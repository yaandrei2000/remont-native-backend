
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AuthCode
 * 
 */
export type AuthCode = $Result.DefaultSelection<Prisma.$AuthCodePayload>
/**
 * Model BugReport
 * 
 */
export type BugReport = $Result.DefaultSelection<Prisma.$BugReportPayload>
/**
 * Model BugReportImage
 * 
 */
export type BugReportImage = $Result.DefaultSelection<Prisma.$BugReportImagePayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model HomePageSection
 * 
 */
export type HomePageSection = $Result.DefaultSelection<Prisma.$HomePageSectionPayload>
/**
 * Model HomePageSectionItem
 * 
 */
export type HomePageSectionItem = $Result.DefaultSelection<Prisma.$HomePageSectionItemPayload>
/**
 * Model MasterApplication
 * 
 */
export type MasterApplication = $Result.DefaultSelection<Prisma.$MasterApplicationPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderStep
 * 
 */
export type OrderStep = $Result.DefaultSelection<Prisma.$OrderStepPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model PromoCodeUsage
 * 
 */
export type PromoCodeUsage = $Result.DefaultSelection<Prisma.$PromoCodeUsagePayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceCity
 * 
 */
export type ServiceCity = $Result.DefaultSelection<Prisma.$ServiceCityPayload>
/**
 * Model Story
 * 
 */
export type Story = $Result.DefaultSelection<Prisma.$StoryPayload>
/**
 * Model StoryImage
 * 
 */
export type StoryImage = $Result.DefaultSelection<Prisma.$StoryImagePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BugReportCategory: {
  UI: 'UI',
  PERFORMANCE: 'PERFORMANCE',
  FUNCTIONALITY: 'FUNCTIONALITY',
  DATA: 'DATA',
  OTHER: 'OTHER'
};

export type BugReportCategory = (typeof BugReportCategory)[keyof typeof BugReportCategory]


export const BugReportPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type BugReportPriority = (typeof BugReportPriority)[keyof typeof BugReportPriority]


export const BugReportStatus: {
  NEW: 'NEW',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type BugReportStatus = (typeof BugReportStatus)[keyof typeof BugReportStatus]


export const ChatStatus: {
  NEW: 'NEW',
  ACTIVE: 'ACTIVE',
  CLOSED: 'CLOSED'
};

export type ChatStatus = (typeof ChatStatus)[keyof typeof ChatStatus]


export const HomePageSectionType: {
  QUICK_SERVICES: 'QUICK_SERVICES',
  SERVICE_CATEGORIES: 'SERVICE_CATEGORIES',
  SEASONAL_SERVICES: 'SEASONAL_SERVICES',
  PROMO_SERVICES: 'PROMO_SERVICES'
};

export type HomePageSectionType = (typeof HomePageSectionType)[keyof typeof HomePageSectionType]


export const MasterApplicationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type MasterApplicationStatus = (typeof MasterApplicationStatus)[keyof typeof MasterApplicationStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderUrgency: {
  URGENT: 'URGENT',
  SCHEDULED: 'SCHEDULED'
};

export type OrderUrgency = (typeof OrderUrgency)[keyof typeof OrderUrgency]


export const StepStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type StepStatus = (typeof StepStatus)[keyof typeof StepStatus]


export const ReferralStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type ReferralStatus = (typeof ReferralStatus)[keyof typeof ReferralStatus]


export const UserRole: {
  CLIENT: 'CLIENT',
  MASTER: 'MASTER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type BugReportCategory = $Enums.BugReportCategory

export const BugReportCategory: typeof $Enums.BugReportCategory

export type BugReportPriority = $Enums.BugReportPriority

export const BugReportPriority: typeof $Enums.BugReportPriority

export type BugReportStatus = $Enums.BugReportStatus

export const BugReportStatus: typeof $Enums.BugReportStatus

export type ChatStatus = $Enums.ChatStatus

export const ChatStatus: typeof $Enums.ChatStatus

export type HomePageSectionType = $Enums.HomePageSectionType

export const HomePageSectionType: typeof $Enums.HomePageSectionType

export type MasterApplicationStatus = $Enums.MasterApplicationStatus

export const MasterApplicationStatus: typeof $Enums.MasterApplicationStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderUrgency = $Enums.OrderUrgency

export const OrderUrgency: typeof $Enums.OrderUrgency

export type StepStatus = $Enums.StepStatus

export const StepStatus: typeof $Enums.StepStatus

export type ReferralStatus = $Enums.ReferralStatus

export const ReferralStatus: typeof $Enums.ReferralStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AuthCodes
 * const authCodes = await prisma.authCode.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AuthCodes
   * const authCodes = await prisma.authCode.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.authCode`: Exposes CRUD operations for the **AuthCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthCodes
    * const authCodes = await prisma.authCode.findMany()
    * ```
    */
  get authCode(): Prisma.AuthCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bugReport`: Exposes CRUD operations for the **BugReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BugReports
    * const bugReports = await prisma.bugReport.findMany()
    * ```
    */
  get bugReport(): Prisma.BugReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bugReportImage`: Exposes CRUD operations for the **BugReportImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BugReportImages
    * const bugReportImages = await prisma.bugReportImage.findMany()
    * ```
    */
  get bugReportImage(): Prisma.BugReportImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.homePageSection`: Exposes CRUD operations for the **HomePageSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomePageSections
    * const homePageSections = await prisma.homePageSection.findMany()
    * ```
    */
  get homePageSection(): Prisma.HomePageSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.homePageSectionItem`: Exposes CRUD operations for the **HomePageSectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomePageSectionItems
    * const homePageSectionItems = await prisma.homePageSectionItem.findMany()
    * ```
    */
  get homePageSectionItem(): Prisma.HomePageSectionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterApplication`: Exposes CRUD operations for the **MasterApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterApplications
    * const masterApplications = await prisma.masterApplication.findMany()
    * ```
    */
  get masterApplication(): Prisma.MasterApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderStep`: Exposes CRUD operations for the **OrderStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderSteps
    * const orderSteps = await prisma.orderStep.findMany()
    * ```
    */
  get orderStep(): Prisma.OrderStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCodeUsage`: Exposes CRUD operations for the **PromoCodeUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodeUsages
    * const promoCodeUsages = await prisma.promoCodeUsage.findMany()
    * ```
    */
  get promoCodeUsage(): Prisma.PromoCodeUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceCity`: Exposes CRUD operations for the **ServiceCity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCities
    * const serviceCities = await prisma.serviceCity.findMany()
    * ```
    */
  get serviceCity(): Prisma.ServiceCityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.story`: Exposes CRUD operations for the **Story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stories
    * const stories = await prisma.story.findMany()
    * ```
    */
  get story(): Prisma.StoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyImage`: Exposes CRUD operations for the **StoryImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryImages
    * const storyImages = await prisma.storyImage.findMany()
    * ```
    */
  get storyImage(): Prisma.StoryImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AuthCode: 'AuthCode',
    BugReport: 'BugReport',
    BugReportImage: 'BugReportImage',
    Chat: 'Chat',
    ChatMessage: 'ChatMessage',
    City: 'City',
    HomePageSection: 'HomePageSection',
    HomePageSectionItem: 'HomePageSectionItem',
    MasterApplication: 'MasterApplication',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderStep: 'OrderStep',
    PromoCode: 'PromoCode',
    PromoCodeUsage: 'PromoCodeUsage',
    Referral: 'Referral',
    Review: 'Review',
    ServiceCategory: 'ServiceCategory',
    Service: 'Service',
    ServiceCity: 'ServiceCity',
    Story: 'Story',
    StoryImage: 'StoryImage',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "authCode" | "bugReport" | "bugReportImage" | "chat" | "chatMessage" | "city" | "homePageSection" | "homePageSectionItem" | "masterApplication" | "order" | "orderItem" | "orderStep" | "promoCode" | "promoCodeUsage" | "referral" | "review" | "serviceCategory" | "service" | "serviceCity" | "story" | "storyImage" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AuthCode: {
        payload: Prisma.$AuthCodePayload<ExtArgs>
        fields: Prisma.AuthCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>
          }
          findFirst: {
            args: Prisma.AuthCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>
          }
          findMany: {
            args: Prisma.AuthCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>[]
          }
          create: {
            args: Prisma.AuthCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>
          }
          createMany: {
            args: Prisma.AuthCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>[]
          }
          delete: {
            args: Prisma.AuthCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>
          }
          update: {
            args: Prisma.AuthCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>
          }
          deleteMany: {
            args: Prisma.AuthCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>[]
          }
          upsert: {
            args: Prisma.AuthCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthCodePayload>
          }
          aggregate: {
            args: Prisma.AuthCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthCode>
          }
          groupBy: {
            args: Prisma.AuthCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthCodeCountArgs<ExtArgs>
            result: $Utils.Optional<AuthCodeCountAggregateOutputType> | number
          }
        }
      }
      BugReport: {
        payload: Prisma.$BugReportPayload<ExtArgs>
        fields: Prisma.BugReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BugReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BugReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          findFirst: {
            args: Prisma.BugReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BugReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          findMany: {
            args: Prisma.BugReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>[]
          }
          create: {
            args: Prisma.BugReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          createMany: {
            args: Prisma.BugReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BugReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>[]
          }
          delete: {
            args: Prisma.BugReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          update: {
            args: Prisma.BugReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          deleteMany: {
            args: Prisma.BugReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BugReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BugReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>[]
          }
          upsert: {
            args: Prisma.BugReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportPayload>
          }
          aggregate: {
            args: Prisma.BugReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBugReport>
          }
          groupBy: {
            args: Prisma.BugReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BugReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BugReportCountArgs<ExtArgs>
            result: $Utils.Optional<BugReportCountAggregateOutputType> | number
          }
        }
      }
      BugReportImage: {
        payload: Prisma.$BugReportImagePayload<ExtArgs>
        fields: Prisma.BugReportImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BugReportImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BugReportImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>
          }
          findFirst: {
            args: Prisma.BugReportImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BugReportImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>
          }
          findMany: {
            args: Prisma.BugReportImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>[]
          }
          create: {
            args: Prisma.BugReportImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>
          }
          createMany: {
            args: Prisma.BugReportImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BugReportImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>[]
          }
          delete: {
            args: Prisma.BugReportImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>
          }
          update: {
            args: Prisma.BugReportImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>
          }
          deleteMany: {
            args: Prisma.BugReportImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BugReportImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BugReportImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>[]
          }
          upsert: {
            args: Prisma.BugReportImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BugReportImagePayload>
          }
          aggregate: {
            args: Prisma.BugReportImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBugReportImage>
          }
          groupBy: {
            args: Prisma.BugReportImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BugReportImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BugReportImageCountArgs<ExtArgs>
            result: $Utils.Optional<BugReportImageCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      HomePageSection: {
        payload: Prisma.$HomePageSectionPayload<ExtArgs>
        fields: Prisma.HomePageSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomePageSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomePageSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>
          }
          findFirst: {
            args: Prisma.HomePageSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomePageSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>
          }
          findMany: {
            args: Prisma.HomePageSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>[]
          }
          create: {
            args: Prisma.HomePageSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>
          }
          createMany: {
            args: Prisma.HomePageSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomePageSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>[]
          }
          delete: {
            args: Prisma.HomePageSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>
          }
          update: {
            args: Prisma.HomePageSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>
          }
          deleteMany: {
            args: Prisma.HomePageSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomePageSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HomePageSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>[]
          }
          upsert: {
            args: Prisma.HomePageSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionPayload>
          }
          aggregate: {
            args: Prisma.HomePageSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomePageSection>
          }
          groupBy: {
            args: Prisma.HomePageSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomePageSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomePageSectionCountArgs<ExtArgs>
            result: $Utils.Optional<HomePageSectionCountAggregateOutputType> | number
          }
        }
      }
      HomePageSectionItem: {
        payload: Prisma.$HomePageSectionItemPayload<ExtArgs>
        fields: Prisma.HomePageSectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomePageSectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomePageSectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>
          }
          findFirst: {
            args: Prisma.HomePageSectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomePageSectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>
          }
          findMany: {
            args: Prisma.HomePageSectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>[]
          }
          create: {
            args: Prisma.HomePageSectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>
          }
          createMany: {
            args: Prisma.HomePageSectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomePageSectionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>[]
          }
          delete: {
            args: Prisma.HomePageSectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>
          }
          update: {
            args: Prisma.HomePageSectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>
          }
          deleteMany: {
            args: Prisma.HomePageSectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomePageSectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HomePageSectionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>[]
          }
          upsert: {
            args: Prisma.HomePageSectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomePageSectionItemPayload>
          }
          aggregate: {
            args: Prisma.HomePageSectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomePageSectionItem>
          }
          groupBy: {
            args: Prisma.HomePageSectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomePageSectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomePageSectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<HomePageSectionItemCountAggregateOutputType> | number
          }
        }
      }
      MasterApplication: {
        payload: Prisma.$MasterApplicationPayload<ExtArgs>
        fields: Prisma.MasterApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>
          }
          findFirst: {
            args: Prisma.MasterApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>
          }
          findMany: {
            args: Prisma.MasterApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>[]
          }
          create: {
            args: Prisma.MasterApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>
          }
          createMany: {
            args: Prisma.MasterApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MasterApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>[]
          }
          delete: {
            args: Prisma.MasterApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>
          }
          update: {
            args: Prisma.MasterApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>
          }
          deleteMany: {
            args: Prisma.MasterApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MasterApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>[]
          }
          upsert: {
            args: Prisma.MasterApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterApplicationPayload>
          }
          aggregate: {
            args: Prisma.MasterApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterApplication>
          }
          groupBy: {
            args: Prisma.MasterApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<MasterApplicationCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderStep: {
        payload: Prisma.$OrderStepPayload<ExtArgs>
        fields: Prisma.OrderStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>
          }
          findFirst: {
            args: Prisma.OrderStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>
          }
          findMany: {
            args: Prisma.OrderStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>[]
          }
          create: {
            args: Prisma.OrderStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>
          }
          createMany: {
            args: Prisma.OrderStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>[]
          }
          delete: {
            args: Prisma.OrderStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>
          }
          update: {
            args: Prisma.OrderStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>
          }
          deleteMany: {
            args: Prisma.OrderStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>[]
          }
          upsert: {
            args: Prisma.OrderStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStepPayload>
          }
          aggregate: {
            args: Prisma.OrderStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStep>
          }
          groupBy: {
            args: Prisma.OrderStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStepCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStepCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      PromoCodeUsage: {
        payload: Prisma.$PromoCodeUsagePayload<ExtArgs>
        fields: Prisma.PromoCodeUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          findMany: {
            args: Prisma.PromoCodeUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>[]
          }
          create: {
            args: Prisma.PromoCodeUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          createMany: {
            args: Prisma.PromoCodeUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          update: {
            args: Prisma.PromoCodeUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCodeUsage>
          }
          groupBy: {
            args: Prisma.PromoCodeUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeUsageCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeUsageCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceCity: {
        payload: Prisma.$ServiceCityPayload<ExtArgs>
        fields: Prisma.ServiceCityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>
          }
          findFirst: {
            args: Prisma.ServiceCityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>
          }
          findMany: {
            args: Prisma.ServiceCityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>[]
          }
          create: {
            args: Prisma.ServiceCityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>
          }
          createMany: {
            args: Prisma.ServiceCityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>[]
          }
          delete: {
            args: Prisma.ServiceCityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>
          }
          update: {
            args: Prisma.ServiceCityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceCityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>[]
          }
          upsert: {
            args: Prisma.ServiceCityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCityPayload>
          }
          aggregate: {
            args: Prisma.ServiceCityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCity>
          }
          groupBy: {
            args: Prisma.ServiceCityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCityCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCityCountAggregateOutputType> | number
          }
        }
      }
      Story: {
        payload: Prisma.$StoryPayload<ExtArgs>
        fields: Prisma.StoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findFirst: {
            args: Prisma.StoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findMany: {
            args: Prisma.StoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          create: {
            args: Prisma.StoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          createMany: {
            args: Prisma.StoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          delete: {
            args: Prisma.StoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          update: {
            args: Prisma.StoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          deleteMany: {
            args: Prisma.StoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          upsert: {
            args: Prisma.StoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          aggregate: {
            args: Prisma.StoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStory>
          }
          groupBy: {
            args: Prisma.StoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCountAggregateOutputType> | number
          }
        }
      }
      StoryImage: {
        payload: Prisma.$StoryImagePayload<ExtArgs>
        fields: Prisma.StoryImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>
          }
          findFirst: {
            args: Prisma.StoryImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>
          }
          findMany: {
            args: Prisma.StoryImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>[]
          }
          create: {
            args: Prisma.StoryImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>
          }
          createMany: {
            args: Prisma.StoryImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>[]
          }
          delete: {
            args: Prisma.StoryImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>
          }
          update: {
            args: Prisma.StoryImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>
          }
          deleteMany: {
            args: Prisma.StoryImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>[]
          }
          upsert: {
            args: Prisma.StoryImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryImagePayload>
          }
          aggregate: {
            args: Prisma.StoryImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryImage>
          }
          groupBy: {
            args: Prisma.StoryImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryImageCountArgs<ExtArgs>
            result: $Utils.Optional<StoryImageCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    authCode?: AuthCodeOmit
    bugReport?: BugReportOmit
    bugReportImage?: BugReportImageOmit
    chat?: ChatOmit
    chatMessage?: ChatMessageOmit
    city?: CityOmit
    homePageSection?: HomePageSectionOmit
    homePageSectionItem?: HomePageSectionItemOmit
    masterApplication?: MasterApplicationOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    orderStep?: OrderStepOmit
    promoCode?: PromoCodeOmit
    promoCodeUsage?: PromoCodeUsageOmit
    referral?: ReferralOmit
    review?: ReviewOmit
    serviceCategory?: ServiceCategoryOmit
    service?: ServiceOmit
    serviceCity?: ServiceCityOmit
    story?: StoryOmit
    storyImage?: StoryImageOmit
    user?: UserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BugReportCountOutputType
   */

  export type BugReportCountOutputType = {
    images: number
  }

  export type BugReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | BugReportCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * BugReportCountOutputType without action
   */
  export type BugReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportCountOutputType
     */
    select?: BugReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BugReportCountOutputType without action
   */
  export type BugReportCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportImageWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    users: number
    services: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CityCountOutputTypeCountUsersArgs
    services?: boolean | CityCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCityWhereInput
  }


  /**
   * Count Type HomePageSectionCountOutputType
   */

  export type HomePageSectionCountOutputType = {
    items: number
  }

  export type HomePageSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | HomePageSectionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * HomePageSectionCountOutputType without action
   */
  export type HomePageSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionCountOutputType
     */
    select?: HomePageSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HomePageSectionCountOutputType without action
   */
  export type HomePageSectionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomePageSectionItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    steps: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    steps?: boolean | OrderCountOutputTypeCountStepsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStepWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    usages: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | PromoCodeCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    services: number
    homePageItems: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategoryCountOutputTypeCountServicesArgs
    homePageItems?: boolean | ServiceCategoryCountOutputTypeCountHomePageItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountHomePageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomePageSectionItemWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    orders: number
    cities: number
    homePageItems: number
    reviews: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ServiceCountOutputTypeCountOrdersArgs
    cities?: boolean | ServiceCountOutputTypeCountCitiesArgs
    homePageItems?: boolean | ServiceCountOutputTypeCountHomePageItemsArgs
    reviews?: boolean | ServiceCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCityWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountHomePageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomePageSectionItemWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type StoryCountOutputType
   */

  export type StoryCountOutputType = {
    images: number
  }

  export type StoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | StoryCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryCountOutputType
     */
    select?: StoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryImageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ordersAsClient: number
    ordersAsMaster: number
    referrals: number
    processedApplications: number
    promoCodeUsages: number
    chatsAsUser: number
    chatsAsManager: number
    bugReports: number
    reviewsGiven: number
    reviewsReceived: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordersAsClient?: boolean | UserCountOutputTypeCountOrdersAsClientArgs
    ordersAsMaster?: boolean | UserCountOutputTypeCountOrdersAsMasterArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    processedApplications?: boolean | UserCountOutputTypeCountProcessedApplicationsArgs
    promoCodeUsages?: boolean | UserCountOutputTypeCountPromoCodeUsagesArgs
    chatsAsUser?: boolean | UserCountOutputTypeCountChatsAsUserArgs
    chatsAsManager?: boolean | UserCountOutputTypeCountChatsAsManagerArgs
    bugReports?: boolean | UserCountOutputTypeCountBugReportsArgs
    reviewsGiven?: boolean | UserCountOutputTypeCountReviewsGivenArgs
    reviewsReceived?: boolean | UserCountOutputTypeCountReviewsReceivedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersAsClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersAsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPromoCodeUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsAsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsAsManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBugReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AuthCode
   */

  export type AggregateAuthCode = {
    _count: AuthCodeCountAggregateOutputType | null
    _min: AuthCodeMinAggregateOutputType | null
    _max: AuthCodeMaxAggregateOutputType | null
  }

  export type AuthCodeMinAggregateOutputType = {
    id: string | null
    phone: string | null
    code: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type AuthCodeMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    code: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type AuthCodeCountAggregateOutputType = {
    id: number
    phone: number
    code: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type AuthCodeMinAggregateInputType = {
    id?: true
    phone?: true
    code?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type AuthCodeMaxAggregateInputType = {
    id?: true
    phone?: true
    code?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type AuthCodeCountAggregateInputType = {
    id?: true
    phone?: true
    code?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type AuthCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthCode to aggregate.
     */
    where?: AuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthCodes to fetch.
     */
    orderBy?: AuthCodeOrderByWithRelationInput | AuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthCodes
    **/
    _count?: true | AuthCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthCodeMaxAggregateInputType
  }

  export type GetAuthCodeAggregateType<T extends AuthCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthCode[P]>
      : GetScalarType<T[P], AggregateAuthCode[P]>
  }




  export type AuthCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthCodeWhereInput
    orderBy?: AuthCodeOrderByWithAggregationInput | AuthCodeOrderByWithAggregationInput[]
    by: AuthCodeScalarFieldEnum[] | AuthCodeScalarFieldEnum
    having?: AuthCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthCodeCountAggregateInputType | true
    _min?: AuthCodeMinAggregateInputType
    _max?: AuthCodeMaxAggregateInputType
  }

  export type AuthCodeGroupByOutputType = {
    id: string
    phone: string
    code: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: AuthCodeCountAggregateOutputType | null
    _min: AuthCodeMinAggregateOutputType | null
    _max: AuthCodeMaxAggregateOutputType | null
  }

  type GetAuthCodeGroupByPayload<T extends AuthCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthCodeGroupByOutputType[P]>
            : GetScalarType<T[P], AuthCodeGroupByOutputType[P]>
        }
      >
    >


  export type AuthCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["authCode"]>

  export type AuthCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["authCode"]>

  export type AuthCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["authCode"]>

  export type AuthCodeSelectScalar = {
    id?: boolean
    phone?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type AuthCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "code" | "expiresAt" | "used" | "createdAt", ExtArgs["result"]["authCode"]>

  export type $AuthCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      code: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["authCode"]>
    composites: {}
  }

  type AuthCodeGetPayload<S extends boolean | null | undefined | AuthCodeDefaultArgs> = $Result.GetResult<Prisma.$AuthCodePayload, S>

  type AuthCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthCodeCountAggregateInputType | true
    }

  export interface AuthCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthCode'], meta: { name: 'AuthCode' } }
    /**
     * Find zero or one AuthCode that matches the filter.
     * @param {AuthCodeFindUniqueArgs} args - Arguments to find a AuthCode
     * @example
     * // Get one AuthCode
     * const authCode = await prisma.authCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthCodeFindUniqueArgs>(args: SelectSubset<T, AuthCodeFindUniqueArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthCodeFindUniqueOrThrowArgs} args - Arguments to find a AuthCode
     * @example
     * // Get one AuthCode
     * const authCode = await prisma.authCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeFindFirstArgs} args - Arguments to find a AuthCode
     * @example
     * // Get one AuthCode
     * const authCode = await prisma.authCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthCodeFindFirstArgs>(args?: SelectSubset<T, AuthCodeFindFirstArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeFindFirstOrThrowArgs} args - Arguments to find a AuthCode
     * @example
     * // Get one AuthCode
     * const authCode = await prisma.authCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthCodes
     * const authCodes = await prisma.authCode.findMany()
     * 
     * // Get first 10 AuthCodes
     * const authCodes = await prisma.authCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authCodeWithIdOnly = await prisma.authCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthCodeFindManyArgs>(args?: SelectSubset<T, AuthCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthCode.
     * @param {AuthCodeCreateArgs} args - Arguments to create a AuthCode.
     * @example
     * // Create one AuthCode
     * const AuthCode = await prisma.authCode.create({
     *   data: {
     *     // ... data to create a AuthCode
     *   }
     * })
     * 
     */
    create<T extends AuthCodeCreateArgs>(args: SelectSubset<T, AuthCodeCreateArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthCodes.
     * @param {AuthCodeCreateManyArgs} args - Arguments to create many AuthCodes.
     * @example
     * // Create many AuthCodes
     * const authCode = await prisma.authCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthCodeCreateManyArgs>(args?: SelectSubset<T, AuthCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthCodes and returns the data saved in the database.
     * @param {AuthCodeCreateManyAndReturnArgs} args - Arguments to create many AuthCodes.
     * @example
     * // Create many AuthCodes
     * const authCode = await prisma.authCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthCodes and only return the `id`
     * const authCodeWithIdOnly = await prisma.authCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthCode.
     * @param {AuthCodeDeleteArgs} args - Arguments to delete one AuthCode.
     * @example
     * // Delete one AuthCode
     * const AuthCode = await prisma.authCode.delete({
     *   where: {
     *     // ... filter to delete one AuthCode
     *   }
     * })
     * 
     */
    delete<T extends AuthCodeDeleteArgs>(args: SelectSubset<T, AuthCodeDeleteArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthCode.
     * @param {AuthCodeUpdateArgs} args - Arguments to update one AuthCode.
     * @example
     * // Update one AuthCode
     * const authCode = await prisma.authCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthCodeUpdateArgs>(args: SelectSubset<T, AuthCodeUpdateArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthCodes.
     * @param {AuthCodeDeleteManyArgs} args - Arguments to filter AuthCodes to delete.
     * @example
     * // Delete a few AuthCodes
     * const { count } = await prisma.authCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthCodeDeleteManyArgs>(args?: SelectSubset<T, AuthCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthCodes
     * const authCode = await prisma.authCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthCodeUpdateManyArgs>(args: SelectSubset<T, AuthCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthCodes and returns the data updated in the database.
     * @param {AuthCodeUpdateManyAndReturnArgs} args - Arguments to update many AuthCodes.
     * @example
     * // Update many AuthCodes
     * const authCode = await prisma.authCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthCodes and only return the `id`
     * const authCodeWithIdOnly = await prisma.authCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthCode.
     * @param {AuthCodeUpsertArgs} args - Arguments to update or create a AuthCode.
     * @example
     * // Update or create a AuthCode
     * const authCode = await prisma.authCode.upsert({
     *   create: {
     *     // ... data to create a AuthCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthCode we want to update
     *   }
     * })
     */
    upsert<T extends AuthCodeUpsertArgs>(args: SelectSubset<T, AuthCodeUpsertArgs<ExtArgs>>): Prisma__AuthCodeClient<$Result.GetResult<Prisma.$AuthCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeCountArgs} args - Arguments to filter AuthCodes to count.
     * @example
     * // Count the number of AuthCodes
     * const count = await prisma.authCode.count({
     *   where: {
     *     // ... the filter for the AuthCodes we want to count
     *   }
     * })
    **/
    count<T extends AuthCodeCountArgs>(
      args?: Subset<T, AuthCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthCodeAggregateArgs>(args: Subset<T, AuthCodeAggregateArgs>): Prisma.PrismaPromise<GetAuthCodeAggregateType<T>>

    /**
     * Group by AuthCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthCodeGroupByArgs['orderBy'] }
        : { orderBy?: AuthCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthCode model
   */
  readonly fields: AuthCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthCode model
   */
  interface AuthCodeFieldRefs {
    readonly id: FieldRef<"AuthCode", 'String'>
    readonly phone: FieldRef<"AuthCode", 'String'>
    readonly code: FieldRef<"AuthCode", 'String'>
    readonly expiresAt: FieldRef<"AuthCode", 'DateTime'>
    readonly used: FieldRef<"AuthCode", 'Boolean'>
    readonly createdAt: FieldRef<"AuthCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthCode findUnique
   */
  export type AuthCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * Filter, which AuthCode to fetch.
     */
    where: AuthCodeWhereUniqueInput
  }

  /**
   * AuthCode findUniqueOrThrow
   */
  export type AuthCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * Filter, which AuthCode to fetch.
     */
    where: AuthCodeWhereUniqueInput
  }

  /**
   * AuthCode findFirst
   */
  export type AuthCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * Filter, which AuthCode to fetch.
     */
    where?: AuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthCodes to fetch.
     */
    orderBy?: AuthCodeOrderByWithRelationInput | AuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthCodes.
     */
    cursor?: AuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthCodes.
     */
    distinct?: AuthCodeScalarFieldEnum | AuthCodeScalarFieldEnum[]
  }

  /**
   * AuthCode findFirstOrThrow
   */
  export type AuthCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * Filter, which AuthCode to fetch.
     */
    where?: AuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthCodes to fetch.
     */
    orderBy?: AuthCodeOrderByWithRelationInput | AuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthCodes.
     */
    cursor?: AuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthCodes.
     */
    distinct?: AuthCodeScalarFieldEnum | AuthCodeScalarFieldEnum[]
  }

  /**
   * AuthCode findMany
   */
  export type AuthCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * Filter, which AuthCodes to fetch.
     */
    where?: AuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthCodes to fetch.
     */
    orderBy?: AuthCodeOrderByWithRelationInput | AuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthCodes.
     */
    cursor?: AuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthCodes.
     */
    skip?: number
    distinct?: AuthCodeScalarFieldEnum | AuthCodeScalarFieldEnum[]
  }

  /**
   * AuthCode create
   */
  export type AuthCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * The data needed to create a AuthCode.
     */
    data: XOR<AuthCodeCreateInput, AuthCodeUncheckedCreateInput>
  }

  /**
   * AuthCode createMany
   */
  export type AuthCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthCodes.
     */
    data: AuthCodeCreateManyInput | AuthCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthCode createManyAndReturn
   */
  export type AuthCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * The data used to create many AuthCodes.
     */
    data: AuthCodeCreateManyInput | AuthCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthCode update
   */
  export type AuthCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * The data needed to update a AuthCode.
     */
    data: XOR<AuthCodeUpdateInput, AuthCodeUncheckedUpdateInput>
    /**
     * Choose, which AuthCode to update.
     */
    where: AuthCodeWhereUniqueInput
  }

  /**
   * AuthCode updateMany
   */
  export type AuthCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthCodes.
     */
    data: XOR<AuthCodeUpdateManyMutationInput, AuthCodeUncheckedUpdateManyInput>
    /**
     * Filter which AuthCodes to update
     */
    where?: AuthCodeWhereInput
    /**
     * Limit how many AuthCodes to update.
     */
    limit?: number
  }

  /**
   * AuthCode updateManyAndReturn
   */
  export type AuthCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * The data used to update AuthCodes.
     */
    data: XOR<AuthCodeUpdateManyMutationInput, AuthCodeUncheckedUpdateManyInput>
    /**
     * Filter which AuthCodes to update
     */
    where?: AuthCodeWhereInput
    /**
     * Limit how many AuthCodes to update.
     */
    limit?: number
  }

  /**
   * AuthCode upsert
   */
  export type AuthCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * The filter to search for the AuthCode to update in case it exists.
     */
    where: AuthCodeWhereUniqueInput
    /**
     * In case the AuthCode found by the `where` argument doesn't exist, create a new AuthCode with this data.
     */
    create: XOR<AuthCodeCreateInput, AuthCodeUncheckedCreateInput>
    /**
     * In case the AuthCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthCodeUpdateInput, AuthCodeUncheckedUpdateInput>
  }

  /**
   * AuthCode delete
   */
  export type AuthCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
    /**
     * Filter which AuthCode to delete.
     */
    where: AuthCodeWhereUniqueInput
  }

  /**
   * AuthCode deleteMany
   */
  export type AuthCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthCodes to delete
     */
    where?: AuthCodeWhereInput
    /**
     * Limit how many AuthCodes to delete.
     */
    limit?: number
  }

  /**
   * AuthCode without action
   */
  export type AuthCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthCode
     */
    select?: AuthCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthCode
     */
    omit?: AuthCodeOmit<ExtArgs> | null
  }


  /**
   * Model BugReport
   */

  export type AggregateBugReport = {
    _count: BugReportCountAggregateOutputType | null
    _min: BugReportMinAggregateOutputType | null
    _max: BugReportMaxAggregateOutputType | null
  }

  export type BugReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    category: $Enums.BugReportCategory | null
    priority: $Enums.BugReportPriority | null
    status: $Enums.BugReportStatus | null
    description: string | null
    steps: string | null
    email: string | null
    logFileUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type BugReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    category: $Enums.BugReportCategory | null
    priority: $Enums.BugReportPriority | null
    status: $Enums.BugReportStatus | null
    description: string | null
    steps: string | null
    email: string | null
    logFileUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type BugReportCountAggregateOutputType = {
    id: number
    userId: number
    category: number
    priority: number
    status: number
    description: number
    steps: number
    email: number
    logFileUrl: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type BugReportMinAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    status?: true
    description?: true
    steps?: true
    email?: true
    logFileUrl?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type BugReportMaxAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    status?: true
    description?: true
    steps?: true
    email?: true
    logFileUrl?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type BugReportCountAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    status?: true
    description?: true
    steps?: true
    email?: true
    logFileUrl?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type BugReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReport to aggregate.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BugReports
    **/
    _count?: true | BugReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BugReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BugReportMaxAggregateInputType
  }

  export type GetBugReportAggregateType<T extends BugReportAggregateArgs> = {
        [P in keyof T & keyof AggregateBugReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBugReport[P]>
      : GetScalarType<T[P], AggregateBugReport[P]>
  }




  export type BugReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportWhereInput
    orderBy?: BugReportOrderByWithAggregationInput | BugReportOrderByWithAggregationInput[]
    by: BugReportScalarFieldEnum[] | BugReportScalarFieldEnum
    having?: BugReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BugReportCountAggregateInputType | true
    _min?: BugReportMinAggregateInputType
    _max?: BugReportMaxAggregateInputType
  }

  export type BugReportGroupByOutputType = {
    id: string
    userId: string | null
    category: $Enums.BugReportCategory
    priority: $Enums.BugReportPriority
    status: $Enums.BugReportStatus
    description: string
    steps: string | null
    email: string
    logFileUrl: string | null
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: BugReportCountAggregateOutputType | null
    _min: BugReportMinAggregateOutputType | null
    _max: BugReportMaxAggregateOutputType | null
  }

  type GetBugReportGroupByPayload<T extends BugReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BugReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BugReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BugReportGroupByOutputType[P]>
            : GetScalarType<T[P], BugReportGroupByOutputType[P]>
        }
      >
    >


  export type BugReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    description?: boolean
    steps?: boolean
    email?: boolean
    logFileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | BugReport$userArgs<ExtArgs>
    images?: boolean | BugReport$imagesArgs<ExtArgs>
    _count?: boolean | BugReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bugReport"]>

  export type BugReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    description?: boolean
    steps?: boolean
    email?: boolean
    logFileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | BugReport$userArgs<ExtArgs>
  }, ExtArgs["result"]["bugReport"]>

  export type BugReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    description?: boolean
    steps?: boolean
    email?: boolean
    logFileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    user?: boolean | BugReport$userArgs<ExtArgs>
  }, ExtArgs["result"]["bugReport"]>

  export type BugReportSelectScalar = {
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    description?: boolean
    steps?: boolean
    email?: boolean
    logFileUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type BugReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "category" | "priority" | "status" | "description" | "steps" | "email" | "logFileUrl" | "createdAt" | "updatedAt" | "resolvedAt", ExtArgs["result"]["bugReport"]>
  export type BugReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BugReport$userArgs<ExtArgs>
    images?: boolean | BugReport$imagesArgs<ExtArgs>
    _count?: boolean | BugReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BugReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BugReport$userArgs<ExtArgs>
  }
  export type BugReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BugReport$userArgs<ExtArgs>
  }

  export type $BugReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BugReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      images: Prisma.$BugReportImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      category: $Enums.BugReportCategory
      priority: $Enums.BugReportPriority
      status: $Enums.BugReportStatus
      description: string
      steps: string | null
      email: string
      logFileUrl: string | null
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["bugReport"]>
    composites: {}
  }

  type BugReportGetPayload<S extends boolean | null | undefined | BugReportDefaultArgs> = $Result.GetResult<Prisma.$BugReportPayload, S>

  type BugReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BugReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BugReportCountAggregateInputType | true
    }

  export interface BugReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BugReport'], meta: { name: 'BugReport' } }
    /**
     * Find zero or one BugReport that matches the filter.
     * @param {BugReportFindUniqueArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BugReportFindUniqueArgs>(args: SelectSubset<T, BugReportFindUniqueArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BugReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BugReportFindUniqueOrThrowArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BugReportFindUniqueOrThrowArgs>(args: SelectSubset<T, BugReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BugReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportFindFirstArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BugReportFindFirstArgs>(args?: SelectSubset<T, BugReportFindFirstArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BugReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportFindFirstOrThrowArgs} args - Arguments to find a BugReport
     * @example
     * // Get one BugReport
     * const bugReport = await prisma.bugReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BugReportFindFirstOrThrowArgs>(args?: SelectSubset<T, BugReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BugReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BugReports
     * const bugReports = await prisma.bugReport.findMany()
     * 
     * // Get first 10 BugReports
     * const bugReports = await prisma.bugReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bugReportWithIdOnly = await prisma.bugReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BugReportFindManyArgs>(args?: SelectSubset<T, BugReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BugReport.
     * @param {BugReportCreateArgs} args - Arguments to create a BugReport.
     * @example
     * // Create one BugReport
     * const BugReport = await prisma.bugReport.create({
     *   data: {
     *     // ... data to create a BugReport
     *   }
     * })
     * 
     */
    create<T extends BugReportCreateArgs>(args: SelectSubset<T, BugReportCreateArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BugReports.
     * @param {BugReportCreateManyArgs} args - Arguments to create many BugReports.
     * @example
     * // Create many BugReports
     * const bugReport = await prisma.bugReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BugReportCreateManyArgs>(args?: SelectSubset<T, BugReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BugReports and returns the data saved in the database.
     * @param {BugReportCreateManyAndReturnArgs} args - Arguments to create many BugReports.
     * @example
     * // Create many BugReports
     * const bugReport = await prisma.bugReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BugReports and only return the `id`
     * const bugReportWithIdOnly = await prisma.bugReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BugReportCreateManyAndReturnArgs>(args?: SelectSubset<T, BugReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BugReport.
     * @param {BugReportDeleteArgs} args - Arguments to delete one BugReport.
     * @example
     * // Delete one BugReport
     * const BugReport = await prisma.bugReport.delete({
     *   where: {
     *     // ... filter to delete one BugReport
     *   }
     * })
     * 
     */
    delete<T extends BugReportDeleteArgs>(args: SelectSubset<T, BugReportDeleteArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BugReport.
     * @param {BugReportUpdateArgs} args - Arguments to update one BugReport.
     * @example
     * // Update one BugReport
     * const bugReport = await prisma.bugReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BugReportUpdateArgs>(args: SelectSubset<T, BugReportUpdateArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BugReports.
     * @param {BugReportDeleteManyArgs} args - Arguments to filter BugReports to delete.
     * @example
     * // Delete a few BugReports
     * const { count } = await prisma.bugReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BugReportDeleteManyArgs>(args?: SelectSubset<T, BugReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BugReports
     * const bugReport = await prisma.bugReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BugReportUpdateManyArgs>(args: SelectSubset<T, BugReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReports and returns the data updated in the database.
     * @param {BugReportUpdateManyAndReturnArgs} args - Arguments to update many BugReports.
     * @example
     * // Update many BugReports
     * const bugReport = await prisma.bugReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BugReports and only return the `id`
     * const bugReportWithIdOnly = await prisma.bugReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BugReportUpdateManyAndReturnArgs>(args: SelectSubset<T, BugReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BugReport.
     * @param {BugReportUpsertArgs} args - Arguments to update or create a BugReport.
     * @example
     * // Update or create a BugReport
     * const bugReport = await prisma.bugReport.upsert({
     *   create: {
     *     // ... data to create a BugReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BugReport we want to update
     *   }
     * })
     */
    upsert<T extends BugReportUpsertArgs>(args: SelectSubset<T, BugReportUpsertArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BugReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportCountArgs} args - Arguments to filter BugReports to count.
     * @example
     * // Count the number of BugReports
     * const count = await prisma.bugReport.count({
     *   where: {
     *     // ... the filter for the BugReports we want to count
     *   }
     * })
    **/
    count<T extends BugReportCountArgs>(
      args?: Subset<T, BugReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BugReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BugReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BugReportAggregateArgs>(args: Subset<T, BugReportAggregateArgs>): Prisma.PrismaPromise<GetBugReportAggregateType<T>>

    /**
     * Group by BugReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BugReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BugReportGroupByArgs['orderBy'] }
        : { orderBy?: BugReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BugReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBugReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BugReport model
   */
  readonly fields: BugReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BugReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BugReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BugReport$userArgs<ExtArgs> = {}>(args?: Subset<T, BugReport$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends BugReport$imagesArgs<ExtArgs> = {}>(args?: Subset<T, BugReport$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BugReport model
   */
  interface BugReportFieldRefs {
    readonly id: FieldRef<"BugReport", 'String'>
    readonly userId: FieldRef<"BugReport", 'String'>
    readonly category: FieldRef<"BugReport", 'BugReportCategory'>
    readonly priority: FieldRef<"BugReport", 'BugReportPriority'>
    readonly status: FieldRef<"BugReport", 'BugReportStatus'>
    readonly description: FieldRef<"BugReport", 'String'>
    readonly steps: FieldRef<"BugReport", 'String'>
    readonly email: FieldRef<"BugReport", 'String'>
    readonly logFileUrl: FieldRef<"BugReport", 'String'>
    readonly createdAt: FieldRef<"BugReport", 'DateTime'>
    readonly updatedAt: FieldRef<"BugReport", 'DateTime'>
    readonly resolvedAt: FieldRef<"BugReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BugReport findUnique
   */
  export type BugReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport findUniqueOrThrow
   */
  export type BugReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport findFirst
   */
  export type BugReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReports.
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReports.
     */
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * BugReport findFirstOrThrow
   */
  export type BugReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReport to fetch.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReports.
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReports.
     */
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * BugReport findMany
   */
  export type BugReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter, which BugReports to fetch.
     */
    where?: BugReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReports to fetch.
     */
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BugReports.
     */
    cursor?: BugReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReports.
     */
    skip?: number
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * BugReport create
   */
  export type BugReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * The data needed to create a BugReport.
     */
    data: XOR<BugReportCreateInput, BugReportUncheckedCreateInput>
  }

  /**
   * BugReport createMany
   */
  export type BugReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BugReports.
     */
    data: BugReportCreateManyInput | BugReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BugReport createManyAndReturn
   */
  export type BugReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * The data used to create many BugReports.
     */
    data: BugReportCreateManyInput | BugReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BugReport update
   */
  export type BugReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * The data needed to update a BugReport.
     */
    data: XOR<BugReportUpdateInput, BugReportUncheckedUpdateInput>
    /**
     * Choose, which BugReport to update.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport updateMany
   */
  export type BugReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BugReports.
     */
    data: XOR<BugReportUpdateManyMutationInput, BugReportUncheckedUpdateManyInput>
    /**
     * Filter which BugReports to update
     */
    where?: BugReportWhereInput
    /**
     * Limit how many BugReports to update.
     */
    limit?: number
  }

  /**
   * BugReport updateManyAndReturn
   */
  export type BugReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * The data used to update BugReports.
     */
    data: XOR<BugReportUpdateManyMutationInput, BugReportUncheckedUpdateManyInput>
    /**
     * Filter which BugReports to update
     */
    where?: BugReportWhereInput
    /**
     * Limit how many BugReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BugReport upsert
   */
  export type BugReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * The filter to search for the BugReport to update in case it exists.
     */
    where: BugReportWhereUniqueInput
    /**
     * In case the BugReport found by the `where` argument doesn't exist, create a new BugReport with this data.
     */
    create: XOR<BugReportCreateInput, BugReportUncheckedCreateInput>
    /**
     * In case the BugReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BugReportUpdateInput, BugReportUncheckedUpdateInput>
  }

  /**
   * BugReport delete
   */
  export type BugReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    /**
     * Filter which BugReport to delete.
     */
    where: BugReportWhereUniqueInput
  }

  /**
   * BugReport deleteMany
   */
  export type BugReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReports to delete
     */
    where?: BugReportWhereInput
    /**
     * Limit how many BugReports to delete.
     */
    limit?: number
  }

  /**
   * BugReport.user
   */
  export type BugReport$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BugReport.images
   */
  export type BugReport$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    where?: BugReportImageWhereInput
    orderBy?: BugReportImageOrderByWithRelationInput | BugReportImageOrderByWithRelationInput[]
    cursor?: BugReportImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BugReportImageScalarFieldEnum | BugReportImageScalarFieldEnum[]
  }

  /**
   * BugReport without action
   */
  export type BugReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
  }


  /**
   * Model BugReportImage
   */

  export type AggregateBugReportImage = {
    _count: BugReportImageCountAggregateOutputType | null
    _avg: BugReportImageAvgAggregateOutputType | null
    _sum: BugReportImageSumAggregateOutputType | null
    _min: BugReportImageMinAggregateOutputType | null
    _max: BugReportImageMaxAggregateOutputType | null
  }

  export type BugReportImageAvgAggregateOutputType = {
    order: number | null
  }

  export type BugReportImageSumAggregateOutputType = {
    order: number | null
  }

  export type BugReportImageMinAggregateOutputType = {
    id: string | null
    bugReportId: string | null
    imageUrl: string | null
    order: number | null
    createdAt: Date | null
  }

  export type BugReportImageMaxAggregateOutputType = {
    id: string | null
    bugReportId: string | null
    imageUrl: string | null
    order: number | null
    createdAt: Date | null
  }

  export type BugReportImageCountAggregateOutputType = {
    id: number
    bugReportId: number
    imageUrl: number
    order: number
    createdAt: number
    _all: number
  }


  export type BugReportImageAvgAggregateInputType = {
    order?: true
  }

  export type BugReportImageSumAggregateInputType = {
    order?: true
  }

  export type BugReportImageMinAggregateInputType = {
    id?: true
    bugReportId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
  }

  export type BugReportImageMaxAggregateInputType = {
    id?: true
    bugReportId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
  }

  export type BugReportImageCountAggregateInputType = {
    id?: true
    bugReportId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type BugReportImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReportImage to aggregate.
     */
    where?: BugReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReportImages to fetch.
     */
    orderBy?: BugReportImageOrderByWithRelationInput | BugReportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BugReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReportImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BugReportImages
    **/
    _count?: true | BugReportImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BugReportImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BugReportImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BugReportImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BugReportImageMaxAggregateInputType
  }

  export type GetBugReportImageAggregateType<T extends BugReportImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBugReportImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBugReportImage[P]>
      : GetScalarType<T[P], AggregateBugReportImage[P]>
  }




  export type BugReportImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BugReportImageWhereInput
    orderBy?: BugReportImageOrderByWithAggregationInput | BugReportImageOrderByWithAggregationInput[]
    by: BugReportImageScalarFieldEnum[] | BugReportImageScalarFieldEnum
    having?: BugReportImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BugReportImageCountAggregateInputType | true
    _avg?: BugReportImageAvgAggregateInputType
    _sum?: BugReportImageSumAggregateInputType
    _min?: BugReportImageMinAggregateInputType
    _max?: BugReportImageMaxAggregateInputType
  }

  export type BugReportImageGroupByOutputType = {
    id: string
    bugReportId: string
    imageUrl: string
    order: number
    createdAt: Date
    _count: BugReportImageCountAggregateOutputType | null
    _avg: BugReportImageAvgAggregateOutputType | null
    _sum: BugReportImageSumAggregateOutputType | null
    _min: BugReportImageMinAggregateOutputType | null
    _max: BugReportImageMaxAggregateOutputType | null
  }

  type GetBugReportImageGroupByPayload<T extends BugReportImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BugReportImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BugReportImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BugReportImageGroupByOutputType[P]>
            : GetScalarType<T[P], BugReportImageGroupByOutputType[P]>
        }
      >
    >


  export type BugReportImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bugReportId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    bugReport?: boolean | BugReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bugReportImage"]>

  export type BugReportImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bugReportId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    bugReport?: boolean | BugReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bugReportImage"]>

  export type BugReportImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bugReportId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    bugReport?: boolean | BugReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bugReportImage"]>

  export type BugReportImageSelectScalar = {
    id?: boolean
    bugReportId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type BugReportImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bugReportId" | "imageUrl" | "order" | "createdAt", ExtArgs["result"]["bugReportImage"]>
  export type BugReportImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bugReport?: boolean | BugReportDefaultArgs<ExtArgs>
  }
  export type BugReportImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bugReport?: boolean | BugReportDefaultArgs<ExtArgs>
  }
  export type BugReportImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bugReport?: boolean | BugReportDefaultArgs<ExtArgs>
  }

  export type $BugReportImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BugReportImage"
    objects: {
      bugReport: Prisma.$BugReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bugReportId: string
      imageUrl: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["bugReportImage"]>
    composites: {}
  }

  type BugReportImageGetPayload<S extends boolean | null | undefined | BugReportImageDefaultArgs> = $Result.GetResult<Prisma.$BugReportImagePayload, S>

  type BugReportImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BugReportImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BugReportImageCountAggregateInputType | true
    }

  export interface BugReportImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BugReportImage'], meta: { name: 'BugReportImage' } }
    /**
     * Find zero or one BugReportImage that matches the filter.
     * @param {BugReportImageFindUniqueArgs} args - Arguments to find a BugReportImage
     * @example
     * // Get one BugReportImage
     * const bugReportImage = await prisma.bugReportImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BugReportImageFindUniqueArgs>(args: SelectSubset<T, BugReportImageFindUniqueArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BugReportImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BugReportImageFindUniqueOrThrowArgs} args - Arguments to find a BugReportImage
     * @example
     * // Get one BugReportImage
     * const bugReportImage = await prisma.bugReportImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BugReportImageFindUniqueOrThrowArgs>(args: SelectSubset<T, BugReportImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BugReportImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageFindFirstArgs} args - Arguments to find a BugReportImage
     * @example
     * // Get one BugReportImage
     * const bugReportImage = await prisma.bugReportImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BugReportImageFindFirstArgs>(args?: SelectSubset<T, BugReportImageFindFirstArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BugReportImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageFindFirstOrThrowArgs} args - Arguments to find a BugReportImage
     * @example
     * // Get one BugReportImage
     * const bugReportImage = await prisma.bugReportImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BugReportImageFindFirstOrThrowArgs>(args?: SelectSubset<T, BugReportImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BugReportImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BugReportImages
     * const bugReportImages = await prisma.bugReportImage.findMany()
     * 
     * // Get first 10 BugReportImages
     * const bugReportImages = await prisma.bugReportImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bugReportImageWithIdOnly = await prisma.bugReportImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BugReportImageFindManyArgs>(args?: SelectSubset<T, BugReportImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BugReportImage.
     * @param {BugReportImageCreateArgs} args - Arguments to create a BugReportImage.
     * @example
     * // Create one BugReportImage
     * const BugReportImage = await prisma.bugReportImage.create({
     *   data: {
     *     // ... data to create a BugReportImage
     *   }
     * })
     * 
     */
    create<T extends BugReportImageCreateArgs>(args: SelectSubset<T, BugReportImageCreateArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BugReportImages.
     * @param {BugReportImageCreateManyArgs} args - Arguments to create many BugReportImages.
     * @example
     * // Create many BugReportImages
     * const bugReportImage = await prisma.bugReportImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BugReportImageCreateManyArgs>(args?: SelectSubset<T, BugReportImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BugReportImages and returns the data saved in the database.
     * @param {BugReportImageCreateManyAndReturnArgs} args - Arguments to create many BugReportImages.
     * @example
     * // Create many BugReportImages
     * const bugReportImage = await prisma.bugReportImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BugReportImages and only return the `id`
     * const bugReportImageWithIdOnly = await prisma.bugReportImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BugReportImageCreateManyAndReturnArgs>(args?: SelectSubset<T, BugReportImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BugReportImage.
     * @param {BugReportImageDeleteArgs} args - Arguments to delete one BugReportImage.
     * @example
     * // Delete one BugReportImage
     * const BugReportImage = await prisma.bugReportImage.delete({
     *   where: {
     *     // ... filter to delete one BugReportImage
     *   }
     * })
     * 
     */
    delete<T extends BugReportImageDeleteArgs>(args: SelectSubset<T, BugReportImageDeleteArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BugReportImage.
     * @param {BugReportImageUpdateArgs} args - Arguments to update one BugReportImage.
     * @example
     * // Update one BugReportImage
     * const bugReportImage = await prisma.bugReportImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BugReportImageUpdateArgs>(args: SelectSubset<T, BugReportImageUpdateArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BugReportImages.
     * @param {BugReportImageDeleteManyArgs} args - Arguments to filter BugReportImages to delete.
     * @example
     * // Delete a few BugReportImages
     * const { count } = await prisma.bugReportImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BugReportImageDeleteManyArgs>(args?: SelectSubset<T, BugReportImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BugReportImages
     * const bugReportImage = await prisma.bugReportImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BugReportImageUpdateManyArgs>(args: SelectSubset<T, BugReportImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BugReportImages and returns the data updated in the database.
     * @param {BugReportImageUpdateManyAndReturnArgs} args - Arguments to update many BugReportImages.
     * @example
     * // Update many BugReportImages
     * const bugReportImage = await prisma.bugReportImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BugReportImages and only return the `id`
     * const bugReportImageWithIdOnly = await prisma.bugReportImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BugReportImageUpdateManyAndReturnArgs>(args: SelectSubset<T, BugReportImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BugReportImage.
     * @param {BugReportImageUpsertArgs} args - Arguments to update or create a BugReportImage.
     * @example
     * // Update or create a BugReportImage
     * const bugReportImage = await prisma.bugReportImage.upsert({
     *   create: {
     *     // ... data to create a BugReportImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BugReportImage we want to update
     *   }
     * })
     */
    upsert<T extends BugReportImageUpsertArgs>(args: SelectSubset<T, BugReportImageUpsertArgs<ExtArgs>>): Prisma__BugReportImageClient<$Result.GetResult<Prisma.$BugReportImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BugReportImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageCountArgs} args - Arguments to filter BugReportImages to count.
     * @example
     * // Count the number of BugReportImages
     * const count = await prisma.bugReportImage.count({
     *   where: {
     *     // ... the filter for the BugReportImages we want to count
     *   }
     * })
    **/
    count<T extends BugReportImageCountArgs>(
      args?: Subset<T, BugReportImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BugReportImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BugReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BugReportImageAggregateArgs>(args: Subset<T, BugReportImageAggregateArgs>): Prisma.PrismaPromise<GetBugReportImageAggregateType<T>>

    /**
     * Group by BugReportImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BugReportImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BugReportImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BugReportImageGroupByArgs['orderBy'] }
        : { orderBy?: BugReportImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BugReportImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBugReportImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BugReportImage model
   */
  readonly fields: BugReportImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BugReportImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BugReportImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bugReport<T extends BugReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BugReportDefaultArgs<ExtArgs>>): Prisma__BugReportClient<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BugReportImage model
   */
  interface BugReportImageFieldRefs {
    readonly id: FieldRef<"BugReportImage", 'String'>
    readonly bugReportId: FieldRef<"BugReportImage", 'String'>
    readonly imageUrl: FieldRef<"BugReportImage", 'String'>
    readonly order: FieldRef<"BugReportImage", 'Int'>
    readonly createdAt: FieldRef<"BugReportImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BugReportImage findUnique
   */
  export type BugReportImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * Filter, which BugReportImage to fetch.
     */
    where: BugReportImageWhereUniqueInput
  }

  /**
   * BugReportImage findUniqueOrThrow
   */
  export type BugReportImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * Filter, which BugReportImage to fetch.
     */
    where: BugReportImageWhereUniqueInput
  }

  /**
   * BugReportImage findFirst
   */
  export type BugReportImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * Filter, which BugReportImage to fetch.
     */
    where?: BugReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReportImages to fetch.
     */
    orderBy?: BugReportImageOrderByWithRelationInput | BugReportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReportImages.
     */
    cursor?: BugReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReportImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReportImages.
     */
    distinct?: BugReportImageScalarFieldEnum | BugReportImageScalarFieldEnum[]
  }

  /**
   * BugReportImage findFirstOrThrow
   */
  export type BugReportImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * Filter, which BugReportImage to fetch.
     */
    where?: BugReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReportImages to fetch.
     */
    orderBy?: BugReportImageOrderByWithRelationInput | BugReportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BugReportImages.
     */
    cursor?: BugReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReportImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BugReportImages.
     */
    distinct?: BugReportImageScalarFieldEnum | BugReportImageScalarFieldEnum[]
  }

  /**
   * BugReportImage findMany
   */
  export type BugReportImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * Filter, which BugReportImages to fetch.
     */
    where?: BugReportImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BugReportImages to fetch.
     */
    orderBy?: BugReportImageOrderByWithRelationInput | BugReportImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BugReportImages.
     */
    cursor?: BugReportImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BugReportImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BugReportImages.
     */
    skip?: number
    distinct?: BugReportImageScalarFieldEnum | BugReportImageScalarFieldEnum[]
  }

  /**
   * BugReportImage create
   */
  export type BugReportImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * The data needed to create a BugReportImage.
     */
    data: XOR<BugReportImageCreateInput, BugReportImageUncheckedCreateInput>
  }

  /**
   * BugReportImage createMany
   */
  export type BugReportImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BugReportImages.
     */
    data: BugReportImageCreateManyInput | BugReportImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BugReportImage createManyAndReturn
   */
  export type BugReportImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * The data used to create many BugReportImages.
     */
    data: BugReportImageCreateManyInput | BugReportImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BugReportImage update
   */
  export type BugReportImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * The data needed to update a BugReportImage.
     */
    data: XOR<BugReportImageUpdateInput, BugReportImageUncheckedUpdateInput>
    /**
     * Choose, which BugReportImage to update.
     */
    where: BugReportImageWhereUniqueInput
  }

  /**
   * BugReportImage updateMany
   */
  export type BugReportImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BugReportImages.
     */
    data: XOR<BugReportImageUpdateManyMutationInput, BugReportImageUncheckedUpdateManyInput>
    /**
     * Filter which BugReportImages to update
     */
    where?: BugReportImageWhereInput
    /**
     * Limit how many BugReportImages to update.
     */
    limit?: number
  }

  /**
   * BugReportImage updateManyAndReturn
   */
  export type BugReportImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * The data used to update BugReportImages.
     */
    data: XOR<BugReportImageUpdateManyMutationInput, BugReportImageUncheckedUpdateManyInput>
    /**
     * Filter which BugReportImages to update
     */
    where?: BugReportImageWhereInput
    /**
     * Limit how many BugReportImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BugReportImage upsert
   */
  export type BugReportImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * The filter to search for the BugReportImage to update in case it exists.
     */
    where: BugReportImageWhereUniqueInput
    /**
     * In case the BugReportImage found by the `where` argument doesn't exist, create a new BugReportImage with this data.
     */
    create: XOR<BugReportImageCreateInput, BugReportImageUncheckedCreateInput>
    /**
     * In case the BugReportImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BugReportImageUpdateInput, BugReportImageUncheckedUpdateInput>
  }

  /**
   * BugReportImage delete
   */
  export type BugReportImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
    /**
     * Filter which BugReportImage to delete.
     */
    where: BugReportImageWhereUniqueInput
  }

  /**
   * BugReportImage deleteMany
   */
  export type BugReportImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BugReportImages to delete
     */
    where?: BugReportImageWhereInput
    /**
     * Limit how many BugReportImages to delete.
     */
    limit?: number
  }

  /**
   * BugReportImage without action
   */
  export type BugReportImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReportImage
     */
    select?: BugReportImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReportImage
     */
    omit?: BugReportImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportImageInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    userId: string | null
    managerId: string | null
    status: $Enums.ChatStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    managerId: string | null
    status: $Enums.ChatStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    userId: number
    managerId: number
    status: number
    createdAt: number
    updatedAt: number
    closedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    userId?: true
    managerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    userId?: true
    managerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    userId?: true
    managerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    userId: string
    managerId: string | null
    status: $Enums.ChatStatus
    createdAt: Date
    updatedAt: Date
    closedAt: Date | null
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    managerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    managerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    managerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    userId?: boolean
    managerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "managerId" | "status" | "createdAt" | "updatedAt" | "closedAt", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      managerId: string | null
      status: $Enums.ChatStatus
      createdAt: Date
      updatedAt: Date
      closedAt: Date | null
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends Chat$managerArgs<ExtArgs> = {}>(args?: Subset<T, Chat$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly userId: FieldRef<"Chat", 'String'>
    readonly managerId: FieldRef<"Chat", 'String'>
    readonly status: FieldRef<"Chat", 'ChatStatus'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
    readonly closedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.manager
   */
  export type Chat$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    text: string | null
    isFromUser: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    text: string | null
    isFromUser: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    chatId: number
    text: number
    isFromUser: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    chatId?: true
    text?: true
    isFromUser?: true
    readAt?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    text?: true
    isFromUser?: true
    readAt?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    chatId?: true
    text?: true
    isFromUser?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    chatId: string
    text: string
    isFromUser: boolean
    readAt: Date | null
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    text?: boolean
    isFromUser?: boolean
    readAt?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    text?: boolean
    isFromUser?: boolean
    readAt?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    text?: boolean
    isFromUser?: boolean
    readAt?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    text?: boolean
    isFromUser?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "text" | "isFromUser" | "readAt" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      text: string
      isFromUser: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly chatId: FieldRef<"ChatMessage", 'String'>
    readonly text: FieldRef<"ChatMessage", 'String'>
    readonly isFromUser: FieldRef<"ChatMessage", 'Boolean'>
    readonly readAt: FieldRef<"ChatMessage", 'DateTime'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    region: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    region: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | City$usersArgs<ExtArgs>
    services?: boolean | City$servicesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "region" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | City$usersArgs<ExtArgs>
    services?: boolean | City$servicesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      services: Prisma.$ServiceCityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      region: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends City$servicesArgs<ExtArgs> = {}>(args?: Subset<T, City$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly region: FieldRef<"City", 'String'>
    readonly isActive: FieldRef<"City", 'Boolean'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * City.services
   */
  export type City$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    where?: ServiceCityWhereInput
    orderBy?: ServiceCityOrderByWithRelationInput | ServiceCityOrderByWithRelationInput[]
    cursor?: ServiceCityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceCityScalarFieldEnum | ServiceCityScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model HomePageSection
   */

  export type AggregateHomePageSection = {
    _count: HomePageSectionCountAggregateOutputType | null
    _avg: HomePageSectionAvgAggregateOutputType | null
    _sum: HomePageSectionSumAggregateOutputType | null
    _min: HomePageSectionMinAggregateOutputType | null
    _max: HomePageSectionMaxAggregateOutputType | null
  }

  export type HomePageSectionAvgAggregateOutputType = {
    order: number | null
  }

  export type HomePageSectionSumAggregateOutputType = {
    order: number | null
  }

  export type HomePageSectionMinAggregateOutputType = {
    id: string | null
    type: $Enums.HomePageSectionType | null
    title: string | null
    icon: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomePageSectionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.HomePageSectionType | null
    title: string | null
    icon: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomePageSectionCountAggregateOutputType = {
    id: number
    type: number
    title: number
    icon: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HomePageSectionAvgAggregateInputType = {
    order?: true
  }

  export type HomePageSectionSumAggregateInputType = {
    order?: true
  }

  export type HomePageSectionMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    icon?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomePageSectionMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    icon?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomePageSectionCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    icon?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HomePageSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomePageSection to aggregate.
     */
    where?: HomePageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSections to fetch.
     */
    orderBy?: HomePageSectionOrderByWithRelationInput | HomePageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomePageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomePageSections
    **/
    _count?: true | HomePageSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HomePageSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HomePageSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomePageSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomePageSectionMaxAggregateInputType
  }

  export type GetHomePageSectionAggregateType<T extends HomePageSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateHomePageSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomePageSection[P]>
      : GetScalarType<T[P], AggregateHomePageSection[P]>
  }




  export type HomePageSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomePageSectionWhereInput
    orderBy?: HomePageSectionOrderByWithAggregationInput | HomePageSectionOrderByWithAggregationInput[]
    by: HomePageSectionScalarFieldEnum[] | HomePageSectionScalarFieldEnum
    having?: HomePageSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomePageSectionCountAggregateInputType | true
    _avg?: HomePageSectionAvgAggregateInputType
    _sum?: HomePageSectionSumAggregateInputType
    _min?: HomePageSectionMinAggregateInputType
    _max?: HomePageSectionMaxAggregateInputType
  }

  export type HomePageSectionGroupByOutputType = {
    id: string
    type: $Enums.HomePageSectionType
    title: string | null
    icon: string | null
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: HomePageSectionCountAggregateOutputType | null
    _avg: HomePageSectionAvgAggregateOutputType | null
    _sum: HomePageSectionSumAggregateOutputType | null
    _min: HomePageSectionMinAggregateOutputType | null
    _max: HomePageSectionMaxAggregateOutputType | null
  }

  type GetHomePageSectionGroupByPayload<T extends HomePageSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomePageSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomePageSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomePageSectionGroupByOutputType[P]>
            : GetScalarType<T[P], HomePageSectionGroupByOutputType[P]>
        }
      >
    >


  export type HomePageSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    icon?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | HomePageSection$itemsArgs<ExtArgs>
    _count?: boolean | HomePageSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homePageSection"]>

  export type HomePageSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    icon?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["homePageSection"]>

  export type HomePageSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    icon?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["homePageSection"]>

  export type HomePageSectionSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    icon?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HomePageSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "icon" | "isActive" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["homePageSection"]>
  export type HomePageSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | HomePageSection$itemsArgs<ExtArgs>
    _count?: boolean | HomePageSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HomePageSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HomePageSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HomePageSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomePageSection"
    objects: {
      items: Prisma.$HomePageSectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.HomePageSectionType
      title: string | null
      icon: string | null
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["homePageSection"]>
    composites: {}
  }

  type HomePageSectionGetPayload<S extends boolean | null | undefined | HomePageSectionDefaultArgs> = $Result.GetResult<Prisma.$HomePageSectionPayload, S>

  type HomePageSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HomePageSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HomePageSectionCountAggregateInputType | true
    }

  export interface HomePageSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomePageSection'], meta: { name: 'HomePageSection' } }
    /**
     * Find zero or one HomePageSection that matches the filter.
     * @param {HomePageSectionFindUniqueArgs} args - Arguments to find a HomePageSection
     * @example
     * // Get one HomePageSection
     * const homePageSection = await prisma.homePageSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomePageSectionFindUniqueArgs>(args: SelectSubset<T, HomePageSectionFindUniqueArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HomePageSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HomePageSectionFindUniqueOrThrowArgs} args - Arguments to find a HomePageSection
     * @example
     * // Get one HomePageSection
     * const homePageSection = await prisma.homePageSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomePageSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, HomePageSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomePageSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionFindFirstArgs} args - Arguments to find a HomePageSection
     * @example
     * // Get one HomePageSection
     * const homePageSection = await prisma.homePageSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomePageSectionFindFirstArgs>(args?: SelectSubset<T, HomePageSectionFindFirstArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomePageSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionFindFirstOrThrowArgs} args - Arguments to find a HomePageSection
     * @example
     * // Get one HomePageSection
     * const homePageSection = await prisma.homePageSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomePageSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, HomePageSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HomePageSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomePageSections
     * const homePageSections = await prisma.homePageSection.findMany()
     * 
     * // Get first 10 HomePageSections
     * const homePageSections = await prisma.homePageSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homePageSectionWithIdOnly = await prisma.homePageSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomePageSectionFindManyArgs>(args?: SelectSubset<T, HomePageSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HomePageSection.
     * @param {HomePageSectionCreateArgs} args - Arguments to create a HomePageSection.
     * @example
     * // Create one HomePageSection
     * const HomePageSection = await prisma.homePageSection.create({
     *   data: {
     *     // ... data to create a HomePageSection
     *   }
     * })
     * 
     */
    create<T extends HomePageSectionCreateArgs>(args: SelectSubset<T, HomePageSectionCreateArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HomePageSections.
     * @param {HomePageSectionCreateManyArgs} args - Arguments to create many HomePageSections.
     * @example
     * // Create many HomePageSections
     * const homePageSection = await prisma.homePageSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomePageSectionCreateManyArgs>(args?: SelectSubset<T, HomePageSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomePageSections and returns the data saved in the database.
     * @param {HomePageSectionCreateManyAndReturnArgs} args - Arguments to create many HomePageSections.
     * @example
     * // Create many HomePageSections
     * const homePageSection = await prisma.homePageSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomePageSections and only return the `id`
     * const homePageSectionWithIdOnly = await prisma.homePageSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomePageSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, HomePageSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HomePageSection.
     * @param {HomePageSectionDeleteArgs} args - Arguments to delete one HomePageSection.
     * @example
     * // Delete one HomePageSection
     * const HomePageSection = await prisma.homePageSection.delete({
     *   where: {
     *     // ... filter to delete one HomePageSection
     *   }
     * })
     * 
     */
    delete<T extends HomePageSectionDeleteArgs>(args: SelectSubset<T, HomePageSectionDeleteArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HomePageSection.
     * @param {HomePageSectionUpdateArgs} args - Arguments to update one HomePageSection.
     * @example
     * // Update one HomePageSection
     * const homePageSection = await prisma.homePageSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomePageSectionUpdateArgs>(args: SelectSubset<T, HomePageSectionUpdateArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HomePageSections.
     * @param {HomePageSectionDeleteManyArgs} args - Arguments to filter HomePageSections to delete.
     * @example
     * // Delete a few HomePageSections
     * const { count } = await prisma.homePageSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomePageSectionDeleteManyArgs>(args?: SelectSubset<T, HomePageSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomePageSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomePageSections
     * const homePageSection = await prisma.homePageSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomePageSectionUpdateManyArgs>(args: SelectSubset<T, HomePageSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomePageSections and returns the data updated in the database.
     * @param {HomePageSectionUpdateManyAndReturnArgs} args - Arguments to update many HomePageSections.
     * @example
     * // Update many HomePageSections
     * const homePageSection = await prisma.homePageSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HomePageSections and only return the `id`
     * const homePageSectionWithIdOnly = await prisma.homePageSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HomePageSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, HomePageSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HomePageSection.
     * @param {HomePageSectionUpsertArgs} args - Arguments to update or create a HomePageSection.
     * @example
     * // Update or create a HomePageSection
     * const homePageSection = await prisma.homePageSection.upsert({
     *   create: {
     *     // ... data to create a HomePageSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomePageSection we want to update
     *   }
     * })
     */
    upsert<T extends HomePageSectionUpsertArgs>(args: SelectSubset<T, HomePageSectionUpsertArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HomePageSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionCountArgs} args - Arguments to filter HomePageSections to count.
     * @example
     * // Count the number of HomePageSections
     * const count = await prisma.homePageSection.count({
     *   where: {
     *     // ... the filter for the HomePageSections we want to count
     *   }
     * })
    **/
    count<T extends HomePageSectionCountArgs>(
      args?: Subset<T, HomePageSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomePageSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomePageSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomePageSectionAggregateArgs>(args: Subset<T, HomePageSectionAggregateArgs>): Prisma.PrismaPromise<GetHomePageSectionAggregateType<T>>

    /**
     * Group by HomePageSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomePageSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomePageSectionGroupByArgs['orderBy'] }
        : { orderBy?: HomePageSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomePageSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomePageSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomePageSection model
   */
  readonly fields: HomePageSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomePageSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomePageSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends HomePageSection$itemsArgs<ExtArgs> = {}>(args?: Subset<T, HomePageSection$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomePageSection model
   */
  interface HomePageSectionFieldRefs {
    readonly id: FieldRef<"HomePageSection", 'String'>
    readonly type: FieldRef<"HomePageSection", 'HomePageSectionType'>
    readonly title: FieldRef<"HomePageSection", 'String'>
    readonly icon: FieldRef<"HomePageSection", 'String'>
    readonly isActive: FieldRef<"HomePageSection", 'Boolean'>
    readonly order: FieldRef<"HomePageSection", 'Int'>
    readonly createdAt: FieldRef<"HomePageSection", 'DateTime'>
    readonly updatedAt: FieldRef<"HomePageSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HomePageSection findUnique
   */
  export type HomePageSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSection to fetch.
     */
    where: HomePageSectionWhereUniqueInput
  }

  /**
   * HomePageSection findUniqueOrThrow
   */
  export type HomePageSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSection to fetch.
     */
    where: HomePageSectionWhereUniqueInput
  }

  /**
   * HomePageSection findFirst
   */
  export type HomePageSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSection to fetch.
     */
    where?: HomePageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSections to fetch.
     */
    orderBy?: HomePageSectionOrderByWithRelationInput | HomePageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomePageSections.
     */
    cursor?: HomePageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomePageSections.
     */
    distinct?: HomePageSectionScalarFieldEnum | HomePageSectionScalarFieldEnum[]
  }

  /**
   * HomePageSection findFirstOrThrow
   */
  export type HomePageSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSection to fetch.
     */
    where?: HomePageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSections to fetch.
     */
    orderBy?: HomePageSectionOrderByWithRelationInput | HomePageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomePageSections.
     */
    cursor?: HomePageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomePageSections.
     */
    distinct?: HomePageSectionScalarFieldEnum | HomePageSectionScalarFieldEnum[]
  }

  /**
   * HomePageSection findMany
   */
  export type HomePageSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSections to fetch.
     */
    where?: HomePageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSections to fetch.
     */
    orderBy?: HomePageSectionOrderByWithRelationInput | HomePageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomePageSections.
     */
    cursor?: HomePageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSections.
     */
    skip?: number
    distinct?: HomePageSectionScalarFieldEnum | HomePageSectionScalarFieldEnum[]
  }

  /**
   * HomePageSection create
   */
  export type HomePageSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a HomePageSection.
     */
    data: XOR<HomePageSectionCreateInput, HomePageSectionUncheckedCreateInput>
  }

  /**
   * HomePageSection createMany
   */
  export type HomePageSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomePageSections.
     */
    data: HomePageSectionCreateManyInput | HomePageSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomePageSection createManyAndReturn
   */
  export type HomePageSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * The data used to create many HomePageSections.
     */
    data: HomePageSectionCreateManyInput | HomePageSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomePageSection update
   */
  export type HomePageSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a HomePageSection.
     */
    data: XOR<HomePageSectionUpdateInput, HomePageSectionUncheckedUpdateInput>
    /**
     * Choose, which HomePageSection to update.
     */
    where: HomePageSectionWhereUniqueInput
  }

  /**
   * HomePageSection updateMany
   */
  export type HomePageSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomePageSections.
     */
    data: XOR<HomePageSectionUpdateManyMutationInput, HomePageSectionUncheckedUpdateManyInput>
    /**
     * Filter which HomePageSections to update
     */
    where?: HomePageSectionWhereInput
    /**
     * Limit how many HomePageSections to update.
     */
    limit?: number
  }

  /**
   * HomePageSection updateManyAndReturn
   */
  export type HomePageSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * The data used to update HomePageSections.
     */
    data: XOR<HomePageSectionUpdateManyMutationInput, HomePageSectionUncheckedUpdateManyInput>
    /**
     * Filter which HomePageSections to update
     */
    where?: HomePageSectionWhereInput
    /**
     * Limit how many HomePageSections to update.
     */
    limit?: number
  }

  /**
   * HomePageSection upsert
   */
  export type HomePageSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the HomePageSection to update in case it exists.
     */
    where: HomePageSectionWhereUniqueInput
    /**
     * In case the HomePageSection found by the `where` argument doesn't exist, create a new HomePageSection with this data.
     */
    create: XOR<HomePageSectionCreateInput, HomePageSectionUncheckedCreateInput>
    /**
     * In case the HomePageSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomePageSectionUpdateInput, HomePageSectionUncheckedUpdateInput>
  }

  /**
   * HomePageSection delete
   */
  export type HomePageSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
    /**
     * Filter which HomePageSection to delete.
     */
    where: HomePageSectionWhereUniqueInput
  }

  /**
   * HomePageSection deleteMany
   */
  export type HomePageSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomePageSections to delete
     */
    where?: HomePageSectionWhereInput
    /**
     * Limit how many HomePageSections to delete.
     */
    limit?: number
  }

  /**
   * HomePageSection.items
   */
  export type HomePageSection$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    where?: HomePageSectionItemWhereInput
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    cursor?: HomePageSectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomePageSectionItemScalarFieldEnum | HomePageSectionItemScalarFieldEnum[]
  }

  /**
   * HomePageSection without action
   */
  export type HomePageSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSection
     */
    select?: HomePageSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSection
     */
    omit?: HomePageSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionInclude<ExtArgs> | null
  }


  /**
   * Model HomePageSectionItem
   */

  export type AggregateHomePageSectionItem = {
    _count: HomePageSectionItemCountAggregateOutputType | null
    _avg: HomePageSectionItemAvgAggregateOutputType | null
    _sum: HomePageSectionItemSumAggregateOutputType | null
    _min: HomePageSectionItemMinAggregateOutputType | null
    _max: HomePageSectionItemMaxAggregateOutputType | null
  }

  export type HomePageSectionItemAvgAggregateOutputType = {
    order: number | null
  }

  export type HomePageSectionItemSumAggregateOutputType = {
    order: number | null
  }

  export type HomePageSectionItemMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    categoryId: string | null
    serviceId: string | null
    imageUrl: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomePageSectionItemMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    categoryId: string | null
    serviceId: string | null
    imageUrl: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HomePageSectionItemCountAggregateOutputType = {
    id: number
    sectionId: number
    categoryId: number
    serviceId: number
    imageUrl: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HomePageSectionItemAvgAggregateInputType = {
    order?: true
  }

  export type HomePageSectionItemSumAggregateInputType = {
    order?: true
  }

  export type HomePageSectionItemMinAggregateInputType = {
    id?: true
    sectionId?: true
    categoryId?: true
    serviceId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomePageSectionItemMaxAggregateInputType = {
    id?: true
    sectionId?: true
    categoryId?: true
    serviceId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HomePageSectionItemCountAggregateInputType = {
    id?: true
    sectionId?: true
    categoryId?: true
    serviceId?: true
    imageUrl?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HomePageSectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomePageSectionItem to aggregate.
     */
    where?: HomePageSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSectionItems to fetch.
     */
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomePageSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomePageSectionItems
    **/
    _count?: true | HomePageSectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HomePageSectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HomePageSectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomePageSectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomePageSectionItemMaxAggregateInputType
  }

  export type GetHomePageSectionItemAggregateType<T extends HomePageSectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateHomePageSectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomePageSectionItem[P]>
      : GetScalarType<T[P], AggregateHomePageSectionItem[P]>
  }




  export type HomePageSectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomePageSectionItemWhereInput
    orderBy?: HomePageSectionItemOrderByWithAggregationInput | HomePageSectionItemOrderByWithAggregationInput[]
    by: HomePageSectionItemScalarFieldEnum[] | HomePageSectionItemScalarFieldEnum
    having?: HomePageSectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomePageSectionItemCountAggregateInputType | true
    _avg?: HomePageSectionItemAvgAggregateInputType
    _sum?: HomePageSectionItemSumAggregateInputType
    _min?: HomePageSectionItemMinAggregateInputType
    _max?: HomePageSectionItemMaxAggregateInputType
  }

  export type HomePageSectionItemGroupByOutputType = {
    id: string
    sectionId: string
    categoryId: string | null
    serviceId: string | null
    imageUrl: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: HomePageSectionItemCountAggregateOutputType | null
    _avg: HomePageSectionItemAvgAggregateOutputType | null
    _sum: HomePageSectionItemSumAggregateOutputType | null
    _min: HomePageSectionItemMinAggregateOutputType | null
    _max: HomePageSectionItemMaxAggregateOutputType | null
  }

  type GetHomePageSectionItemGroupByPayload<T extends HomePageSectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomePageSectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomePageSectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomePageSectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], HomePageSectionItemGroupByOutputType[P]>
        }
      >
    >


  export type HomePageSectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    categoryId?: boolean
    serviceId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | HomePageSectionDefaultArgs<ExtArgs>
    category?: boolean | HomePageSectionItem$categoryArgs<ExtArgs>
    service?: boolean | HomePageSectionItem$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["homePageSectionItem"]>

  export type HomePageSectionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    categoryId?: boolean
    serviceId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | HomePageSectionDefaultArgs<ExtArgs>
    category?: boolean | HomePageSectionItem$categoryArgs<ExtArgs>
    service?: boolean | HomePageSectionItem$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["homePageSectionItem"]>

  export type HomePageSectionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    categoryId?: boolean
    serviceId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | HomePageSectionDefaultArgs<ExtArgs>
    category?: boolean | HomePageSectionItem$categoryArgs<ExtArgs>
    service?: boolean | HomePageSectionItem$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["homePageSectionItem"]>

  export type HomePageSectionItemSelectScalar = {
    id?: boolean
    sectionId?: boolean
    categoryId?: boolean
    serviceId?: boolean
    imageUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HomePageSectionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "categoryId" | "serviceId" | "imageUrl" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["homePageSectionItem"]>
  export type HomePageSectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | HomePageSectionDefaultArgs<ExtArgs>
    category?: boolean | HomePageSectionItem$categoryArgs<ExtArgs>
    service?: boolean | HomePageSectionItem$serviceArgs<ExtArgs>
  }
  export type HomePageSectionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | HomePageSectionDefaultArgs<ExtArgs>
    category?: boolean | HomePageSectionItem$categoryArgs<ExtArgs>
    service?: boolean | HomePageSectionItem$serviceArgs<ExtArgs>
  }
  export type HomePageSectionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | HomePageSectionDefaultArgs<ExtArgs>
    category?: boolean | HomePageSectionItem$categoryArgs<ExtArgs>
    service?: boolean | HomePageSectionItem$serviceArgs<ExtArgs>
  }

  export type $HomePageSectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomePageSectionItem"
    objects: {
      section: Prisma.$HomePageSectionPayload<ExtArgs>
      category: Prisma.$ServiceCategoryPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      categoryId: string | null
      serviceId: string | null
      imageUrl: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["homePageSectionItem"]>
    composites: {}
  }

  type HomePageSectionItemGetPayload<S extends boolean | null | undefined | HomePageSectionItemDefaultArgs> = $Result.GetResult<Prisma.$HomePageSectionItemPayload, S>

  type HomePageSectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HomePageSectionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HomePageSectionItemCountAggregateInputType | true
    }

  export interface HomePageSectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomePageSectionItem'], meta: { name: 'HomePageSectionItem' } }
    /**
     * Find zero or one HomePageSectionItem that matches the filter.
     * @param {HomePageSectionItemFindUniqueArgs} args - Arguments to find a HomePageSectionItem
     * @example
     * // Get one HomePageSectionItem
     * const homePageSectionItem = await prisma.homePageSectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomePageSectionItemFindUniqueArgs>(args: SelectSubset<T, HomePageSectionItemFindUniqueArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HomePageSectionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HomePageSectionItemFindUniqueOrThrowArgs} args - Arguments to find a HomePageSectionItem
     * @example
     * // Get one HomePageSectionItem
     * const homePageSectionItem = await prisma.homePageSectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomePageSectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, HomePageSectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomePageSectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemFindFirstArgs} args - Arguments to find a HomePageSectionItem
     * @example
     * // Get one HomePageSectionItem
     * const homePageSectionItem = await prisma.homePageSectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomePageSectionItemFindFirstArgs>(args?: SelectSubset<T, HomePageSectionItemFindFirstArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomePageSectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemFindFirstOrThrowArgs} args - Arguments to find a HomePageSectionItem
     * @example
     * // Get one HomePageSectionItem
     * const homePageSectionItem = await prisma.homePageSectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomePageSectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, HomePageSectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HomePageSectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomePageSectionItems
     * const homePageSectionItems = await prisma.homePageSectionItem.findMany()
     * 
     * // Get first 10 HomePageSectionItems
     * const homePageSectionItems = await prisma.homePageSectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homePageSectionItemWithIdOnly = await prisma.homePageSectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomePageSectionItemFindManyArgs>(args?: SelectSubset<T, HomePageSectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HomePageSectionItem.
     * @param {HomePageSectionItemCreateArgs} args - Arguments to create a HomePageSectionItem.
     * @example
     * // Create one HomePageSectionItem
     * const HomePageSectionItem = await prisma.homePageSectionItem.create({
     *   data: {
     *     // ... data to create a HomePageSectionItem
     *   }
     * })
     * 
     */
    create<T extends HomePageSectionItemCreateArgs>(args: SelectSubset<T, HomePageSectionItemCreateArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HomePageSectionItems.
     * @param {HomePageSectionItemCreateManyArgs} args - Arguments to create many HomePageSectionItems.
     * @example
     * // Create many HomePageSectionItems
     * const homePageSectionItem = await prisma.homePageSectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomePageSectionItemCreateManyArgs>(args?: SelectSubset<T, HomePageSectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomePageSectionItems and returns the data saved in the database.
     * @param {HomePageSectionItemCreateManyAndReturnArgs} args - Arguments to create many HomePageSectionItems.
     * @example
     * // Create many HomePageSectionItems
     * const homePageSectionItem = await prisma.homePageSectionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomePageSectionItems and only return the `id`
     * const homePageSectionItemWithIdOnly = await prisma.homePageSectionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomePageSectionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, HomePageSectionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HomePageSectionItem.
     * @param {HomePageSectionItemDeleteArgs} args - Arguments to delete one HomePageSectionItem.
     * @example
     * // Delete one HomePageSectionItem
     * const HomePageSectionItem = await prisma.homePageSectionItem.delete({
     *   where: {
     *     // ... filter to delete one HomePageSectionItem
     *   }
     * })
     * 
     */
    delete<T extends HomePageSectionItemDeleteArgs>(args: SelectSubset<T, HomePageSectionItemDeleteArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HomePageSectionItem.
     * @param {HomePageSectionItemUpdateArgs} args - Arguments to update one HomePageSectionItem.
     * @example
     * // Update one HomePageSectionItem
     * const homePageSectionItem = await prisma.homePageSectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomePageSectionItemUpdateArgs>(args: SelectSubset<T, HomePageSectionItemUpdateArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HomePageSectionItems.
     * @param {HomePageSectionItemDeleteManyArgs} args - Arguments to filter HomePageSectionItems to delete.
     * @example
     * // Delete a few HomePageSectionItems
     * const { count } = await prisma.homePageSectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomePageSectionItemDeleteManyArgs>(args?: SelectSubset<T, HomePageSectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomePageSectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomePageSectionItems
     * const homePageSectionItem = await prisma.homePageSectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomePageSectionItemUpdateManyArgs>(args: SelectSubset<T, HomePageSectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomePageSectionItems and returns the data updated in the database.
     * @param {HomePageSectionItemUpdateManyAndReturnArgs} args - Arguments to update many HomePageSectionItems.
     * @example
     * // Update many HomePageSectionItems
     * const homePageSectionItem = await prisma.homePageSectionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HomePageSectionItems and only return the `id`
     * const homePageSectionItemWithIdOnly = await prisma.homePageSectionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HomePageSectionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, HomePageSectionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HomePageSectionItem.
     * @param {HomePageSectionItemUpsertArgs} args - Arguments to update or create a HomePageSectionItem.
     * @example
     * // Update or create a HomePageSectionItem
     * const homePageSectionItem = await prisma.homePageSectionItem.upsert({
     *   create: {
     *     // ... data to create a HomePageSectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomePageSectionItem we want to update
     *   }
     * })
     */
    upsert<T extends HomePageSectionItemUpsertArgs>(args: SelectSubset<T, HomePageSectionItemUpsertArgs<ExtArgs>>): Prisma__HomePageSectionItemClient<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HomePageSectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemCountArgs} args - Arguments to filter HomePageSectionItems to count.
     * @example
     * // Count the number of HomePageSectionItems
     * const count = await prisma.homePageSectionItem.count({
     *   where: {
     *     // ... the filter for the HomePageSectionItems we want to count
     *   }
     * })
    **/
    count<T extends HomePageSectionItemCountArgs>(
      args?: Subset<T, HomePageSectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomePageSectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomePageSectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomePageSectionItemAggregateArgs>(args: Subset<T, HomePageSectionItemAggregateArgs>): Prisma.PrismaPromise<GetHomePageSectionItemAggregateType<T>>

    /**
     * Group by HomePageSectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomePageSectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomePageSectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomePageSectionItemGroupByArgs['orderBy'] }
        : { orderBy?: HomePageSectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomePageSectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomePageSectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomePageSectionItem model
   */
  readonly fields: HomePageSectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomePageSectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomePageSectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends HomePageSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HomePageSectionDefaultArgs<ExtArgs>>): Prisma__HomePageSectionClient<$Result.GetResult<Prisma.$HomePageSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends HomePageSectionItem$categoryArgs<ExtArgs> = {}>(args?: Subset<T, HomePageSectionItem$categoryArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends HomePageSectionItem$serviceArgs<ExtArgs> = {}>(args?: Subset<T, HomePageSectionItem$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomePageSectionItem model
   */
  interface HomePageSectionItemFieldRefs {
    readonly id: FieldRef<"HomePageSectionItem", 'String'>
    readonly sectionId: FieldRef<"HomePageSectionItem", 'String'>
    readonly categoryId: FieldRef<"HomePageSectionItem", 'String'>
    readonly serviceId: FieldRef<"HomePageSectionItem", 'String'>
    readonly imageUrl: FieldRef<"HomePageSectionItem", 'String'>
    readonly order: FieldRef<"HomePageSectionItem", 'Int'>
    readonly createdAt: FieldRef<"HomePageSectionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"HomePageSectionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HomePageSectionItem findUnique
   */
  export type HomePageSectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSectionItem to fetch.
     */
    where: HomePageSectionItemWhereUniqueInput
  }

  /**
   * HomePageSectionItem findUniqueOrThrow
   */
  export type HomePageSectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSectionItem to fetch.
     */
    where: HomePageSectionItemWhereUniqueInput
  }

  /**
   * HomePageSectionItem findFirst
   */
  export type HomePageSectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSectionItem to fetch.
     */
    where?: HomePageSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSectionItems to fetch.
     */
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomePageSectionItems.
     */
    cursor?: HomePageSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomePageSectionItems.
     */
    distinct?: HomePageSectionItemScalarFieldEnum | HomePageSectionItemScalarFieldEnum[]
  }

  /**
   * HomePageSectionItem findFirstOrThrow
   */
  export type HomePageSectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSectionItem to fetch.
     */
    where?: HomePageSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSectionItems to fetch.
     */
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomePageSectionItems.
     */
    cursor?: HomePageSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomePageSectionItems.
     */
    distinct?: HomePageSectionItemScalarFieldEnum | HomePageSectionItemScalarFieldEnum[]
  }

  /**
   * HomePageSectionItem findMany
   */
  export type HomePageSectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which HomePageSectionItems to fetch.
     */
    where?: HomePageSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomePageSectionItems to fetch.
     */
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomePageSectionItems.
     */
    cursor?: HomePageSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomePageSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomePageSectionItems.
     */
    skip?: number
    distinct?: HomePageSectionItemScalarFieldEnum | HomePageSectionItemScalarFieldEnum[]
  }

  /**
   * HomePageSectionItem create
   */
  export type HomePageSectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a HomePageSectionItem.
     */
    data: XOR<HomePageSectionItemCreateInput, HomePageSectionItemUncheckedCreateInput>
  }

  /**
   * HomePageSectionItem createMany
   */
  export type HomePageSectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomePageSectionItems.
     */
    data: HomePageSectionItemCreateManyInput | HomePageSectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomePageSectionItem createManyAndReturn
   */
  export type HomePageSectionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * The data used to create many HomePageSectionItems.
     */
    data: HomePageSectionItemCreateManyInput | HomePageSectionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomePageSectionItem update
   */
  export type HomePageSectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a HomePageSectionItem.
     */
    data: XOR<HomePageSectionItemUpdateInput, HomePageSectionItemUncheckedUpdateInput>
    /**
     * Choose, which HomePageSectionItem to update.
     */
    where: HomePageSectionItemWhereUniqueInput
  }

  /**
   * HomePageSectionItem updateMany
   */
  export type HomePageSectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomePageSectionItems.
     */
    data: XOR<HomePageSectionItemUpdateManyMutationInput, HomePageSectionItemUncheckedUpdateManyInput>
    /**
     * Filter which HomePageSectionItems to update
     */
    where?: HomePageSectionItemWhereInput
    /**
     * Limit how many HomePageSectionItems to update.
     */
    limit?: number
  }

  /**
   * HomePageSectionItem updateManyAndReturn
   */
  export type HomePageSectionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * The data used to update HomePageSectionItems.
     */
    data: XOR<HomePageSectionItemUpdateManyMutationInput, HomePageSectionItemUncheckedUpdateManyInput>
    /**
     * Filter which HomePageSectionItems to update
     */
    where?: HomePageSectionItemWhereInput
    /**
     * Limit how many HomePageSectionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomePageSectionItem upsert
   */
  export type HomePageSectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the HomePageSectionItem to update in case it exists.
     */
    where: HomePageSectionItemWhereUniqueInput
    /**
     * In case the HomePageSectionItem found by the `where` argument doesn't exist, create a new HomePageSectionItem with this data.
     */
    create: XOR<HomePageSectionItemCreateInput, HomePageSectionItemUncheckedCreateInput>
    /**
     * In case the HomePageSectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomePageSectionItemUpdateInput, HomePageSectionItemUncheckedUpdateInput>
  }

  /**
   * HomePageSectionItem delete
   */
  export type HomePageSectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    /**
     * Filter which HomePageSectionItem to delete.
     */
    where: HomePageSectionItemWhereUniqueInput
  }

  /**
   * HomePageSectionItem deleteMany
   */
  export type HomePageSectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomePageSectionItems to delete
     */
    where?: HomePageSectionItemWhereInput
    /**
     * Limit how many HomePageSectionItems to delete.
     */
    limit?: number
  }

  /**
   * HomePageSectionItem.category
   */
  export type HomePageSectionItem$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    where?: ServiceCategoryWhereInput
  }

  /**
   * HomePageSectionItem.service
   */
  export type HomePageSectionItem$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * HomePageSectionItem without action
   */
  export type HomePageSectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
  }


  /**
   * Model MasterApplication
   */

  export type AggregateMasterApplication = {
    _count: MasterApplicationCountAggregateOutputType | null
    _min: MasterApplicationMinAggregateOutputType | null
    _max: MasterApplicationMaxAggregateOutputType | null
  }

  export type MasterApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    email: string | null
    experience: string | null
    description: string | null
    status: $Enums.MasterApplicationStatus | null
    processedAt: Date | null
    processedById: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MasterApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    phone: string | null
    email: string | null
    experience: string | null
    description: string | null
    status: $Enums.MasterApplicationStatus | null
    processedAt: Date | null
    processedById: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MasterApplicationCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    phone: number
    email: number
    experience: number
    specialties: number
    description: number
    status: number
    processedAt: number
    processedById: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MasterApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    experience?: true
    description?: true
    status?: true
    processedAt?: true
    processedById?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MasterApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    experience?: true
    description?: true
    status?: true
    processedAt?: true
    processedById?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MasterApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    phone?: true
    email?: true
    experience?: true
    specialties?: true
    description?: true
    status?: true
    processedAt?: true
    processedById?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MasterApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterApplication to aggregate.
     */
    where?: MasterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterApplications to fetch.
     */
    orderBy?: MasterApplicationOrderByWithRelationInput | MasterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterApplications
    **/
    _count?: true | MasterApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterApplicationMaxAggregateInputType
  }

  export type GetMasterApplicationAggregateType<T extends MasterApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterApplication[P]>
      : GetScalarType<T[P], AggregateMasterApplication[P]>
  }




  export type MasterApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterApplicationWhereInput
    orderBy?: MasterApplicationOrderByWithAggregationInput | MasterApplicationOrderByWithAggregationInput[]
    by: MasterApplicationScalarFieldEnum[] | MasterApplicationScalarFieldEnum
    having?: MasterApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterApplicationCountAggregateInputType | true
    _min?: MasterApplicationMinAggregateInputType
    _max?: MasterApplicationMaxAggregateInputType
  }

  export type MasterApplicationGroupByOutputType = {
    id: string
    userId: string
    name: string
    phone: string
    email: string | null
    experience: string | null
    specialties: string[]
    description: string | null
    status: $Enums.MasterApplicationStatus
    processedAt: Date | null
    processedById: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: MasterApplicationCountAggregateOutputType | null
    _min: MasterApplicationMinAggregateOutputType | null
    _max: MasterApplicationMaxAggregateOutputType | null
  }

  type GetMasterApplicationGroupByPayload<T extends MasterApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], MasterApplicationGroupByOutputType[P]>
        }
      >
    >


  export type MasterApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    experience?: boolean
    specialties?: boolean
    description?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedBy?: boolean | MasterApplication$processedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterApplication"]>

  export type MasterApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    experience?: boolean
    specialties?: boolean
    description?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedBy?: boolean | MasterApplication$processedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterApplication"]>

  export type MasterApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    experience?: boolean
    specialties?: boolean
    description?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedBy?: boolean | MasterApplication$processedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterApplication"]>

  export type MasterApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    experience?: boolean
    specialties?: boolean
    description?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MasterApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "phone" | "email" | "experience" | "specialties" | "description" | "status" | "processedAt" | "processedById" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["masterApplication"]>
  export type MasterApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processedBy?: boolean | MasterApplication$processedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MasterApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processedBy?: boolean | MasterApplication$processedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MasterApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processedBy?: boolean | MasterApplication$processedByArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MasterApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterApplication"
    objects: {
      processedBy: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      phone: string
      email: string | null
      experience: string | null
      specialties: string[]
      description: string | null
      status: $Enums.MasterApplicationStatus
      processedAt: Date | null
      processedById: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["masterApplication"]>
    composites: {}
  }

  type MasterApplicationGetPayload<S extends boolean | null | undefined | MasterApplicationDefaultArgs> = $Result.GetResult<Prisma.$MasterApplicationPayload, S>

  type MasterApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterApplicationCountAggregateInputType | true
    }

  export interface MasterApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterApplication'], meta: { name: 'MasterApplication' } }
    /**
     * Find zero or one MasterApplication that matches the filter.
     * @param {MasterApplicationFindUniqueArgs} args - Arguments to find a MasterApplication
     * @example
     * // Get one MasterApplication
     * const masterApplication = await prisma.masterApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterApplicationFindUniqueArgs>(args: SelectSubset<T, MasterApplicationFindUniqueArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterApplicationFindUniqueOrThrowArgs} args - Arguments to find a MasterApplication
     * @example
     * // Get one MasterApplication
     * const masterApplication = await prisma.masterApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationFindFirstArgs} args - Arguments to find a MasterApplication
     * @example
     * // Get one MasterApplication
     * const masterApplication = await prisma.masterApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterApplicationFindFirstArgs>(args?: SelectSubset<T, MasterApplicationFindFirstArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationFindFirstOrThrowArgs} args - Arguments to find a MasterApplication
     * @example
     * // Get one MasterApplication
     * const masterApplication = await prisma.masterApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterApplications
     * const masterApplications = await prisma.masterApplication.findMany()
     * 
     * // Get first 10 MasterApplications
     * const masterApplications = await prisma.masterApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterApplicationWithIdOnly = await prisma.masterApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterApplicationFindManyArgs>(args?: SelectSubset<T, MasterApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterApplication.
     * @param {MasterApplicationCreateArgs} args - Arguments to create a MasterApplication.
     * @example
     * // Create one MasterApplication
     * const MasterApplication = await prisma.masterApplication.create({
     *   data: {
     *     // ... data to create a MasterApplication
     *   }
     * })
     * 
     */
    create<T extends MasterApplicationCreateArgs>(args: SelectSubset<T, MasterApplicationCreateArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterApplications.
     * @param {MasterApplicationCreateManyArgs} args - Arguments to create many MasterApplications.
     * @example
     * // Create many MasterApplications
     * const masterApplication = await prisma.masterApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterApplicationCreateManyArgs>(args?: SelectSubset<T, MasterApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MasterApplications and returns the data saved in the database.
     * @param {MasterApplicationCreateManyAndReturnArgs} args - Arguments to create many MasterApplications.
     * @example
     * // Create many MasterApplications
     * const masterApplication = await prisma.masterApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MasterApplications and only return the `id`
     * const masterApplicationWithIdOnly = await prisma.masterApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MasterApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MasterApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MasterApplication.
     * @param {MasterApplicationDeleteArgs} args - Arguments to delete one MasterApplication.
     * @example
     * // Delete one MasterApplication
     * const MasterApplication = await prisma.masterApplication.delete({
     *   where: {
     *     // ... filter to delete one MasterApplication
     *   }
     * })
     * 
     */
    delete<T extends MasterApplicationDeleteArgs>(args: SelectSubset<T, MasterApplicationDeleteArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterApplication.
     * @param {MasterApplicationUpdateArgs} args - Arguments to update one MasterApplication.
     * @example
     * // Update one MasterApplication
     * const masterApplication = await prisma.masterApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterApplicationUpdateArgs>(args: SelectSubset<T, MasterApplicationUpdateArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterApplications.
     * @param {MasterApplicationDeleteManyArgs} args - Arguments to filter MasterApplications to delete.
     * @example
     * // Delete a few MasterApplications
     * const { count } = await prisma.masterApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterApplicationDeleteManyArgs>(args?: SelectSubset<T, MasterApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterApplications
     * const masterApplication = await prisma.masterApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterApplicationUpdateManyArgs>(args: SelectSubset<T, MasterApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterApplications and returns the data updated in the database.
     * @param {MasterApplicationUpdateManyAndReturnArgs} args - Arguments to update many MasterApplications.
     * @example
     * // Update many MasterApplications
     * const masterApplication = await prisma.masterApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MasterApplications and only return the `id`
     * const masterApplicationWithIdOnly = await prisma.masterApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MasterApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, MasterApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MasterApplication.
     * @param {MasterApplicationUpsertArgs} args - Arguments to update or create a MasterApplication.
     * @example
     * // Update or create a MasterApplication
     * const masterApplication = await prisma.masterApplication.upsert({
     *   create: {
     *     // ... data to create a MasterApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterApplication we want to update
     *   }
     * })
     */
    upsert<T extends MasterApplicationUpsertArgs>(args: SelectSubset<T, MasterApplicationUpsertArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationCountArgs} args - Arguments to filter MasterApplications to count.
     * @example
     * // Count the number of MasterApplications
     * const count = await prisma.masterApplication.count({
     *   where: {
     *     // ... the filter for the MasterApplications we want to count
     *   }
     * })
    **/
    count<T extends MasterApplicationCountArgs>(
      args?: Subset<T, MasterApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterApplicationAggregateArgs>(args: Subset<T, MasterApplicationAggregateArgs>): Prisma.PrismaPromise<GetMasterApplicationAggregateType<T>>

    /**
     * Group by MasterApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterApplicationGroupByArgs['orderBy'] }
        : { orderBy?: MasterApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterApplication model
   */
  readonly fields: MasterApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    processedBy<T extends MasterApplication$processedByArgs<ExtArgs> = {}>(args?: Subset<T, MasterApplication$processedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterApplication model
   */
  interface MasterApplicationFieldRefs {
    readonly id: FieldRef<"MasterApplication", 'String'>
    readonly userId: FieldRef<"MasterApplication", 'String'>
    readonly name: FieldRef<"MasterApplication", 'String'>
    readonly phone: FieldRef<"MasterApplication", 'String'>
    readonly email: FieldRef<"MasterApplication", 'String'>
    readonly experience: FieldRef<"MasterApplication", 'String'>
    readonly specialties: FieldRef<"MasterApplication", 'String[]'>
    readonly description: FieldRef<"MasterApplication", 'String'>
    readonly status: FieldRef<"MasterApplication", 'MasterApplicationStatus'>
    readonly processedAt: FieldRef<"MasterApplication", 'DateTime'>
    readonly processedById: FieldRef<"MasterApplication", 'String'>
    readonly rejectionReason: FieldRef<"MasterApplication", 'String'>
    readonly createdAt: FieldRef<"MasterApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"MasterApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MasterApplication findUnique
   */
  export type MasterApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MasterApplication to fetch.
     */
    where: MasterApplicationWhereUniqueInput
  }

  /**
   * MasterApplication findUniqueOrThrow
   */
  export type MasterApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MasterApplication to fetch.
     */
    where: MasterApplicationWhereUniqueInput
  }

  /**
   * MasterApplication findFirst
   */
  export type MasterApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MasterApplication to fetch.
     */
    where?: MasterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterApplications to fetch.
     */
    orderBy?: MasterApplicationOrderByWithRelationInput | MasterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterApplications.
     */
    cursor?: MasterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterApplications.
     */
    distinct?: MasterApplicationScalarFieldEnum | MasterApplicationScalarFieldEnum[]
  }

  /**
   * MasterApplication findFirstOrThrow
   */
  export type MasterApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MasterApplication to fetch.
     */
    where?: MasterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterApplications to fetch.
     */
    orderBy?: MasterApplicationOrderByWithRelationInput | MasterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterApplications.
     */
    cursor?: MasterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterApplications.
     */
    distinct?: MasterApplicationScalarFieldEnum | MasterApplicationScalarFieldEnum[]
  }

  /**
   * MasterApplication findMany
   */
  export type MasterApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * Filter, which MasterApplications to fetch.
     */
    where?: MasterApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterApplications to fetch.
     */
    orderBy?: MasterApplicationOrderByWithRelationInput | MasterApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterApplications.
     */
    cursor?: MasterApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterApplications.
     */
    skip?: number
    distinct?: MasterApplicationScalarFieldEnum | MasterApplicationScalarFieldEnum[]
  }

  /**
   * MasterApplication create
   */
  export type MasterApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a MasterApplication.
     */
    data: XOR<MasterApplicationCreateInput, MasterApplicationUncheckedCreateInput>
  }

  /**
   * MasterApplication createMany
   */
  export type MasterApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterApplications.
     */
    data: MasterApplicationCreateManyInput | MasterApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterApplication createManyAndReturn
   */
  export type MasterApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many MasterApplications.
     */
    data: MasterApplicationCreateManyInput | MasterApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MasterApplication update
   */
  export type MasterApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a MasterApplication.
     */
    data: XOR<MasterApplicationUpdateInput, MasterApplicationUncheckedUpdateInput>
    /**
     * Choose, which MasterApplication to update.
     */
    where: MasterApplicationWhereUniqueInput
  }

  /**
   * MasterApplication updateMany
   */
  export type MasterApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterApplications.
     */
    data: XOR<MasterApplicationUpdateManyMutationInput, MasterApplicationUncheckedUpdateManyInput>
    /**
     * Filter which MasterApplications to update
     */
    where?: MasterApplicationWhereInput
    /**
     * Limit how many MasterApplications to update.
     */
    limit?: number
  }

  /**
   * MasterApplication updateManyAndReturn
   */
  export type MasterApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * The data used to update MasterApplications.
     */
    data: XOR<MasterApplicationUpdateManyMutationInput, MasterApplicationUncheckedUpdateManyInput>
    /**
     * Filter which MasterApplications to update
     */
    where?: MasterApplicationWhereInput
    /**
     * Limit how many MasterApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MasterApplication upsert
   */
  export type MasterApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the MasterApplication to update in case it exists.
     */
    where: MasterApplicationWhereUniqueInput
    /**
     * In case the MasterApplication found by the `where` argument doesn't exist, create a new MasterApplication with this data.
     */
    create: XOR<MasterApplicationCreateInput, MasterApplicationUncheckedCreateInput>
    /**
     * In case the MasterApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterApplicationUpdateInput, MasterApplicationUncheckedUpdateInput>
  }

  /**
   * MasterApplication delete
   */
  export type MasterApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    /**
     * Filter which MasterApplication to delete.
     */
    where: MasterApplicationWhereUniqueInput
  }

  /**
   * MasterApplication deleteMany
   */
  export type MasterApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterApplications to delete
     */
    where?: MasterApplicationWhereInput
    /**
     * Limit how many MasterApplications to delete.
     */
    limit?: number
  }

  /**
   * MasterApplication.processedBy
   */
  export type MasterApplication$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MasterApplication without action
   */
  export type MasterApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalPrice: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalPrice: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    clientId: string | null
    masterId: string | null
    status: $Enums.OrderStatus | null
    recipient: string | null
    clientName: string | null
    clientPhone: string | null
    city: string | null
    address: string | null
    apartment: string | null
    isPrivateHouse: boolean | null
    urgency: $Enums.OrderUrgency | null
    scheduledDate: Date | null
    scheduledTime: string | null
    totalPrice: number | null
    workDescription: string | null
    warranty: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    clientId: string | null
    masterId: string | null
    status: $Enums.OrderStatus | null
    recipient: string | null
    clientName: string | null
    clientPhone: string | null
    city: string | null
    address: string | null
    apartment: string | null
    isPrivateHouse: boolean | null
    urgency: $Enums.OrderUrgency | null
    scheduledDate: Date | null
    scheduledTime: string | null
    totalPrice: number | null
    workDescription: string | null
    warranty: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    clientId: number
    masterId: number
    status: number
    recipient: number
    clientName: number
    clientPhone: number
    city: number
    address: number
    apartment: number
    isPrivateHouse: number
    urgency: number
    scheduledDate: number
    scheduledTime: number
    totalPrice: number
    workDescription: number
    warranty: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalPrice?: true
  }

  export type OrderSumAggregateInputType = {
    totalPrice?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    clientId?: true
    masterId?: true
    status?: true
    recipient?: true
    clientName?: true
    clientPhone?: true
    city?: true
    address?: true
    apartment?: true
    isPrivateHouse?: true
    urgency?: true
    scheduledDate?: true
    scheduledTime?: true
    totalPrice?: true
    workDescription?: true
    warranty?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    clientId?: true
    masterId?: true
    status?: true
    recipient?: true
    clientName?: true
    clientPhone?: true
    city?: true
    address?: true
    apartment?: true
    isPrivateHouse?: true
    urgency?: true
    scheduledDate?: true
    scheduledTime?: true
    totalPrice?: true
    workDescription?: true
    warranty?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    clientId?: true
    masterId?: true
    status?: true
    recipient?: true
    clientName?: true
    clientPhone?: true
    city?: true
    address?: true
    apartment?: true
    isPrivateHouse?: true
    urgency?: true
    scheduledDate?: true
    scheduledTime?: true
    totalPrice?: true
    workDescription?: true
    warranty?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    clientId: string | null
    masterId: string | null
    status: $Enums.OrderStatus
    recipient: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment: string | null
    isPrivateHouse: boolean
    urgency: $Enums.OrderUrgency
    scheduledDate: Date | null
    scheduledTime: string | null
    totalPrice: number | null
    workDescription: string | null
    warranty: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    masterId?: boolean
    status?: boolean
    recipient?: boolean
    clientName?: boolean
    clientPhone?: boolean
    city?: boolean
    address?: boolean
    apartment?: boolean
    isPrivateHouse?: boolean
    urgency?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    totalPrice?: boolean
    workDescription?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    client?: boolean | Order$clientArgs<ExtArgs>
    master?: boolean | Order$masterArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    steps?: boolean | Order$stepsArgs<ExtArgs>
    review?: boolean | Order$reviewArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    masterId?: boolean
    status?: boolean
    recipient?: boolean
    clientName?: boolean
    clientPhone?: boolean
    city?: boolean
    address?: boolean
    apartment?: boolean
    isPrivateHouse?: boolean
    urgency?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    totalPrice?: boolean
    workDescription?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    client?: boolean | Order$clientArgs<ExtArgs>
    master?: boolean | Order$masterArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    masterId?: boolean
    status?: boolean
    recipient?: boolean
    clientName?: boolean
    clientPhone?: boolean
    city?: boolean
    address?: boolean
    apartment?: boolean
    isPrivateHouse?: boolean
    urgency?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    totalPrice?: boolean
    workDescription?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    client?: boolean | Order$clientArgs<ExtArgs>
    master?: boolean | Order$masterArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    clientId?: boolean
    masterId?: boolean
    status?: boolean
    recipient?: boolean
    clientName?: boolean
    clientPhone?: boolean
    city?: boolean
    address?: boolean
    apartment?: boolean
    isPrivateHouse?: boolean
    urgency?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    totalPrice?: boolean
    workDescription?: boolean
    warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "clientId" | "masterId" | "status" | "recipient" | "clientName" | "clientPhone" | "city" | "address" | "apartment" | "isPrivateHouse" | "urgency" | "scheduledDate" | "scheduledTime" | "totalPrice" | "workDescription" | "warranty" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Order$clientArgs<ExtArgs>
    master?: boolean | Order$masterArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    steps?: boolean | Order$stepsArgs<ExtArgs>
    review?: boolean | Order$reviewArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Order$clientArgs<ExtArgs>
    master?: boolean | Order$masterArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Order$clientArgs<ExtArgs>
    master?: boolean | Order$masterArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      client: Prisma.$UserPayload<ExtArgs> | null
      master: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      steps: Prisma.$OrderStepPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      clientId: string | null
      masterId: string | null
      status: $Enums.OrderStatus
      recipient: string
      clientName: string
      clientPhone: string
      city: string
      address: string
      apartment: string | null
      isPrivateHouse: boolean
      urgency: $Enums.OrderUrgency
      scheduledDate: Date | null
      scheduledTime: string | null
      totalPrice: number | null
      workDescription: string | null
      warranty: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Order$clientArgs<ExtArgs> = {}>(args?: Subset<T, Order$clientArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    master<T extends Order$masterArgs<ExtArgs> = {}>(args?: Subset<T, Order$masterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    steps<T extends Order$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Order$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends Order$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Order$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly clientId: FieldRef<"Order", 'String'>
    readonly masterId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly recipient: FieldRef<"Order", 'String'>
    readonly clientName: FieldRef<"Order", 'String'>
    readonly clientPhone: FieldRef<"Order", 'String'>
    readonly city: FieldRef<"Order", 'String'>
    readonly address: FieldRef<"Order", 'String'>
    readonly apartment: FieldRef<"Order", 'String'>
    readonly isPrivateHouse: FieldRef<"Order", 'Boolean'>
    readonly urgency: FieldRef<"Order", 'OrderUrgency'>
    readonly scheduledDate: FieldRef<"Order", 'DateTime'>
    readonly scheduledTime: FieldRef<"Order", 'String'>
    readonly totalPrice: FieldRef<"Order", 'Float'>
    readonly workDescription: FieldRef<"Order", 'String'>
    readonly warranty: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly completedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.client
   */
  export type Order$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.master
   */
  export type Order$masterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.steps
   */
  export type Order$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    where?: OrderStepWhereInput
    orderBy?: OrderStepOrderByWithRelationInput | OrderStepOrderByWithRelationInput[]
    cursor?: OrderStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStepScalarFieldEnum | OrderStepScalarFieldEnum[]
  }

  /**
   * Order.review
   */
  export type Order$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    serviceId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    serviceId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    serviceId: number
    quantity: number
    price: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    quantity?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    serviceId: string
    quantity: number
    price: number
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "serviceId" | "quantity" | "price" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      serviceId: string
      quantity: number
      price: number
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly serviceId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderStep
   */

  export type AggregateOrderStep = {
    _count: OrderStepCountAggregateOutputType | null
    _min: OrderStepMinAggregateOutputType | null
    _max: OrderStepMaxAggregateOutputType | null
  }

  export type OrderStepMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    title: string | null
    description: string | null
    status: $Enums.StepStatus | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type OrderStepMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    title: string | null
    description: string | null
    status: $Enums.StepStatus | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type OrderStepCountAggregateOutputType = {
    id: number
    orderId: number
    title: number
    description: number
    status: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type OrderStepMinAggregateInputType = {
    id?: true
    orderId?: true
    title?: true
    description?: true
    status?: true
    completedAt?: true
    createdAt?: true
  }

  export type OrderStepMaxAggregateInputType = {
    id?: true
    orderId?: true
    title?: true
    description?: true
    status?: true
    completedAt?: true
    createdAt?: true
  }

  export type OrderStepCountAggregateInputType = {
    id?: true
    orderId?: true
    title?: true
    description?: true
    status?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type OrderStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStep to aggregate.
     */
    where?: OrderStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSteps to fetch.
     */
    orderBy?: OrderStepOrderByWithRelationInput | OrderStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderSteps
    **/
    _count?: true | OrderStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStepMaxAggregateInputType
  }

  export type GetOrderStepAggregateType<T extends OrderStepAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStep[P]>
      : GetScalarType<T[P], AggregateOrderStep[P]>
  }




  export type OrderStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStepWhereInput
    orderBy?: OrderStepOrderByWithAggregationInput | OrderStepOrderByWithAggregationInput[]
    by: OrderStepScalarFieldEnum[] | OrderStepScalarFieldEnum
    having?: OrderStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStepCountAggregateInputType | true
    _min?: OrderStepMinAggregateInputType
    _max?: OrderStepMaxAggregateInputType
  }

  export type OrderStepGroupByOutputType = {
    id: string
    orderId: string
    title: string
    description: string | null
    status: $Enums.StepStatus
    completedAt: Date | null
    createdAt: Date
    _count: OrderStepCountAggregateOutputType | null
    _min: OrderStepMinAggregateOutputType | null
    _max: OrderStepMaxAggregateOutputType | null
  }

  type GetOrderStepGroupByPayload<T extends OrderStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStepGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStepGroupByOutputType[P]>
        }
      >
    >


  export type OrderStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStep"]>

  export type OrderStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStep"]>

  export type OrderStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStep"]>

  export type OrderStepSelectScalar = {
    id?: boolean
    orderId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type OrderStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "title" | "description" | "status" | "completedAt" | "createdAt", ExtArgs["result"]["orderStep"]>
  export type OrderStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStep"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      title: string
      description: string | null
      status: $Enums.StepStatus
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["orderStep"]>
    composites: {}
  }

  type OrderStepGetPayload<S extends boolean | null | undefined | OrderStepDefaultArgs> = $Result.GetResult<Prisma.$OrderStepPayload, S>

  type OrderStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderStepCountAggregateInputType | true
    }

  export interface OrderStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStep'], meta: { name: 'OrderStep' } }
    /**
     * Find zero or one OrderStep that matches the filter.
     * @param {OrderStepFindUniqueArgs} args - Arguments to find a OrderStep
     * @example
     * // Get one OrderStep
     * const orderStep = await prisma.orderStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStepFindUniqueArgs>(args: SelectSubset<T, OrderStepFindUniqueArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderStepFindUniqueOrThrowArgs} args - Arguments to find a OrderStep
     * @example
     * // Get one OrderStep
     * const orderStep = await prisma.orderStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStepFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepFindFirstArgs} args - Arguments to find a OrderStep
     * @example
     * // Get one OrderStep
     * const orderStep = await prisma.orderStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStepFindFirstArgs>(args?: SelectSubset<T, OrderStepFindFirstArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepFindFirstOrThrowArgs} args - Arguments to find a OrderStep
     * @example
     * // Get one OrderStep
     * const orderStep = await prisma.orderStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStepFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderSteps
     * const orderSteps = await prisma.orderStep.findMany()
     * 
     * // Get first 10 OrderSteps
     * const orderSteps = await prisma.orderStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStepWithIdOnly = await prisma.orderStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderStepFindManyArgs>(args?: SelectSubset<T, OrderStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderStep.
     * @param {OrderStepCreateArgs} args - Arguments to create a OrderStep.
     * @example
     * // Create one OrderStep
     * const OrderStep = await prisma.orderStep.create({
     *   data: {
     *     // ... data to create a OrderStep
     *   }
     * })
     * 
     */
    create<T extends OrderStepCreateArgs>(args: SelectSubset<T, OrderStepCreateArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderSteps.
     * @param {OrderStepCreateManyArgs} args - Arguments to create many OrderSteps.
     * @example
     * // Create many OrderSteps
     * const orderStep = await prisma.orderStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStepCreateManyArgs>(args?: SelectSubset<T, OrderStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderSteps and returns the data saved in the database.
     * @param {OrderStepCreateManyAndReturnArgs} args - Arguments to create many OrderSteps.
     * @example
     * // Create many OrderSteps
     * const orderStep = await prisma.orderStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderSteps and only return the `id`
     * const orderStepWithIdOnly = await prisma.orderStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderStepCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderStep.
     * @param {OrderStepDeleteArgs} args - Arguments to delete one OrderStep.
     * @example
     * // Delete one OrderStep
     * const OrderStep = await prisma.orderStep.delete({
     *   where: {
     *     // ... filter to delete one OrderStep
     *   }
     * })
     * 
     */
    delete<T extends OrderStepDeleteArgs>(args: SelectSubset<T, OrderStepDeleteArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderStep.
     * @param {OrderStepUpdateArgs} args - Arguments to update one OrderStep.
     * @example
     * // Update one OrderStep
     * const orderStep = await prisma.orderStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStepUpdateArgs>(args: SelectSubset<T, OrderStepUpdateArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderSteps.
     * @param {OrderStepDeleteManyArgs} args - Arguments to filter OrderSteps to delete.
     * @example
     * // Delete a few OrderSteps
     * const { count } = await prisma.orderStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStepDeleteManyArgs>(args?: SelectSubset<T, OrderStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderSteps
     * const orderStep = await prisma.orderStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStepUpdateManyArgs>(args: SelectSubset<T, OrderStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderSteps and returns the data updated in the database.
     * @param {OrderStepUpdateManyAndReturnArgs} args - Arguments to update many OrderSteps.
     * @example
     * // Update many OrderSteps
     * const orderStep = await prisma.orderStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderSteps and only return the `id`
     * const orderStepWithIdOnly = await prisma.orderStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderStepUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderStep.
     * @param {OrderStepUpsertArgs} args - Arguments to update or create a OrderStep.
     * @example
     * // Update or create a OrderStep
     * const orderStep = await prisma.orderStep.upsert({
     *   create: {
     *     // ... data to create a OrderStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStep we want to update
     *   }
     * })
     */
    upsert<T extends OrderStepUpsertArgs>(args: SelectSubset<T, OrderStepUpsertArgs<ExtArgs>>): Prisma__OrderStepClient<$Result.GetResult<Prisma.$OrderStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepCountArgs} args - Arguments to filter OrderSteps to count.
     * @example
     * // Count the number of OrderSteps
     * const count = await prisma.orderStep.count({
     *   where: {
     *     // ... the filter for the OrderSteps we want to count
     *   }
     * })
    **/
    count<T extends OrderStepCountArgs>(
      args?: Subset<T, OrderStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStepAggregateArgs>(args: Subset<T, OrderStepAggregateArgs>): Prisma.PrismaPromise<GetOrderStepAggregateType<T>>

    /**
     * Group by OrderStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStepGroupByArgs['orderBy'] }
        : { orderBy?: OrderStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStep model
   */
  readonly fields: OrderStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStep model
   */
  interface OrderStepFieldRefs {
    readonly id: FieldRef<"OrderStep", 'String'>
    readonly orderId: FieldRef<"OrderStep", 'String'>
    readonly title: FieldRef<"OrderStep", 'String'>
    readonly description: FieldRef<"OrderStep", 'String'>
    readonly status: FieldRef<"OrderStep", 'StepStatus'>
    readonly completedAt: FieldRef<"OrderStep", 'DateTime'>
    readonly createdAt: FieldRef<"OrderStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderStep findUnique
   */
  export type OrderStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * Filter, which OrderStep to fetch.
     */
    where: OrderStepWhereUniqueInput
  }

  /**
   * OrderStep findUniqueOrThrow
   */
  export type OrderStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * Filter, which OrderStep to fetch.
     */
    where: OrderStepWhereUniqueInput
  }

  /**
   * OrderStep findFirst
   */
  export type OrderStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * Filter, which OrderStep to fetch.
     */
    where?: OrderStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSteps to fetch.
     */
    orderBy?: OrderStepOrderByWithRelationInput | OrderStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSteps.
     */
    cursor?: OrderStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSteps.
     */
    distinct?: OrderStepScalarFieldEnum | OrderStepScalarFieldEnum[]
  }

  /**
   * OrderStep findFirstOrThrow
   */
  export type OrderStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * Filter, which OrderStep to fetch.
     */
    where?: OrderStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSteps to fetch.
     */
    orderBy?: OrderStepOrderByWithRelationInput | OrderStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSteps.
     */
    cursor?: OrderStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSteps.
     */
    distinct?: OrderStepScalarFieldEnum | OrderStepScalarFieldEnum[]
  }

  /**
   * OrderStep findMany
   */
  export type OrderStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * Filter, which OrderSteps to fetch.
     */
    where?: OrderStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSteps to fetch.
     */
    orderBy?: OrderStepOrderByWithRelationInput | OrderStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderSteps.
     */
    cursor?: OrderStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSteps.
     */
    skip?: number
    distinct?: OrderStepScalarFieldEnum | OrderStepScalarFieldEnum[]
  }

  /**
   * OrderStep create
   */
  export type OrderStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStep.
     */
    data: XOR<OrderStepCreateInput, OrderStepUncheckedCreateInput>
  }

  /**
   * OrderStep createMany
   */
  export type OrderStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderSteps.
     */
    data: OrderStepCreateManyInput | OrderStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStep createManyAndReturn
   */
  export type OrderStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * The data used to create many OrderSteps.
     */
    data: OrderStepCreateManyInput | OrderStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderStep update
   */
  export type OrderStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStep.
     */
    data: XOR<OrderStepUpdateInput, OrderStepUncheckedUpdateInput>
    /**
     * Choose, which OrderStep to update.
     */
    where: OrderStepWhereUniqueInput
  }

  /**
   * OrderStep updateMany
   */
  export type OrderStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderSteps.
     */
    data: XOR<OrderStepUpdateManyMutationInput, OrderStepUncheckedUpdateManyInput>
    /**
     * Filter which OrderSteps to update
     */
    where?: OrderStepWhereInput
    /**
     * Limit how many OrderSteps to update.
     */
    limit?: number
  }

  /**
   * OrderStep updateManyAndReturn
   */
  export type OrderStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * The data used to update OrderSteps.
     */
    data: XOR<OrderStepUpdateManyMutationInput, OrderStepUncheckedUpdateManyInput>
    /**
     * Filter which OrderSteps to update
     */
    where?: OrderStepWhereInput
    /**
     * Limit how many OrderSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderStep upsert
   */
  export type OrderStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStep to update in case it exists.
     */
    where: OrderStepWhereUniqueInput
    /**
     * In case the OrderStep found by the `where` argument doesn't exist, create a new OrderStep with this data.
     */
    create: XOR<OrderStepCreateInput, OrderStepUncheckedCreateInput>
    /**
     * In case the OrderStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStepUpdateInput, OrderStepUncheckedUpdateInput>
  }

  /**
   * OrderStep delete
   */
  export type OrderStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
    /**
     * Filter which OrderStep to delete.
     */
    where: OrderStepWhereUniqueInput
  }

  /**
   * OrderStep deleteMany
   */
  export type OrderStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSteps to delete
     */
    where?: OrderStepWhereInput
    /**
     * Limit how many OrderSteps to delete.
     */
    limit?: number
  }

  /**
   * OrderStep without action
   */
  export type OrderStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStep
     */
    select?: OrderStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStep
     */
    omit?: OrderStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStepInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    points: number | null
    discount: number | null
    minAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    points: number | null
    discount: number | null
    minAmount: number | null
    maxDiscount: number | null
    usageLimit: number | null
    usedCount: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    points: number | null
    discount: number | null
    discountType: string | null
    minAmount: number | null
    maxDiscount: number | null
    expiresAt: Date | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    points: number | null
    discount: number | null
    discountType: string | null
    minAmount: number | null
    maxDiscount: number | null
    expiresAt: Date | null
    usageLimit: number | null
    usedCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    points: number
    discount: number
    discountType: number
    minAmount: number
    maxDiscount: number
    expiresAt: number
    usageLimit: number
    usedCount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    points?: true
    discount?: true
    minAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeSumAggregateInputType = {
    points?: true
    discount?: true
    minAmount?: true
    maxDiscount?: true
    usageLimit?: true
    usedCount?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    points?: true
    discount?: true
    discountType?: true
    minAmount?: true
    maxDiscount?: true
    expiresAt?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    points?: true
    discount?: true
    discountType?: true
    minAmount?: true
    maxDiscount?: true
    expiresAt?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    points?: true
    discount?: true
    discountType?: true
    minAmount?: true
    maxDiscount?: true
    expiresAt?: true
    usageLimit?: true
    usedCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    points: number
    discount: number | null
    discountType: string | null
    minAmount: number | null
    maxDiscount: number | null
    expiresAt: Date | null
    usageLimit: number | null
    usedCount: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    points?: boolean
    discount?: boolean
    discountType?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    expiresAt?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usages?: boolean | PromoCode$usagesArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    points?: boolean
    discount?: boolean
    discountType?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    expiresAt?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    points?: boolean
    discount?: boolean
    discountType?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    expiresAt?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    points?: boolean
    discount?: boolean
    discountType?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    expiresAt?: boolean
    usageLimit?: boolean
    usedCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "points" | "discount" | "discountType" | "minAmount" | "maxDiscount" | "expiresAt" | "usageLimit" | "usedCount" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | PromoCode$usagesArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromoCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      usages: Prisma.$PromoCodeUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      points: number
      discount: number | null
      discountType: string | null
      minAmount: number | null
      maxDiscount: number | null
      expiresAt: Date | null
      usageLimit: number | null
      usedCount: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes and returns the data updated in the database.
     * @param {PromoCodeUpdateManyAndReturnArgs} args - Arguments to update many PromoCodes.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usages<T extends PromoCode$usagesArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly points: FieldRef<"PromoCode", 'Int'>
    readonly discount: FieldRef<"PromoCode", 'Float'>
    readonly discountType: FieldRef<"PromoCode", 'String'>
    readonly minAmount: FieldRef<"PromoCode", 'Float'>
    readonly maxDiscount: FieldRef<"PromoCode", 'Float'>
    readonly expiresAt: FieldRef<"PromoCode", 'DateTime'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly usedCount: FieldRef<"PromoCode", 'Int'>
    readonly isActive: FieldRef<"PromoCode", 'Boolean'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
    readonly updatedAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode updateManyAndReturn
   */
  export type PromoCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode.usages
   */
  export type PromoCode$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    cursor?: PromoCodeUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model PromoCodeUsage
   */

  export type AggregatePromoCodeUsage = {
    _count: PromoCodeUsageCountAggregateOutputType | null
    _avg: PromoCodeUsageAvgAggregateOutputType | null
    _sum: PromoCodeUsageSumAggregateOutputType | null
    _min: PromoCodeUsageMinAggregateOutputType | null
    _max: PromoCodeUsageMaxAggregateOutputType | null
  }

  export type PromoCodeUsageAvgAggregateOutputType = {
    points: number | null
  }

  export type PromoCodeUsageSumAggregateOutputType = {
    points: number | null
  }

  export type PromoCodeUsageMinAggregateOutputType = {
    id: string | null
    promoCodeId: string | null
    userId: string | null
    points: number | null
    createdAt: Date | null
  }

  export type PromoCodeUsageMaxAggregateOutputType = {
    id: string | null
    promoCodeId: string | null
    userId: string | null
    points: number | null
    createdAt: Date | null
  }

  export type PromoCodeUsageCountAggregateOutputType = {
    id: number
    promoCodeId: number
    userId: number
    points: number
    createdAt: number
    _all: number
  }


  export type PromoCodeUsageAvgAggregateInputType = {
    points?: true
  }

  export type PromoCodeUsageSumAggregateInputType = {
    points?: true
  }

  export type PromoCodeUsageMinAggregateInputType = {
    id?: true
    promoCodeId?: true
    userId?: true
    points?: true
    createdAt?: true
  }

  export type PromoCodeUsageMaxAggregateInputType = {
    id?: true
    promoCodeId?: true
    userId?: true
    points?: true
    createdAt?: true
  }

  export type PromoCodeUsageCountAggregateInputType = {
    id?: true
    promoCodeId?: true
    userId?: true
    points?: true
    createdAt?: true
    _all?: true
  }

  export type PromoCodeUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodeUsage to aggregate.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodeUsages
    **/
    _count?: true | PromoCodeUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeUsageMaxAggregateInputType
  }

  export type GetPromoCodeUsageAggregateType<T extends PromoCodeUsageAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCodeUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCodeUsage[P]>
      : GetScalarType<T[P], AggregatePromoCodeUsage[P]>
  }




  export type PromoCodeUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithAggregationInput | PromoCodeUsageOrderByWithAggregationInput[]
    by: PromoCodeUsageScalarFieldEnum[] | PromoCodeUsageScalarFieldEnum
    having?: PromoCodeUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeUsageCountAggregateInputType | true
    _avg?: PromoCodeUsageAvgAggregateInputType
    _sum?: PromoCodeUsageSumAggregateInputType
    _min?: PromoCodeUsageMinAggregateInputType
    _max?: PromoCodeUsageMaxAggregateInputType
  }

  export type PromoCodeUsageGroupByOutputType = {
    id: string
    promoCodeId: string
    userId: string
    points: number
    createdAt: Date
    _count: PromoCodeUsageCountAggregateOutputType | null
    _avg: PromoCodeUsageAvgAggregateOutputType | null
    _sum: PromoCodeUsageSumAggregateOutputType | null
    _min: PromoCodeUsageMinAggregateOutputType | null
    _max: PromoCodeUsageMaxAggregateOutputType | null
  }

  type GetPromoCodeUsageGroupByPayload<T extends PromoCodeUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeUsageGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeUsageGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    points?: boolean
    createdAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCodeUsage"]>

  export type PromoCodeUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    points?: boolean
    createdAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCodeUsage"]>

  export type PromoCodeUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    points?: boolean
    createdAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCodeUsage"]>

  export type PromoCodeUsageSelectScalar = {
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    points?: boolean
    createdAt?: boolean
  }

  export type PromoCodeUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promoCodeId" | "userId" | "points" | "createdAt", ExtArgs["result"]["promoCodeUsage"]>
  export type PromoCodeUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PromoCodeUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PromoCodeUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PromoCodeUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCodeUsage"
    objects: {
      promoCode: Prisma.$PromoCodePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promoCodeId: string
      userId: string
      points: number
      createdAt: Date
    }, ExtArgs["result"]["promoCodeUsage"]>
    composites: {}
  }

  type PromoCodeUsageGetPayload<S extends boolean | null | undefined | PromoCodeUsageDefaultArgs> = $Result.GetResult<Prisma.$PromoCodeUsagePayload, S>

  type PromoCodeUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeUsageCountAggregateInputType | true
    }

  export interface PromoCodeUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCodeUsage'], meta: { name: 'PromoCodeUsage' } }
    /**
     * Find zero or one PromoCodeUsage that matches the filter.
     * @param {PromoCodeUsageFindUniqueArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeUsageFindUniqueArgs>(args: SelectSubset<T, PromoCodeUsageFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCodeUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeUsageFindUniqueOrThrowArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCodeUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageFindFirstArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeUsageFindFirstArgs>(args?: SelectSubset<T, PromoCodeUsageFindFirstArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCodeUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageFindFirstOrThrowArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodeUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodeUsages
     * const promoCodeUsages = await prisma.promoCodeUsage.findMany()
     * 
     * // Get first 10 PromoCodeUsages
     * const promoCodeUsages = await prisma.promoCodeUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeUsageWithIdOnly = await prisma.promoCodeUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeUsageFindManyArgs>(args?: SelectSubset<T, PromoCodeUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCodeUsage.
     * @param {PromoCodeUsageCreateArgs} args - Arguments to create a PromoCodeUsage.
     * @example
     * // Create one PromoCodeUsage
     * const PromoCodeUsage = await prisma.promoCodeUsage.create({
     *   data: {
     *     // ... data to create a PromoCodeUsage
     *   }
     * })
     * 
     */
    create<T extends PromoCodeUsageCreateArgs>(args: SelectSubset<T, PromoCodeUsageCreateArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodeUsages.
     * @param {PromoCodeUsageCreateManyArgs} args - Arguments to create many PromoCodeUsages.
     * @example
     * // Create many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeUsageCreateManyArgs>(args?: SelectSubset<T, PromoCodeUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodeUsages and returns the data saved in the database.
     * @param {PromoCodeUsageCreateManyAndReturnArgs} args - Arguments to create many PromoCodeUsages.
     * @example
     * // Create many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodeUsages and only return the `id`
     * const promoCodeUsageWithIdOnly = await prisma.promoCodeUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCodeUsage.
     * @param {PromoCodeUsageDeleteArgs} args - Arguments to delete one PromoCodeUsage.
     * @example
     * // Delete one PromoCodeUsage
     * const PromoCodeUsage = await prisma.promoCodeUsage.delete({
     *   where: {
     *     // ... filter to delete one PromoCodeUsage
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeUsageDeleteArgs>(args: SelectSubset<T, PromoCodeUsageDeleteArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCodeUsage.
     * @param {PromoCodeUsageUpdateArgs} args - Arguments to update one PromoCodeUsage.
     * @example
     * // Update one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUsageUpdateArgs>(args: SelectSubset<T, PromoCodeUsageUpdateArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodeUsages.
     * @param {PromoCodeUsageDeleteManyArgs} args - Arguments to filter PromoCodeUsages to delete.
     * @example
     * // Delete a few PromoCodeUsages
     * const { count } = await prisma.promoCodeUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeUsageDeleteManyArgs>(args?: SelectSubset<T, PromoCodeUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodeUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUsageUpdateManyArgs>(args: SelectSubset<T, PromoCodeUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodeUsages and returns the data updated in the database.
     * @param {PromoCodeUsageUpdateManyAndReturnArgs} args - Arguments to update many PromoCodeUsages.
     * @example
     * // Update many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodeUsages and only return the `id`
     * const promoCodeUsageWithIdOnly = await prisma.promoCodeUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCodeUsage.
     * @param {PromoCodeUsageUpsertArgs} args - Arguments to update or create a PromoCodeUsage.
     * @example
     * // Update or create a PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.upsert({
     *   create: {
     *     // ... data to create a PromoCodeUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCodeUsage we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUsageUpsertArgs>(args: SelectSubset<T, PromoCodeUsageUpsertArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodeUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageCountArgs} args - Arguments to filter PromoCodeUsages to count.
     * @example
     * // Count the number of PromoCodeUsages
     * const count = await prisma.promoCodeUsage.count({
     *   where: {
     *     // ... the filter for the PromoCodeUsages we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeUsageCountArgs>(
      args?: Subset<T, PromoCodeUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCodeUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeUsageAggregateArgs>(args: Subset<T, PromoCodeUsageAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeUsageAggregateType<T>>

    /**
     * Group by PromoCodeUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeUsageGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCodeUsage model
   */
  readonly fields: PromoCodeUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCodeUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promoCode<T extends PromoCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromoCodeDefaultArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCodeUsage model
   */
  interface PromoCodeUsageFieldRefs {
    readonly id: FieldRef<"PromoCodeUsage", 'String'>
    readonly promoCodeId: FieldRef<"PromoCodeUsage", 'String'>
    readonly userId: FieldRef<"PromoCodeUsage", 'String'>
    readonly points: FieldRef<"PromoCodeUsage", 'Int'>
    readonly createdAt: FieldRef<"PromoCodeUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCodeUsage findUnique
   */
  export type PromoCodeUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage findUniqueOrThrow
   */
  export type PromoCodeUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage findFirst
   */
  export type PromoCodeUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodeUsages.
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodeUsages.
     */
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCodeUsage findFirstOrThrow
   */
  export type PromoCodeUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodeUsages.
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodeUsages.
     */
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCodeUsage findMany
   */
  export type PromoCodeUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsages to fetch.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodeUsages.
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCodeUsage create
   */
  export type PromoCodeUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCodeUsage.
     */
    data: XOR<PromoCodeUsageCreateInput, PromoCodeUsageUncheckedCreateInput>
  }

  /**
   * PromoCodeUsage createMany
   */
  export type PromoCodeUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodeUsages.
     */
    data: PromoCodeUsageCreateManyInput | PromoCodeUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCodeUsage createManyAndReturn
   */
  export type PromoCodeUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodeUsages.
     */
    data: PromoCodeUsageCreateManyInput | PromoCodeUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCodeUsage update
   */
  export type PromoCodeUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCodeUsage.
     */
    data: XOR<PromoCodeUsageUpdateInput, PromoCodeUsageUncheckedUpdateInput>
    /**
     * Choose, which PromoCodeUsage to update.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage updateMany
   */
  export type PromoCodeUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodeUsages.
     */
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodeUsages to update
     */
    where?: PromoCodeUsageWhereInput
    /**
     * Limit how many PromoCodeUsages to update.
     */
    limit?: number
  }

  /**
   * PromoCodeUsage updateManyAndReturn
   */
  export type PromoCodeUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodeUsages.
     */
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodeUsages to update
     */
    where?: PromoCodeUsageWhereInput
    /**
     * Limit how many PromoCodeUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCodeUsage upsert
   */
  export type PromoCodeUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCodeUsage to update in case it exists.
     */
    where: PromoCodeUsageWhereUniqueInput
    /**
     * In case the PromoCodeUsage found by the `where` argument doesn't exist, create a new PromoCodeUsage with this data.
     */
    create: XOR<PromoCodeUsageCreateInput, PromoCodeUsageUncheckedCreateInput>
    /**
     * In case the PromoCodeUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUsageUpdateInput, PromoCodeUsageUncheckedUpdateInput>
  }

  /**
   * PromoCodeUsage delete
   */
  export type PromoCodeUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter which PromoCodeUsage to delete.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage deleteMany
   */
  export type PromoCodeUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodeUsages to delete
     */
    where?: PromoCodeUsageWhereInput
    /**
     * Limit how many PromoCodeUsages to delete.
     */
    limit?: number
  }

  /**
   * PromoCodeUsage without action
   */
  export type PromoCodeUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    points: number | null
  }

  export type ReferralSumAggregateOutputType = {
    points: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    referredId: string | null
    points: number | null
    status: $Enums.ReferralStatus | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    referredId: string | null
    points: number | null
    status: $Enums.ReferralStatus | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    referredId: number
    points: number
    status: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    points?: true
  }

  export type ReferralSumAggregateInputType = {
    points?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    points?: true
    status?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    points?: true
    status?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    points?: true
    status?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    referredId: string
    points: number
    status: $Enums.ReferralStatus
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referrerId" | "referredId" | "points" | "status" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referred: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      referredId: string
      points: number
      status: $Enums.ReferralStatus
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referred<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly referredId: FieldRef<"Referral", 'String'>
    readonly points: FieldRef<"Referral", 'Int'>
    readonly status: FieldRef<"Referral", 'ReferralStatus'>
    readonly completedAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
    readonly updatedAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    serviceId: string | null
    authorId: string | null
    masterId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    serviceId: string | null
    authorId: string | null
    masterId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    orderId: number
    serviceId: number
    authorId: number
    masterId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    authorId?: true
    masterId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    authorId?: true
    masterId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    orderId?: true
    serviceId?: true
    authorId?: true
    masterId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    orderId: string
    serviceId: string
    authorId: string
    masterId: string | null
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    authorId?: boolean
    masterId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    master?: boolean | Review$masterArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    authorId?: boolean
    masterId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    master?: boolean | Review$masterArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    authorId?: boolean
    masterId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    master?: boolean | Review$masterArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    orderId?: boolean
    serviceId?: boolean
    authorId?: boolean
    masterId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "serviceId" | "authorId" | "masterId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    master?: boolean | Review$masterArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    master?: boolean | Review$masterArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    master?: boolean | Review$masterArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      master: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      serviceId: string
      authorId: string
      masterId: string | null
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    master<T extends Review$masterArgs<ExtArgs> = {}>(args?: Subset<T, Review$masterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly orderId: FieldRef<"Review", 'String'>
    readonly serviceId: FieldRef<"Review", 'String'>
    readonly authorId: FieldRef<"Review", 'String'>
    readonly masterId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.master
   */
  export type Review$masterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCategoryCountAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    homePageItems?: boolean | ServiceCategory$homePageItemsArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "icon" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceCategory"]>
  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    homePageItems?: boolean | ServiceCategory$homePageItemsArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      homePageItems: Prisma.$HomePageSectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories and returns the data updated in the database.
     * @param {ServiceCategoryUpdateManyAndReturnArgs} args - Arguments to update many ServiceCategories.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceCategory$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homePageItems<T extends ServiceCategory$homePageItemsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$homePageItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly slug: FieldRef<"ServiceCategory", 'String'>
    readonly description: FieldRef<"ServiceCategory", 'String'>
    readonly icon: FieldRef<"ServiceCategory", 'String'>
    readonly image: FieldRef<"ServiceCategory", 'String'>
    readonly createdAt: FieldRef<"ServiceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory updateManyAndReturn
   */
  export type ServiceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to update.
     */
    limit?: number
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
    /**
     * Limit how many ServiceCategories to delete.
     */
    limit?: number
  }

  /**
   * ServiceCategory.services
   */
  export type ServiceCategory$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory.homePageItems
   */
  export type ServiceCategory$homePageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    where?: HomePageSectionItemWhereInput
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    cursor?: HomePageSectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomePageSectionItemScalarFieldEnum | HomePageSectionItemScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCategory
     */
    omit?: ServiceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: number | null
    image: string | null
    time: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: number | null
    image: string | null
    time: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    price: number
    image: number
    time: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    image?: true
    time?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    image?: true
    time?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    image?: true
    time?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    price: number | null
    image: string | null
    time: string | null
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    time?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    orders?: boolean | Service$ordersArgs<ExtArgs>
    cities?: boolean | Service$citiesArgs<ExtArgs>
    homePageItems?: boolean | Service$homePageItemsArgs<ExtArgs>
    reviews?: boolean | Service$reviewsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    time?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    time?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    image?: boolean
    time?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "price" | "image" | "time" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    orders?: boolean | Service$ordersArgs<ExtArgs>
    cities?: boolean | Service$citiesArgs<ExtArgs>
    homePageItems?: boolean | Service$homePageItemsArgs<ExtArgs>
    reviews?: boolean | Service$reviewsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
      orders: Prisma.$OrderItemPayload<ExtArgs>[]
      cities: Prisma.$ServiceCityPayload<ExtArgs>[]
      homePageItems: Prisma.$HomePageSectionItemPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      price: number | null
      image: string | null
      time: string | null
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Service$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Service$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cities<T extends Service$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Service$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homePageItems<T extends Service$homePageItemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$homePageItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomePageSectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Service$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Service$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly image: FieldRef<"Service", 'String'>
    readonly time: FieldRef<"Service", 'String'>
    readonly categoryId: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.orders
   */
  export type Service$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Service.cities
   */
  export type Service$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    where?: ServiceCityWhereInput
    orderBy?: ServiceCityOrderByWithRelationInput | ServiceCityOrderByWithRelationInput[]
    cursor?: ServiceCityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceCityScalarFieldEnum | ServiceCityScalarFieldEnum[]
  }

  /**
   * Service.homePageItems
   */
  export type Service$homePageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomePageSectionItem
     */
    select?: HomePageSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomePageSectionItem
     */
    omit?: HomePageSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomePageSectionItemInclude<ExtArgs> | null
    where?: HomePageSectionItemWhereInput
    orderBy?: HomePageSectionItemOrderByWithRelationInput | HomePageSectionItemOrderByWithRelationInput[]
    cursor?: HomePageSectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomePageSectionItemScalarFieldEnum | HomePageSectionItemScalarFieldEnum[]
  }

  /**
   * Service.reviews
   */
  export type Service$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCity
   */

  export type AggregateServiceCity = {
    _count: ServiceCityCountAggregateOutputType | null
    _min: ServiceCityMinAggregateOutputType | null
    _max: ServiceCityMaxAggregateOutputType | null
  }

  export type ServiceCityMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    cityId: string | null
    createdAt: Date | null
  }

  export type ServiceCityMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    cityId: string | null
    createdAt: Date | null
  }

  export type ServiceCityCountAggregateOutputType = {
    id: number
    serviceId: number
    cityId: number
    createdAt: number
    _all: number
  }


  export type ServiceCityMinAggregateInputType = {
    id?: true
    serviceId?: true
    cityId?: true
    createdAt?: true
  }

  export type ServiceCityMaxAggregateInputType = {
    id?: true
    serviceId?: true
    cityId?: true
    createdAt?: true
  }

  export type ServiceCityCountAggregateInputType = {
    id?: true
    serviceId?: true
    cityId?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceCityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCity to aggregate.
     */
    where?: ServiceCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCities to fetch.
     */
    orderBy?: ServiceCityOrderByWithRelationInput | ServiceCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCities
    **/
    _count?: true | ServiceCityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCityMaxAggregateInputType
  }

  export type GetServiceCityAggregateType<T extends ServiceCityAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCity[P]>
      : GetScalarType<T[P], AggregateServiceCity[P]>
  }




  export type ServiceCityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCityWhereInput
    orderBy?: ServiceCityOrderByWithAggregationInput | ServiceCityOrderByWithAggregationInput[]
    by: ServiceCityScalarFieldEnum[] | ServiceCityScalarFieldEnum
    having?: ServiceCityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCityCountAggregateInputType | true
    _min?: ServiceCityMinAggregateInputType
    _max?: ServiceCityMaxAggregateInputType
  }

  export type ServiceCityGroupByOutputType = {
    id: string
    serviceId: string
    cityId: string
    createdAt: Date
    _count: ServiceCityCountAggregateOutputType | null
    _min: ServiceCityMinAggregateOutputType | null
    _max: ServiceCityMaxAggregateOutputType | null
  }

  type GetServiceCityGroupByPayload<T extends ServiceCityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCityGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCityGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCity"]>

  export type ServiceCitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCity"]>

  export type ServiceCitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCity"]>

  export type ServiceCitySelectScalar = {
    id?: boolean
    serviceId?: boolean
    cityId?: boolean
    createdAt?: boolean
  }

  export type ServiceCityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "cityId" | "createdAt", ExtArgs["result"]["serviceCity"]>
  export type ServiceCityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type ServiceCityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type ServiceCityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $ServiceCityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCity"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      cityId: string
      createdAt: Date
    }, ExtArgs["result"]["serviceCity"]>
    composites: {}
  }

  type ServiceCityGetPayload<S extends boolean | null | undefined | ServiceCityDefaultArgs> = $Result.GetResult<Prisma.$ServiceCityPayload, S>

  type ServiceCityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceCityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCityCountAggregateInputType | true
    }

  export interface ServiceCityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCity'], meta: { name: 'ServiceCity' } }
    /**
     * Find zero or one ServiceCity that matches the filter.
     * @param {ServiceCityFindUniqueArgs} args - Arguments to find a ServiceCity
     * @example
     * // Get one ServiceCity
     * const serviceCity = await prisma.serviceCity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCityFindUniqueArgs>(args: SelectSubset<T, ServiceCityFindUniqueArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceCity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceCityFindUniqueOrThrowArgs} args - Arguments to find a ServiceCity
     * @example
     * // Get one ServiceCity
     * const serviceCity = await prisma.serviceCity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCityFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityFindFirstArgs} args - Arguments to find a ServiceCity
     * @example
     * // Get one ServiceCity
     * const serviceCity = await prisma.serviceCity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCityFindFirstArgs>(args?: SelectSubset<T, ServiceCityFindFirstArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceCity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityFindFirstOrThrowArgs} args - Arguments to find a ServiceCity
     * @example
     * // Get one ServiceCity
     * const serviceCity = await prisma.serviceCity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCityFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceCities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCities
     * const serviceCities = await prisma.serviceCity.findMany()
     * 
     * // Get first 10 ServiceCities
     * const serviceCities = await prisma.serviceCity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCityWithIdOnly = await prisma.serviceCity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCityFindManyArgs>(args?: SelectSubset<T, ServiceCityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceCity.
     * @param {ServiceCityCreateArgs} args - Arguments to create a ServiceCity.
     * @example
     * // Create one ServiceCity
     * const ServiceCity = await prisma.serviceCity.create({
     *   data: {
     *     // ... data to create a ServiceCity
     *   }
     * })
     * 
     */
    create<T extends ServiceCityCreateArgs>(args: SelectSubset<T, ServiceCityCreateArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceCities.
     * @param {ServiceCityCreateManyArgs} args - Arguments to create many ServiceCities.
     * @example
     * // Create many ServiceCities
     * const serviceCity = await prisma.serviceCity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCityCreateManyArgs>(args?: SelectSubset<T, ServiceCityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCities and returns the data saved in the database.
     * @param {ServiceCityCreateManyAndReturnArgs} args - Arguments to create many ServiceCities.
     * @example
     * // Create many ServiceCities
     * const serviceCity = await prisma.serviceCity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCities and only return the `id`
     * const serviceCityWithIdOnly = await prisma.serviceCity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCityCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceCity.
     * @param {ServiceCityDeleteArgs} args - Arguments to delete one ServiceCity.
     * @example
     * // Delete one ServiceCity
     * const ServiceCity = await prisma.serviceCity.delete({
     *   where: {
     *     // ... filter to delete one ServiceCity
     *   }
     * })
     * 
     */
    delete<T extends ServiceCityDeleteArgs>(args: SelectSubset<T, ServiceCityDeleteArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceCity.
     * @param {ServiceCityUpdateArgs} args - Arguments to update one ServiceCity.
     * @example
     * // Update one ServiceCity
     * const serviceCity = await prisma.serviceCity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCityUpdateArgs>(args: SelectSubset<T, ServiceCityUpdateArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceCities.
     * @param {ServiceCityDeleteManyArgs} args - Arguments to filter ServiceCities to delete.
     * @example
     * // Delete a few ServiceCities
     * const { count } = await prisma.serviceCity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCityDeleteManyArgs>(args?: SelectSubset<T, ServiceCityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCities
     * const serviceCity = await prisma.serviceCity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCityUpdateManyArgs>(args: SelectSubset<T, ServiceCityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCities and returns the data updated in the database.
     * @param {ServiceCityUpdateManyAndReturnArgs} args - Arguments to update many ServiceCities.
     * @example
     * // Update many ServiceCities
     * const serviceCity = await prisma.serviceCity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceCities and only return the `id`
     * const serviceCityWithIdOnly = await prisma.serviceCity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceCityUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceCityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceCity.
     * @param {ServiceCityUpsertArgs} args - Arguments to update or create a ServiceCity.
     * @example
     * // Update or create a ServiceCity
     * const serviceCity = await prisma.serviceCity.upsert({
     *   create: {
     *     // ... data to create a ServiceCity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCity we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCityUpsertArgs>(args: SelectSubset<T, ServiceCityUpsertArgs<ExtArgs>>): Prisma__ServiceCityClient<$Result.GetResult<Prisma.$ServiceCityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceCities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityCountArgs} args - Arguments to filter ServiceCities to count.
     * @example
     * // Count the number of ServiceCities
     * const count = await prisma.serviceCity.count({
     *   where: {
     *     // ... the filter for the ServiceCities we want to count
     *   }
     * })
    **/
    count<T extends ServiceCityCountArgs>(
      args?: Subset<T, ServiceCityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCityAggregateArgs>(args: Subset<T, ServiceCityAggregateArgs>): Prisma.PrismaPromise<GetServiceCityAggregateType<T>>

    /**
     * Group by ServiceCity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCityGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCity model
   */
  readonly fields: ServiceCityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCity model
   */
  interface ServiceCityFieldRefs {
    readonly id: FieldRef<"ServiceCity", 'String'>
    readonly serviceId: FieldRef<"ServiceCity", 'String'>
    readonly cityId: FieldRef<"ServiceCity", 'String'>
    readonly createdAt: FieldRef<"ServiceCity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCity findUnique
   */
  export type ServiceCityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCity to fetch.
     */
    where: ServiceCityWhereUniqueInput
  }

  /**
   * ServiceCity findUniqueOrThrow
   */
  export type ServiceCityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCity to fetch.
     */
    where: ServiceCityWhereUniqueInput
  }

  /**
   * ServiceCity findFirst
   */
  export type ServiceCityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCity to fetch.
     */
    where?: ServiceCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCities to fetch.
     */
    orderBy?: ServiceCityOrderByWithRelationInput | ServiceCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCities.
     */
    cursor?: ServiceCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCities.
     */
    distinct?: ServiceCityScalarFieldEnum | ServiceCityScalarFieldEnum[]
  }

  /**
   * ServiceCity findFirstOrThrow
   */
  export type ServiceCityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCity to fetch.
     */
    where?: ServiceCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCities to fetch.
     */
    orderBy?: ServiceCityOrderByWithRelationInput | ServiceCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCities.
     */
    cursor?: ServiceCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCities.
     */
    distinct?: ServiceCityScalarFieldEnum | ServiceCityScalarFieldEnum[]
  }

  /**
   * ServiceCity findMany
   */
  export type ServiceCityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCities to fetch.
     */
    where?: ServiceCityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCities to fetch.
     */
    orderBy?: ServiceCityOrderByWithRelationInput | ServiceCityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCities.
     */
    cursor?: ServiceCityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCities.
     */
    skip?: number
    distinct?: ServiceCityScalarFieldEnum | ServiceCityScalarFieldEnum[]
  }

  /**
   * ServiceCity create
   */
  export type ServiceCityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCity.
     */
    data: XOR<ServiceCityCreateInput, ServiceCityUncheckedCreateInput>
  }

  /**
   * ServiceCity createMany
   */
  export type ServiceCityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCities.
     */
    data: ServiceCityCreateManyInput | ServiceCityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCity createManyAndReturn
   */
  export type ServiceCityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceCities.
     */
    data: ServiceCityCreateManyInput | ServiceCityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceCity update
   */
  export type ServiceCityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCity.
     */
    data: XOR<ServiceCityUpdateInput, ServiceCityUncheckedUpdateInput>
    /**
     * Choose, which ServiceCity to update.
     */
    where: ServiceCityWhereUniqueInput
  }

  /**
   * ServiceCity updateMany
   */
  export type ServiceCityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCities.
     */
    data: XOR<ServiceCityUpdateManyMutationInput, ServiceCityUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCities to update
     */
    where?: ServiceCityWhereInput
    /**
     * Limit how many ServiceCities to update.
     */
    limit?: number
  }

  /**
   * ServiceCity updateManyAndReturn
   */
  export type ServiceCityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * The data used to update ServiceCities.
     */
    data: XOR<ServiceCityUpdateManyMutationInput, ServiceCityUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCities to update
     */
    where?: ServiceCityWhereInput
    /**
     * Limit how many ServiceCities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceCity upsert
   */
  export type ServiceCityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCity to update in case it exists.
     */
    where: ServiceCityWhereUniqueInput
    /**
     * In case the ServiceCity found by the `where` argument doesn't exist, create a new ServiceCity with this data.
     */
    create: XOR<ServiceCityCreateInput, ServiceCityUncheckedCreateInput>
    /**
     * In case the ServiceCity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCityUpdateInput, ServiceCityUncheckedUpdateInput>
  }

  /**
   * ServiceCity delete
   */
  export type ServiceCityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
    /**
     * Filter which ServiceCity to delete.
     */
    where: ServiceCityWhereUniqueInput
  }

  /**
   * ServiceCity deleteMany
   */
  export type ServiceCityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCities to delete
     */
    where?: ServiceCityWhereInput
    /**
     * Limit how many ServiceCities to delete.
     */
    limit?: number
  }

  /**
   * ServiceCity without action
   */
  export type ServiceCityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCity
     */
    select?: ServiceCitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceCity
     */
    omit?: ServiceCityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCityInclude<ExtArgs> | null
  }


  /**
   * Model Story
   */

  export type AggregateStory = {
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  export type StoryAvgAggregateOutputType = {
    order: number | null
  }

  export type StorySumAggregateOutputType = {
    order: number | null
  }

  export type StoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    image: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryCountAggregateOutputType = {
    id: number
    title: number
    image: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryAvgAggregateInputType = {
    order?: true
  }

  export type StorySumAggregateInputType = {
    order?: true
  }

  export type StoryMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Story to aggregate.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stories
    **/
    _count?: true | StoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryMaxAggregateInputType
  }

  export type GetStoryAggregateType<T extends StoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStory[P]>
      : GetScalarType<T[P], AggregateStory[P]>
  }




  export type StoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithAggregationInput | StoryOrderByWithAggregationInput[]
    by: StoryScalarFieldEnum[] | StoryScalarFieldEnum
    having?: StoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCountAggregateInputType | true
    _avg?: StoryAvgAggregateInputType
    _sum?: StorySumAggregateInputType
    _min?: StoryMinAggregateInputType
    _max?: StoryMaxAggregateInputType
  }

  export type StoryGroupByOutputType = {
    id: string
    title: string
    image: string | null
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  type GetStoryGroupByPayload<T extends StoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryGroupByOutputType[P]>
            : GetScalarType<T[P], StoryGroupByOutputType[P]>
        }
      >
    >


  export type StorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | Story$imagesArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["story"]>

  export type StorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["story"]>

  export type StorySelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "image" | "isActive" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["story"]>
  export type StoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Story$imagesArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Story"
    objects: {
      images: Prisma.$StoryImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      image: string | null
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["story"]>
    composites: {}
  }

  type StoryGetPayload<S extends boolean | null | undefined | StoryDefaultArgs> = $Result.GetResult<Prisma.$StoryPayload, S>

  type StoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryCountAggregateInputType | true
    }

  export interface StoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Story'], meta: { name: 'Story' } }
    /**
     * Find zero or one Story that matches the filter.
     * @param {StoryFindUniqueArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryFindUniqueArgs>(args: SelectSubset<T, StoryFindUniqueArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Story that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryFindUniqueOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryFindFirstArgs>(args?: SelectSubset<T, StoryFindFirstArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stories
     * const stories = await prisma.story.findMany()
     * 
     * // Get first 10 Stories
     * const stories = await prisma.story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyWithIdOnly = await prisma.story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryFindManyArgs>(args?: SelectSubset<T, StoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Story.
     * @param {StoryCreateArgs} args - Arguments to create a Story.
     * @example
     * // Create one Story
     * const Story = await prisma.story.create({
     *   data: {
     *     // ... data to create a Story
     *   }
     * })
     * 
     */
    create<T extends StoryCreateArgs>(args: SelectSubset<T, StoryCreateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stories.
     * @param {StoryCreateManyArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCreateManyArgs>(args?: SelectSubset<T, StoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stories and returns the data saved in the database.
     * @param {StoryCreateManyAndReturnArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Story.
     * @param {StoryDeleteArgs} args - Arguments to delete one Story.
     * @example
     * // Delete one Story
     * const Story = await prisma.story.delete({
     *   where: {
     *     // ... filter to delete one Story
     *   }
     * })
     * 
     */
    delete<T extends StoryDeleteArgs>(args: SelectSubset<T, StoryDeleteArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Story.
     * @param {StoryUpdateArgs} args - Arguments to update one Story.
     * @example
     * // Update one Story
     * const story = await prisma.story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryUpdateArgs>(args: SelectSubset<T, StoryUpdateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stories.
     * @param {StoryDeleteManyArgs} args - Arguments to filter Stories to delete.
     * @example
     * // Delete a few Stories
     * const { count } = await prisma.story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryDeleteManyArgs>(args?: SelectSubset<T, StoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryUpdateManyArgs>(args: SelectSubset<T, StoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories and returns the data updated in the database.
     * @param {StoryUpdateManyAndReturnArgs} args - Arguments to update many Stories.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Story.
     * @param {StoryUpsertArgs} args - Arguments to update or create a Story.
     * @example
     * // Update or create a Story
     * const story = await prisma.story.upsert({
     *   create: {
     *     // ... data to create a Story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Story we want to update
     *   }
     * })
     */
    upsert<T extends StoryUpsertArgs>(args: SelectSubset<T, StoryUpsertArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCountArgs} args - Arguments to filter Stories to count.
     * @example
     * // Count the number of Stories
     * const count = await prisma.story.count({
     *   where: {
     *     // ... the filter for the Stories we want to count
     *   }
     * })
    **/
    count<T extends StoryCountArgs>(
      args?: Subset<T, StoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAggregateArgs>(args: Subset<T, StoryAggregateArgs>): Prisma.PrismaPromise<GetStoryAggregateType<T>>

    /**
     * Group by Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryGroupByArgs['orderBy'] }
        : { orderBy?: StoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Story model
   */
  readonly fields: StoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Story$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Story$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Story model
   */
  interface StoryFieldRefs {
    readonly id: FieldRef<"Story", 'String'>
    readonly title: FieldRef<"Story", 'String'>
    readonly image: FieldRef<"Story", 'String'>
    readonly isActive: FieldRef<"Story", 'Boolean'>
    readonly order: FieldRef<"Story", 'Int'>
    readonly createdAt: FieldRef<"Story", 'DateTime'>
    readonly updatedAt: FieldRef<"Story", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Story findUnique
   */
  export type StoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findUniqueOrThrow
   */
  export type StoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findFirst
   */
  export type StoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findFirstOrThrow
   */
  export type StoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findMany
   */
  export type StoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Stories to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story create
   */
  export type StoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Story.
     */
    data: XOR<StoryCreateInput, StoryUncheckedCreateInput>
  }

  /**
   * Story createMany
   */
  export type StoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story createManyAndReturn
   */
  export type StoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story update
   */
  export type StoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Story.
     */
    data: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
    /**
     * Choose, which Story to update.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story updateMany
   */
  export type StoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
  }

  /**
   * Story updateManyAndReturn
   */
  export type StoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
  }

  /**
   * Story upsert
   */
  export type StoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Story to update in case it exists.
     */
    where: StoryWhereUniqueInput
    /**
     * In case the Story found by the `where` argument doesn't exist, create a new Story with this data.
     */
    create: XOR<StoryCreateInput, StoryUncheckedCreateInput>
    /**
     * In case the Story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
  }

  /**
   * Story delete
   */
  export type StoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter which Story to delete.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story deleteMany
   */
  export type StoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stories to delete
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to delete.
     */
    limit?: number
  }

  /**
   * Story.images
   */
  export type Story$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    where?: StoryImageWhereInput
    orderBy?: StoryImageOrderByWithRelationInput | StoryImageOrderByWithRelationInput[]
    cursor?: StoryImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryImageScalarFieldEnum | StoryImageScalarFieldEnum[]
  }

  /**
   * Story without action
   */
  export type StoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
  }


  /**
   * Model StoryImage
   */

  export type AggregateStoryImage = {
    _count: StoryImageCountAggregateOutputType | null
    _avg: StoryImageAvgAggregateOutputType | null
    _sum: StoryImageSumAggregateOutputType | null
    _min: StoryImageMinAggregateOutputType | null
    _max: StoryImageMaxAggregateOutputType | null
  }

  export type StoryImageAvgAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type StoryImageSumAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type StoryImageMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    image: string | null
    title: string | null
    duration: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryImageMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    image: string | null
    title: string | null
    duration: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoryImageCountAggregateOutputType = {
    id: number
    storyId: number
    image: number
    title: number
    duration: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoryImageAvgAggregateInputType = {
    duration?: true
    order?: true
  }

  export type StoryImageSumAggregateInputType = {
    duration?: true
    order?: true
  }

  export type StoryImageMinAggregateInputType = {
    id?: true
    storyId?: true
    image?: true
    title?: true
    duration?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryImageMaxAggregateInputType = {
    id?: true
    storyId?: true
    image?: true
    title?: true
    duration?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoryImageCountAggregateInputType = {
    id?: true
    storyId?: true
    image?: true
    title?: true
    duration?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoryImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryImage to aggregate.
     */
    where?: StoryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryImages to fetch.
     */
    orderBy?: StoryImageOrderByWithRelationInput | StoryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryImages
    **/
    _count?: true | StoryImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoryImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryImageMaxAggregateInputType
  }

  export type GetStoryImageAggregateType<T extends StoryImageAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryImage[P]>
      : GetScalarType<T[P], AggregateStoryImage[P]>
  }




  export type StoryImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryImageWhereInput
    orderBy?: StoryImageOrderByWithAggregationInput | StoryImageOrderByWithAggregationInput[]
    by: StoryImageScalarFieldEnum[] | StoryImageScalarFieldEnum
    having?: StoryImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryImageCountAggregateInputType | true
    _avg?: StoryImageAvgAggregateInputType
    _sum?: StoryImageSumAggregateInputType
    _min?: StoryImageMinAggregateInputType
    _max?: StoryImageMaxAggregateInputType
  }

  export type StoryImageGroupByOutputType = {
    id: string
    storyId: string
    image: string
    title: string | null
    duration: number
    order: number
    createdAt: Date
    updatedAt: Date
    _count: StoryImageCountAggregateOutputType | null
    _avg: StoryImageAvgAggregateOutputType | null
    _sum: StoryImageSumAggregateOutputType | null
    _min: StoryImageMinAggregateOutputType | null
    _max: StoryImageMaxAggregateOutputType | null
  }

  type GetStoryImageGroupByPayload<T extends StoryImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryImageGroupByOutputType[P]>
            : GetScalarType<T[P], StoryImageGroupByOutputType[P]>
        }
      >
    >


  export type StoryImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    image?: boolean
    title?: boolean
    duration?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyImage"]>

  export type StoryImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    image?: boolean
    title?: boolean
    duration?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyImage"]>

  export type StoryImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    image?: boolean
    title?: boolean
    duration?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyImage"]>

  export type StoryImageSelectScalar = {
    id?: boolean
    storyId?: boolean
    image?: boolean
    title?: boolean
    duration?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoryImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "image" | "title" | "duration" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["storyImage"]>
  export type StoryImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }
  export type StoryImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }
  export type StoryImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }

  export type $StoryImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryImage"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      image: string
      title: string | null
      duration: number
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storyImage"]>
    composites: {}
  }

  type StoryImageGetPayload<S extends boolean | null | undefined | StoryImageDefaultArgs> = $Result.GetResult<Prisma.$StoryImagePayload, S>

  type StoryImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryImageCountAggregateInputType | true
    }

  export interface StoryImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryImage'], meta: { name: 'StoryImage' } }
    /**
     * Find zero or one StoryImage that matches the filter.
     * @param {StoryImageFindUniqueArgs} args - Arguments to find a StoryImage
     * @example
     * // Get one StoryImage
     * const storyImage = await prisma.storyImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryImageFindUniqueArgs>(args: SelectSubset<T, StoryImageFindUniqueArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryImageFindUniqueOrThrowArgs} args - Arguments to find a StoryImage
     * @example
     * // Get one StoryImage
     * const storyImage = await prisma.storyImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryImageFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageFindFirstArgs} args - Arguments to find a StoryImage
     * @example
     * // Get one StoryImage
     * const storyImage = await prisma.storyImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryImageFindFirstArgs>(args?: SelectSubset<T, StoryImageFindFirstArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageFindFirstOrThrowArgs} args - Arguments to find a StoryImage
     * @example
     * // Get one StoryImage
     * const storyImage = await prisma.storyImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryImageFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryImages
     * const storyImages = await prisma.storyImage.findMany()
     * 
     * // Get first 10 StoryImages
     * const storyImages = await prisma.storyImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyImageWithIdOnly = await prisma.storyImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryImageFindManyArgs>(args?: SelectSubset<T, StoryImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryImage.
     * @param {StoryImageCreateArgs} args - Arguments to create a StoryImage.
     * @example
     * // Create one StoryImage
     * const StoryImage = await prisma.storyImage.create({
     *   data: {
     *     // ... data to create a StoryImage
     *   }
     * })
     * 
     */
    create<T extends StoryImageCreateArgs>(args: SelectSubset<T, StoryImageCreateArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryImages.
     * @param {StoryImageCreateManyArgs} args - Arguments to create many StoryImages.
     * @example
     * // Create many StoryImages
     * const storyImage = await prisma.storyImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryImageCreateManyArgs>(args?: SelectSubset<T, StoryImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryImages and returns the data saved in the database.
     * @param {StoryImageCreateManyAndReturnArgs} args - Arguments to create many StoryImages.
     * @example
     * // Create many StoryImages
     * const storyImage = await prisma.storyImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryImages and only return the `id`
     * const storyImageWithIdOnly = await prisma.storyImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryImageCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryImage.
     * @param {StoryImageDeleteArgs} args - Arguments to delete one StoryImage.
     * @example
     * // Delete one StoryImage
     * const StoryImage = await prisma.storyImage.delete({
     *   where: {
     *     // ... filter to delete one StoryImage
     *   }
     * })
     * 
     */
    delete<T extends StoryImageDeleteArgs>(args: SelectSubset<T, StoryImageDeleteArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryImage.
     * @param {StoryImageUpdateArgs} args - Arguments to update one StoryImage.
     * @example
     * // Update one StoryImage
     * const storyImage = await prisma.storyImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryImageUpdateArgs>(args: SelectSubset<T, StoryImageUpdateArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryImages.
     * @param {StoryImageDeleteManyArgs} args - Arguments to filter StoryImages to delete.
     * @example
     * // Delete a few StoryImages
     * const { count } = await prisma.storyImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryImageDeleteManyArgs>(args?: SelectSubset<T, StoryImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryImages
     * const storyImage = await prisma.storyImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryImageUpdateManyArgs>(args: SelectSubset<T, StoryImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryImages and returns the data updated in the database.
     * @param {StoryImageUpdateManyAndReturnArgs} args - Arguments to update many StoryImages.
     * @example
     * // Update many StoryImages
     * const storyImage = await prisma.storyImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryImages and only return the `id`
     * const storyImageWithIdOnly = await prisma.storyImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryImageUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryImage.
     * @param {StoryImageUpsertArgs} args - Arguments to update or create a StoryImage.
     * @example
     * // Update or create a StoryImage
     * const storyImage = await prisma.storyImage.upsert({
     *   create: {
     *     // ... data to create a StoryImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryImage we want to update
     *   }
     * })
     */
    upsert<T extends StoryImageUpsertArgs>(args: SelectSubset<T, StoryImageUpsertArgs<ExtArgs>>): Prisma__StoryImageClient<$Result.GetResult<Prisma.$StoryImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageCountArgs} args - Arguments to filter StoryImages to count.
     * @example
     * // Count the number of StoryImages
     * const count = await prisma.storyImage.count({
     *   where: {
     *     // ... the filter for the StoryImages we want to count
     *   }
     * })
    **/
    count<T extends StoryImageCountArgs>(
      args?: Subset<T, StoryImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryImageAggregateArgs>(args: Subset<T, StoryImageAggregateArgs>): Prisma.PrismaPromise<GetStoryImageAggregateType<T>>

    /**
     * Group by StoryImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryImageGroupByArgs['orderBy'] }
        : { orderBy?: StoryImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryImage model
   */
  readonly fields: StoryImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryImage model
   */
  interface StoryImageFieldRefs {
    readonly id: FieldRef<"StoryImage", 'String'>
    readonly storyId: FieldRef<"StoryImage", 'String'>
    readonly image: FieldRef<"StoryImage", 'String'>
    readonly title: FieldRef<"StoryImage", 'String'>
    readonly duration: FieldRef<"StoryImage", 'Int'>
    readonly order: FieldRef<"StoryImage", 'Int'>
    readonly createdAt: FieldRef<"StoryImage", 'DateTime'>
    readonly updatedAt: FieldRef<"StoryImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryImage findUnique
   */
  export type StoryImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * Filter, which StoryImage to fetch.
     */
    where: StoryImageWhereUniqueInput
  }

  /**
   * StoryImage findUniqueOrThrow
   */
  export type StoryImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * Filter, which StoryImage to fetch.
     */
    where: StoryImageWhereUniqueInput
  }

  /**
   * StoryImage findFirst
   */
  export type StoryImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * Filter, which StoryImage to fetch.
     */
    where?: StoryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryImages to fetch.
     */
    orderBy?: StoryImageOrderByWithRelationInput | StoryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryImages.
     */
    cursor?: StoryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryImages.
     */
    distinct?: StoryImageScalarFieldEnum | StoryImageScalarFieldEnum[]
  }

  /**
   * StoryImage findFirstOrThrow
   */
  export type StoryImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * Filter, which StoryImage to fetch.
     */
    where?: StoryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryImages to fetch.
     */
    orderBy?: StoryImageOrderByWithRelationInput | StoryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryImages.
     */
    cursor?: StoryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryImages.
     */
    distinct?: StoryImageScalarFieldEnum | StoryImageScalarFieldEnum[]
  }

  /**
   * StoryImage findMany
   */
  export type StoryImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * Filter, which StoryImages to fetch.
     */
    where?: StoryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryImages to fetch.
     */
    orderBy?: StoryImageOrderByWithRelationInput | StoryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryImages.
     */
    cursor?: StoryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryImages.
     */
    skip?: number
    distinct?: StoryImageScalarFieldEnum | StoryImageScalarFieldEnum[]
  }

  /**
   * StoryImage create
   */
  export type StoryImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryImage.
     */
    data: XOR<StoryImageCreateInput, StoryImageUncheckedCreateInput>
  }

  /**
   * StoryImage createMany
   */
  export type StoryImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryImages.
     */
    data: StoryImageCreateManyInput | StoryImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryImage createManyAndReturn
   */
  export type StoryImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * The data used to create many StoryImages.
     */
    data: StoryImageCreateManyInput | StoryImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryImage update
   */
  export type StoryImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryImage.
     */
    data: XOR<StoryImageUpdateInput, StoryImageUncheckedUpdateInput>
    /**
     * Choose, which StoryImage to update.
     */
    where: StoryImageWhereUniqueInput
  }

  /**
   * StoryImage updateMany
   */
  export type StoryImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryImages.
     */
    data: XOR<StoryImageUpdateManyMutationInput, StoryImageUncheckedUpdateManyInput>
    /**
     * Filter which StoryImages to update
     */
    where?: StoryImageWhereInput
    /**
     * Limit how many StoryImages to update.
     */
    limit?: number
  }

  /**
   * StoryImage updateManyAndReturn
   */
  export type StoryImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * The data used to update StoryImages.
     */
    data: XOR<StoryImageUpdateManyMutationInput, StoryImageUncheckedUpdateManyInput>
    /**
     * Filter which StoryImages to update
     */
    where?: StoryImageWhereInput
    /**
     * Limit how many StoryImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryImage upsert
   */
  export type StoryImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryImage to update in case it exists.
     */
    where: StoryImageWhereUniqueInput
    /**
     * In case the StoryImage found by the `where` argument doesn't exist, create a new StoryImage with this data.
     */
    create: XOR<StoryImageCreateInput, StoryImageUncheckedCreateInput>
    /**
     * In case the StoryImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryImageUpdateInput, StoryImageUncheckedUpdateInput>
  }

  /**
   * StoryImage delete
   */
  export type StoryImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
    /**
     * Filter which StoryImage to delete.
     */
    where: StoryImageWhereUniqueInput
  }

  /**
   * StoryImage deleteMany
   */
  export type StoryImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryImages to delete
     */
    where?: StoryImageWhereInput
    /**
     * Limit how many StoryImages to delete.
     */
    limit?: number
  }

  /**
   * StoryImage without action
   */
  export type StoryImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryImage
     */
    select?: StoryImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryImage
     */
    omit?: StoryImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryImageInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
    rating: number | null
    reviewsCount: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
    rating: number | null
    reviewsCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    avatar: string | null
    points: number | null
    role: $Enums.UserRole | null
    rating: number | null
    reviewsCount: number | null
    isActive: boolean | null
    cityId: string | null
    pushToken: string | null
    referralCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    avatar: string | null
    points: number | null
    role: $Enums.UserRole | null
    rating: number | null
    reviewsCount: number | null
    isActive: boolean | null
    cityId: string | null
    pushToken: string | null
    referralCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phone: number
    firstName: number
    lastName: number
    email: number
    avatar: number
    points: number
    role: number
    rating: number
    reviewsCount: number
    isActive: number
    cityId: number
    pushToken: number
    referralCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
    rating?: true
    reviewsCount?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
    rating?: true
    reviewsCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    phone?: true
    firstName?: true
    lastName?: true
    email?: true
    avatar?: true
    points?: true
    role?: true
    rating?: true
    reviewsCount?: true
    isActive?: true
    cityId?: true
    pushToken?: true
    referralCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phone?: true
    firstName?: true
    lastName?: true
    email?: true
    avatar?: true
    points?: true
    role?: true
    rating?: true
    reviewsCount?: true
    isActive?: true
    cityId?: true
    pushToken?: true
    referralCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phone?: true
    firstName?: true
    lastName?: true
    email?: true
    avatar?: true
    points?: true
    role?: true
    rating?: true
    reviewsCount?: true
    isActive?: true
    cityId?: true
    pushToken?: true
    referralCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    phone: string
    firstName: string | null
    lastName: string | null
    email: string | null
    avatar: string | null
    points: number
    role: $Enums.UserRole
    rating: number | null
    reviewsCount: number | null
    isActive: boolean | null
    cityId: string | null
    pushToken: string | null
    referralCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    avatar?: boolean
    points?: boolean
    role?: boolean
    rating?: boolean
    reviewsCount?: boolean
    isActive?: boolean
    cityId?: boolean
    pushToken?: boolean
    referralCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
    ordersAsClient?: boolean | User$ordersAsClientArgs<ExtArgs>
    ordersAsMaster?: boolean | User$ordersAsMasterArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referred?: boolean | User$referredArgs<ExtArgs>
    masterApplication?: boolean | User$masterApplicationArgs<ExtArgs>
    processedApplications?: boolean | User$processedApplicationsArgs<ExtArgs>
    promoCodeUsages?: boolean | User$promoCodeUsagesArgs<ExtArgs>
    chatsAsUser?: boolean | User$chatsAsUserArgs<ExtArgs>
    chatsAsManager?: boolean | User$chatsAsManagerArgs<ExtArgs>
    bugReports?: boolean | User$bugReportsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    avatar?: boolean
    points?: boolean
    role?: boolean
    rating?: boolean
    reviewsCount?: boolean
    isActive?: boolean
    cityId?: boolean
    pushToken?: boolean
    referralCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    avatar?: boolean
    points?: boolean
    role?: boolean
    rating?: boolean
    reviewsCount?: boolean
    isActive?: boolean
    cityId?: boolean
    pushToken?: boolean
    referralCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    avatar?: boolean
    points?: boolean
    role?: boolean
    rating?: boolean
    reviewsCount?: boolean
    isActive?: boolean
    cityId?: boolean
    pushToken?: boolean
    referralCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "firstName" | "lastName" | "email" | "avatar" | "points" | "role" | "rating" | "reviewsCount" | "isActive" | "cityId" | "pushToken" | "referralCode" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
    ordersAsClient?: boolean | User$ordersAsClientArgs<ExtArgs>
    ordersAsMaster?: boolean | User$ordersAsMasterArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referred?: boolean | User$referredArgs<ExtArgs>
    masterApplication?: boolean | User$masterApplicationArgs<ExtArgs>
    processedApplications?: boolean | User$processedApplicationsArgs<ExtArgs>
    promoCodeUsages?: boolean | User$promoCodeUsagesArgs<ExtArgs>
    chatsAsUser?: boolean | User$chatsAsUserArgs<ExtArgs>
    chatsAsManager?: boolean | User$chatsAsManagerArgs<ExtArgs>
    bugReports?: boolean | User$bugReportsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      city: Prisma.$CityPayload<ExtArgs> | null
      ordersAsClient: Prisma.$OrderPayload<ExtArgs>[]
      ordersAsMaster: Prisma.$OrderPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      referred: Prisma.$ReferralPayload<ExtArgs> | null
      masterApplication: Prisma.$MasterApplicationPayload<ExtArgs> | null
      processedApplications: Prisma.$MasterApplicationPayload<ExtArgs>[]
      promoCodeUsages: Prisma.$PromoCodeUsagePayload<ExtArgs>[]
      chatsAsUser: Prisma.$ChatPayload<ExtArgs>[]
      chatsAsManager: Prisma.$ChatPayload<ExtArgs>[]
      bugReports: Prisma.$BugReportPayload<ExtArgs>[]
      reviewsGiven: Prisma.$ReviewPayload<ExtArgs>[]
      reviewsReceived: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      firstName: string | null
      lastName: string | null
      email: string | null
      avatar: string | null
      points: number
      role: $Enums.UserRole
      rating: number | null
      reviewsCount: number | null
      isActive: boolean | null
      cityId: string | null
      pushToken: string | null
      referralCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends User$cityArgs<ExtArgs> = {}>(args?: Subset<T, User$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ordersAsClient<T extends User$ordersAsClientArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersAsClientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersAsMaster<T extends User$ordersAsMasterArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersAsMasterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referred<T extends User$referredArgs<ExtArgs> = {}>(args?: Subset<T, User$referredArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    masterApplication<T extends User$masterApplicationArgs<ExtArgs> = {}>(args?: Subset<T, User$masterApplicationArgs<ExtArgs>>): Prisma__MasterApplicationClient<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processedApplications<T extends User$processedApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$processedApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoCodeUsages<T extends User$promoCodeUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$promoCodeUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatsAsUser<T extends User$chatsAsUserArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsAsUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatsAsManager<T extends User$chatsAsManagerArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsAsManagerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bugReports<T extends User$bugReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$bugReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BugReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsGiven<T extends User$reviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsReceived<T extends User$reviewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly points: FieldRef<"User", 'Int'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly rating: FieldRef<"User", 'Float'>
    readonly reviewsCount: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly pushToken: FieldRef<"User", 'String'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.city
   */
  export type User$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * User.ordersAsClient
   */
  export type User$ordersAsClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.ordersAsMaster
   */
  export type User$ordersAsMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referred
   */
  export type User$referredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * User.masterApplication
   */
  export type User$masterApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    where?: MasterApplicationWhereInput
  }

  /**
   * User.processedApplications
   */
  export type User$processedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterApplication
     */
    select?: MasterApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterApplication
     */
    omit?: MasterApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterApplicationInclude<ExtArgs> | null
    where?: MasterApplicationWhereInput
    orderBy?: MasterApplicationOrderByWithRelationInput | MasterApplicationOrderByWithRelationInput[]
    cursor?: MasterApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MasterApplicationScalarFieldEnum | MasterApplicationScalarFieldEnum[]
  }

  /**
   * User.promoCodeUsages
   */
  export type User$promoCodeUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    cursor?: PromoCodeUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * User.chatsAsUser
   */
  export type User$chatsAsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.chatsAsManager
   */
  export type User$chatsAsManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.bugReports
   */
  export type User$bugReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BugReport
     */
    select?: BugReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BugReport
     */
    omit?: BugReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BugReportInclude<ExtArgs> | null
    where?: BugReportWhereInput
    orderBy?: BugReportOrderByWithRelationInput | BugReportOrderByWithRelationInput[]
    cursor?: BugReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BugReportScalarFieldEnum | BugReportScalarFieldEnum[]
  }

  /**
   * User.reviewsGiven
   */
  export type User$reviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewsReceived
   */
  export type User$reviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuthCodeScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    code: 'code',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type AuthCodeScalarFieldEnum = (typeof AuthCodeScalarFieldEnum)[keyof typeof AuthCodeScalarFieldEnum]


  export const BugReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    category: 'category',
    priority: 'priority',
    status: 'status',
    description: 'description',
    steps: 'steps',
    email: 'email',
    logFileUrl: 'logFileUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type BugReportScalarFieldEnum = (typeof BugReportScalarFieldEnum)[keyof typeof BugReportScalarFieldEnum]


  export const BugReportImageScalarFieldEnum: {
    id: 'id',
    bugReportId: 'bugReportId',
    imageUrl: 'imageUrl',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type BugReportImageScalarFieldEnum = (typeof BugReportImageScalarFieldEnum)[keyof typeof BugReportImageScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    managerId: 'managerId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    closedAt: 'closedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    text: 'text',
    isFromUser: 'isFromUser',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    region: 'region',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const HomePageSectionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    icon: 'icon',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HomePageSectionScalarFieldEnum = (typeof HomePageSectionScalarFieldEnum)[keyof typeof HomePageSectionScalarFieldEnum]


  export const HomePageSectionItemScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    categoryId: 'categoryId',
    serviceId: 'serviceId',
    imageUrl: 'imageUrl',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HomePageSectionItemScalarFieldEnum = (typeof HomePageSectionItemScalarFieldEnum)[keyof typeof HomePageSectionItemScalarFieldEnum]


  export const MasterApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    experience: 'experience',
    specialties: 'specialties',
    description: 'description',
    status: 'status',
    processedAt: 'processedAt',
    processedById: 'processedById',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MasterApplicationScalarFieldEnum = (typeof MasterApplicationScalarFieldEnum)[keyof typeof MasterApplicationScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    clientId: 'clientId',
    masterId: 'masterId',
    status: 'status',
    recipient: 'recipient',
    clientName: 'clientName',
    clientPhone: 'clientPhone',
    city: 'city',
    address: 'address',
    apartment: 'apartment',
    isPrivateHouse: 'isPrivateHouse',
    urgency: 'urgency',
    scheduledDate: 'scheduledDate',
    scheduledTime: 'scheduledTime',
    totalPrice: 'totalPrice',
    workDescription: 'workDescription',
    warranty: 'warranty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderStepScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    title: 'title',
    description: 'description',
    status: 'status',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type OrderStepScalarFieldEnum = (typeof OrderStepScalarFieldEnum)[keyof typeof OrderStepScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    points: 'points',
    discount: 'discount',
    discountType: 'discountType',
    minAmount: 'minAmount',
    maxDiscount: 'maxDiscount',
    expiresAt: 'expiresAt',
    usageLimit: 'usageLimit',
    usedCount: 'usedCount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const PromoCodeUsageScalarFieldEnum: {
    id: 'id',
    promoCodeId: 'promoCodeId',
    userId: 'userId',
    points: 'points',
    createdAt: 'createdAt'
  };

  export type PromoCodeUsageScalarFieldEnum = (typeof PromoCodeUsageScalarFieldEnum)[keyof typeof PromoCodeUsageScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    referredId: 'referredId',
    points: 'points',
    status: 'status',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    serviceId: 'serviceId',
    authorId: 'authorId',
    masterId: 'masterId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    price: 'price',
    image: 'image',
    time: 'time',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceCityScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    cityId: 'cityId',
    createdAt: 'createdAt'
  };

  export type ServiceCityScalarFieldEnum = (typeof ServiceCityScalarFieldEnum)[keyof typeof ServiceCityScalarFieldEnum]


  export const StoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryScalarFieldEnum = (typeof StoryScalarFieldEnum)[keyof typeof StoryScalarFieldEnum]


  export const StoryImageScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    image: 'image',
    title: 'title',
    duration: 'duration',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoryImageScalarFieldEnum = (typeof StoryImageScalarFieldEnum)[keyof typeof StoryImageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    avatar: 'avatar',
    points: 'points',
    role: 'role',
    rating: 'rating',
    reviewsCount: 'reviewsCount',
    isActive: 'isActive',
    cityId: 'cityId',
    pushToken: 'pushToken',
    referralCode: 'referralCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BugReportCategory'
   */
  export type EnumBugReportCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BugReportCategory'>
    


  /**
   * Reference to a field of type 'BugReportCategory[]'
   */
  export type ListEnumBugReportCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BugReportCategory[]'>
    


  /**
   * Reference to a field of type 'BugReportPriority'
   */
  export type EnumBugReportPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BugReportPriority'>
    


  /**
   * Reference to a field of type 'BugReportPriority[]'
   */
  export type ListEnumBugReportPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BugReportPriority[]'>
    


  /**
   * Reference to a field of type 'BugReportStatus'
   */
  export type EnumBugReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BugReportStatus'>
    


  /**
   * Reference to a field of type 'BugReportStatus[]'
   */
  export type ListEnumBugReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BugReportStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ChatStatus'
   */
  export type EnumChatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatStatus'>
    


  /**
   * Reference to a field of type 'ChatStatus[]'
   */
  export type ListEnumChatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatStatus[]'>
    


  /**
   * Reference to a field of type 'HomePageSectionType'
   */
  export type EnumHomePageSectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HomePageSectionType'>
    


  /**
   * Reference to a field of type 'HomePageSectionType[]'
   */
  export type ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HomePageSectionType[]'>
    


  /**
   * Reference to a field of type 'MasterApplicationStatus'
   */
  export type EnumMasterApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MasterApplicationStatus'>
    


  /**
   * Reference to a field of type 'MasterApplicationStatus[]'
   */
  export type ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MasterApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'OrderUrgency'
   */
  export type EnumOrderUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderUrgency'>
    


  /**
   * Reference to a field of type 'OrderUrgency[]'
   */
  export type ListEnumOrderUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderUrgency[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StepStatus'
   */
  export type EnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus'>
    


  /**
   * Reference to a field of type 'StepStatus[]'
   */
  export type ListEnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus[]'>
    


  /**
   * Reference to a field of type 'ReferralStatus'
   */
  export type EnumReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralStatus'>
    


  /**
   * Reference to a field of type 'ReferralStatus[]'
   */
  export type ListEnumReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    
  /**
   * Deep Input Types
   */


  export type AuthCodeWhereInput = {
    AND?: AuthCodeWhereInput | AuthCodeWhereInput[]
    OR?: AuthCodeWhereInput[]
    NOT?: AuthCodeWhereInput | AuthCodeWhereInput[]
    id?: StringFilter<"AuthCode"> | string
    phone?: StringFilter<"AuthCode"> | string
    code?: StringFilter<"AuthCode"> | string
    expiresAt?: DateTimeFilter<"AuthCode"> | Date | string
    used?: BoolFilter<"AuthCode"> | boolean
    createdAt?: DateTimeFilter<"AuthCode"> | Date | string
  }

  export type AuthCodeOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type AuthCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuthCodeWhereInput | AuthCodeWhereInput[]
    OR?: AuthCodeWhereInput[]
    NOT?: AuthCodeWhereInput | AuthCodeWhereInput[]
    phone?: StringFilter<"AuthCode"> | string
    code?: StringFilter<"AuthCode"> | string
    expiresAt?: DateTimeFilter<"AuthCode"> | Date | string
    used?: BoolFilter<"AuthCode"> | boolean
    createdAt?: DateTimeFilter<"AuthCode"> | Date | string
  }, "id">

  export type AuthCodeOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: AuthCodeCountOrderByAggregateInput
    _max?: AuthCodeMaxOrderByAggregateInput
    _min?: AuthCodeMinOrderByAggregateInput
  }

  export type AuthCodeScalarWhereWithAggregatesInput = {
    AND?: AuthCodeScalarWhereWithAggregatesInput | AuthCodeScalarWhereWithAggregatesInput[]
    OR?: AuthCodeScalarWhereWithAggregatesInput[]
    NOT?: AuthCodeScalarWhereWithAggregatesInput | AuthCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthCode"> | string
    phone?: StringWithAggregatesFilter<"AuthCode"> | string
    code?: StringWithAggregatesFilter<"AuthCode"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"AuthCode"> | Date | string
    used?: BoolWithAggregatesFilter<"AuthCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AuthCode"> | Date | string
  }

  export type BugReportWhereInput = {
    AND?: BugReportWhereInput | BugReportWhereInput[]
    OR?: BugReportWhereInput[]
    NOT?: BugReportWhereInput | BugReportWhereInput[]
    id?: StringFilter<"BugReport"> | string
    userId?: StringNullableFilter<"BugReport"> | string | null
    category?: EnumBugReportCategoryFilter<"BugReport"> | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFilter<"BugReport"> | $Enums.BugReportPriority
    status?: EnumBugReportStatusFilter<"BugReport"> | $Enums.BugReportStatus
    description?: StringFilter<"BugReport"> | string
    steps?: StringNullableFilter<"BugReport"> | string | null
    email?: StringFilter<"BugReport"> | string
    logFileUrl?: StringNullableFilter<"BugReport"> | string | null
    createdAt?: DateTimeFilter<"BugReport"> | Date | string
    updatedAt?: DateTimeFilter<"BugReport"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"BugReport"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    images?: BugReportImageListRelationFilter
  }

  export type BugReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    description?: SortOrder
    steps?: SortOrderInput | SortOrder
    email?: SortOrder
    logFileUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    images?: BugReportImageOrderByRelationAggregateInput
  }

  export type BugReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BugReportWhereInput | BugReportWhereInput[]
    OR?: BugReportWhereInput[]
    NOT?: BugReportWhereInput | BugReportWhereInput[]
    userId?: StringNullableFilter<"BugReport"> | string | null
    category?: EnumBugReportCategoryFilter<"BugReport"> | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFilter<"BugReport"> | $Enums.BugReportPriority
    status?: EnumBugReportStatusFilter<"BugReport"> | $Enums.BugReportStatus
    description?: StringFilter<"BugReport"> | string
    steps?: StringNullableFilter<"BugReport"> | string | null
    email?: StringFilter<"BugReport"> | string
    logFileUrl?: StringNullableFilter<"BugReport"> | string | null
    createdAt?: DateTimeFilter<"BugReport"> | Date | string
    updatedAt?: DateTimeFilter<"BugReport"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"BugReport"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    images?: BugReportImageListRelationFilter
  }, "id">

  export type BugReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    description?: SortOrder
    steps?: SortOrderInput | SortOrder
    email?: SortOrder
    logFileUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: BugReportCountOrderByAggregateInput
    _max?: BugReportMaxOrderByAggregateInput
    _min?: BugReportMinOrderByAggregateInput
  }

  export type BugReportScalarWhereWithAggregatesInput = {
    AND?: BugReportScalarWhereWithAggregatesInput | BugReportScalarWhereWithAggregatesInput[]
    OR?: BugReportScalarWhereWithAggregatesInput[]
    NOT?: BugReportScalarWhereWithAggregatesInput | BugReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BugReport"> | string
    userId?: StringNullableWithAggregatesFilter<"BugReport"> | string | null
    category?: EnumBugReportCategoryWithAggregatesFilter<"BugReport"> | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityWithAggregatesFilter<"BugReport"> | $Enums.BugReportPriority
    status?: EnumBugReportStatusWithAggregatesFilter<"BugReport"> | $Enums.BugReportStatus
    description?: StringWithAggregatesFilter<"BugReport"> | string
    steps?: StringNullableWithAggregatesFilter<"BugReport"> | string | null
    email?: StringWithAggregatesFilter<"BugReport"> | string
    logFileUrl?: StringNullableWithAggregatesFilter<"BugReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BugReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BugReport"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"BugReport"> | Date | string | null
  }

  export type BugReportImageWhereInput = {
    AND?: BugReportImageWhereInput | BugReportImageWhereInput[]
    OR?: BugReportImageWhereInput[]
    NOT?: BugReportImageWhereInput | BugReportImageWhereInput[]
    id?: StringFilter<"BugReportImage"> | string
    bugReportId?: StringFilter<"BugReportImage"> | string
    imageUrl?: StringFilter<"BugReportImage"> | string
    order?: IntFilter<"BugReportImage"> | number
    createdAt?: DateTimeFilter<"BugReportImage"> | Date | string
    bugReport?: XOR<BugReportScalarRelationFilter, BugReportWhereInput>
  }

  export type BugReportImageOrderByWithRelationInput = {
    id?: SortOrder
    bugReportId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    bugReport?: BugReportOrderByWithRelationInput
  }

  export type BugReportImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BugReportImageWhereInput | BugReportImageWhereInput[]
    OR?: BugReportImageWhereInput[]
    NOT?: BugReportImageWhereInput | BugReportImageWhereInput[]
    bugReportId?: StringFilter<"BugReportImage"> | string
    imageUrl?: StringFilter<"BugReportImage"> | string
    order?: IntFilter<"BugReportImage"> | number
    createdAt?: DateTimeFilter<"BugReportImage"> | Date | string
    bugReport?: XOR<BugReportScalarRelationFilter, BugReportWhereInput>
  }, "id">

  export type BugReportImageOrderByWithAggregationInput = {
    id?: SortOrder
    bugReportId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: BugReportImageCountOrderByAggregateInput
    _avg?: BugReportImageAvgOrderByAggregateInput
    _max?: BugReportImageMaxOrderByAggregateInput
    _min?: BugReportImageMinOrderByAggregateInput
    _sum?: BugReportImageSumOrderByAggregateInput
  }

  export type BugReportImageScalarWhereWithAggregatesInput = {
    AND?: BugReportImageScalarWhereWithAggregatesInput | BugReportImageScalarWhereWithAggregatesInput[]
    OR?: BugReportImageScalarWhereWithAggregatesInput[]
    NOT?: BugReportImageScalarWhereWithAggregatesInput | BugReportImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BugReportImage"> | string
    bugReportId?: StringWithAggregatesFilter<"BugReportImage"> | string
    imageUrl?: StringWithAggregatesFilter<"BugReportImage"> | string
    order?: IntWithAggregatesFilter<"BugReportImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BugReportImage"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
    managerId?: StringNullableFilter<"Chat"> | string | null
    status?: EnumChatStatusFilter<"Chat"> | $Enums.ChatStatus
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: ChatMessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    managerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    userId?: StringFilter<"Chat"> | string
    managerId?: StringNullableFilter<"Chat"> | string | null
    status?: EnumChatStatusFilter<"Chat"> | $Enums.ChatStatus
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    managerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    userId?: StringWithAggregatesFilter<"Chat"> | string
    managerId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    status?: EnumChatStatusWithAggregatesFilter<"Chat"> | $Enums.ChatStatus
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    chatId?: StringFilter<"ChatMessage"> | string
    text?: StringFilter<"ChatMessage"> | string
    isFromUser?: BoolFilter<"ChatMessage"> | boolean
    readAt?: DateTimeNullableFilter<"ChatMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    text?: SortOrder
    isFromUser?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    chatId?: StringFilter<"ChatMessage"> | string
    text?: StringFilter<"ChatMessage"> | string
    isFromUser?: BoolFilter<"ChatMessage"> | boolean
    readAt?: DateTimeNullableFilter<"ChatMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    text?: SortOrder
    isFromUser?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    chatId?: StringWithAggregatesFilter<"ChatMessage"> | string
    text?: StringWithAggregatesFilter<"ChatMessage"> | string
    isFromUser?: BoolWithAggregatesFilter<"ChatMessage"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"ChatMessage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    region?: StringNullableFilter<"City"> | string | null
    isActive?: BoolFilter<"City"> | boolean
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    users?: UserListRelationFilter
    services?: ServiceCityListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    services?: ServiceCityOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    region?: StringNullableFilter<"City"> | string | null
    isActive?: BoolFilter<"City"> | boolean
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    users?: UserListRelationFilter
    services?: ServiceCityListRelationFilter
  }, "id" | "name">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    region?: StringNullableWithAggregatesFilter<"City"> | string | null
    isActive?: BoolWithAggregatesFilter<"City"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type HomePageSectionWhereInput = {
    AND?: HomePageSectionWhereInput | HomePageSectionWhereInput[]
    OR?: HomePageSectionWhereInput[]
    NOT?: HomePageSectionWhereInput | HomePageSectionWhereInput[]
    id?: StringFilter<"HomePageSection"> | string
    type?: EnumHomePageSectionTypeFilter<"HomePageSection"> | $Enums.HomePageSectionType
    title?: StringNullableFilter<"HomePageSection"> | string | null
    icon?: StringNullableFilter<"HomePageSection"> | string | null
    isActive?: BoolFilter<"HomePageSection"> | boolean
    order?: IntFilter<"HomePageSection"> | number
    createdAt?: DateTimeFilter<"HomePageSection"> | Date | string
    updatedAt?: DateTimeFilter<"HomePageSection"> | Date | string
    items?: HomePageSectionItemListRelationFilter
  }

  export type HomePageSectionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: HomePageSectionItemOrderByRelationAggregateInput
  }

  export type HomePageSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomePageSectionWhereInput | HomePageSectionWhereInput[]
    OR?: HomePageSectionWhereInput[]
    NOT?: HomePageSectionWhereInput | HomePageSectionWhereInput[]
    type?: EnumHomePageSectionTypeFilter<"HomePageSection"> | $Enums.HomePageSectionType
    title?: StringNullableFilter<"HomePageSection"> | string | null
    icon?: StringNullableFilter<"HomePageSection"> | string | null
    isActive?: BoolFilter<"HomePageSection"> | boolean
    order?: IntFilter<"HomePageSection"> | number
    createdAt?: DateTimeFilter<"HomePageSection"> | Date | string
    updatedAt?: DateTimeFilter<"HomePageSection"> | Date | string
    items?: HomePageSectionItemListRelationFilter
  }, "id">

  export type HomePageSectionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HomePageSectionCountOrderByAggregateInput
    _avg?: HomePageSectionAvgOrderByAggregateInput
    _max?: HomePageSectionMaxOrderByAggregateInput
    _min?: HomePageSectionMinOrderByAggregateInput
    _sum?: HomePageSectionSumOrderByAggregateInput
  }

  export type HomePageSectionScalarWhereWithAggregatesInput = {
    AND?: HomePageSectionScalarWhereWithAggregatesInput | HomePageSectionScalarWhereWithAggregatesInput[]
    OR?: HomePageSectionScalarWhereWithAggregatesInput[]
    NOT?: HomePageSectionScalarWhereWithAggregatesInput | HomePageSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomePageSection"> | string
    type?: EnumHomePageSectionTypeWithAggregatesFilter<"HomePageSection"> | $Enums.HomePageSectionType
    title?: StringNullableWithAggregatesFilter<"HomePageSection"> | string | null
    icon?: StringNullableWithAggregatesFilter<"HomePageSection"> | string | null
    isActive?: BoolWithAggregatesFilter<"HomePageSection"> | boolean
    order?: IntWithAggregatesFilter<"HomePageSection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"HomePageSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HomePageSection"> | Date | string
  }

  export type HomePageSectionItemWhereInput = {
    AND?: HomePageSectionItemWhereInput | HomePageSectionItemWhereInput[]
    OR?: HomePageSectionItemWhereInput[]
    NOT?: HomePageSectionItemWhereInput | HomePageSectionItemWhereInput[]
    id?: StringFilter<"HomePageSectionItem"> | string
    sectionId?: StringFilter<"HomePageSectionItem"> | string
    categoryId?: StringNullableFilter<"HomePageSectionItem"> | string | null
    serviceId?: StringNullableFilter<"HomePageSectionItem"> | string | null
    imageUrl?: StringNullableFilter<"HomePageSectionItem"> | string | null
    order?: IntFilter<"HomePageSectionItem"> | number
    createdAt?: DateTimeFilter<"HomePageSectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"HomePageSectionItem"> | Date | string
    section?: XOR<HomePageSectionScalarRelationFilter, HomePageSectionWhereInput>
    category?: XOR<ServiceCategoryNullableScalarRelationFilter, ServiceCategoryWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type HomePageSectionItemOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: HomePageSectionOrderByWithRelationInput
    category?: ServiceCategoryOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type HomePageSectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomePageSectionItemWhereInput | HomePageSectionItemWhereInput[]
    OR?: HomePageSectionItemWhereInput[]
    NOT?: HomePageSectionItemWhereInput | HomePageSectionItemWhereInput[]
    sectionId?: StringFilter<"HomePageSectionItem"> | string
    categoryId?: StringNullableFilter<"HomePageSectionItem"> | string | null
    serviceId?: StringNullableFilter<"HomePageSectionItem"> | string | null
    imageUrl?: StringNullableFilter<"HomePageSectionItem"> | string | null
    order?: IntFilter<"HomePageSectionItem"> | number
    createdAt?: DateTimeFilter<"HomePageSectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"HomePageSectionItem"> | Date | string
    section?: XOR<HomePageSectionScalarRelationFilter, HomePageSectionWhereInput>
    category?: XOR<ServiceCategoryNullableScalarRelationFilter, ServiceCategoryWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type HomePageSectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HomePageSectionItemCountOrderByAggregateInput
    _avg?: HomePageSectionItemAvgOrderByAggregateInput
    _max?: HomePageSectionItemMaxOrderByAggregateInput
    _min?: HomePageSectionItemMinOrderByAggregateInput
    _sum?: HomePageSectionItemSumOrderByAggregateInput
  }

  export type HomePageSectionItemScalarWhereWithAggregatesInput = {
    AND?: HomePageSectionItemScalarWhereWithAggregatesInput | HomePageSectionItemScalarWhereWithAggregatesInput[]
    OR?: HomePageSectionItemScalarWhereWithAggregatesInput[]
    NOT?: HomePageSectionItemScalarWhereWithAggregatesInput | HomePageSectionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomePageSectionItem"> | string
    sectionId?: StringWithAggregatesFilter<"HomePageSectionItem"> | string
    categoryId?: StringNullableWithAggregatesFilter<"HomePageSectionItem"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"HomePageSectionItem"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"HomePageSectionItem"> | string | null
    order?: IntWithAggregatesFilter<"HomePageSectionItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"HomePageSectionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HomePageSectionItem"> | Date | string
  }

  export type MasterApplicationWhereInput = {
    AND?: MasterApplicationWhereInput | MasterApplicationWhereInput[]
    OR?: MasterApplicationWhereInput[]
    NOT?: MasterApplicationWhereInput | MasterApplicationWhereInput[]
    id?: StringFilter<"MasterApplication"> | string
    userId?: StringFilter<"MasterApplication"> | string
    name?: StringFilter<"MasterApplication"> | string
    phone?: StringFilter<"MasterApplication"> | string
    email?: StringNullableFilter<"MasterApplication"> | string | null
    experience?: StringNullableFilter<"MasterApplication"> | string | null
    specialties?: StringNullableListFilter<"MasterApplication">
    description?: StringNullableFilter<"MasterApplication"> | string | null
    status?: EnumMasterApplicationStatusFilter<"MasterApplication"> | $Enums.MasterApplicationStatus
    processedAt?: DateTimeNullableFilter<"MasterApplication"> | Date | string | null
    processedById?: StringNullableFilter<"MasterApplication"> | string | null
    rejectionReason?: StringNullableFilter<"MasterApplication"> | string | null
    createdAt?: DateTimeFilter<"MasterApplication"> | Date | string
    updatedAt?: DateTimeFilter<"MasterApplication"> | Date | string
    processedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MasterApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    specialties?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedBy?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MasterApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: MasterApplicationWhereInput | MasterApplicationWhereInput[]
    OR?: MasterApplicationWhereInput[]
    NOT?: MasterApplicationWhereInput | MasterApplicationWhereInput[]
    name?: StringFilter<"MasterApplication"> | string
    phone?: StringFilter<"MasterApplication"> | string
    email?: StringNullableFilter<"MasterApplication"> | string | null
    experience?: StringNullableFilter<"MasterApplication"> | string | null
    specialties?: StringNullableListFilter<"MasterApplication">
    description?: StringNullableFilter<"MasterApplication"> | string | null
    status?: EnumMasterApplicationStatusFilter<"MasterApplication"> | $Enums.MasterApplicationStatus
    processedAt?: DateTimeNullableFilter<"MasterApplication"> | Date | string | null
    processedById?: StringNullableFilter<"MasterApplication"> | string | null
    rejectionReason?: StringNullableFilter<"MasterApplication"> | string | null
    createdAt?: DateTimeFilter<"MasterApplication"> | Date | string
    updatedAt?: DateTimeFilter<"MasterApplication"> | Date | string
    processedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type MasterApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    specialties?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MasterApplicationCountOrderByAggregateInput
    _max?: MasterApplicationMaxOrderByAggregateInput
    _min?: MasterApplicationMinOrderByAggregateInput
  }

  export type MasterApplicationScalarWhereWithAggregatesInput = {
    AND?: MasterApplicationScalarWhereWithAggregatesInput | MasterApplicationScalarWhereWithAggregatesInput[]
    OR?: MasterApplicationScalarWhereWithAggregatesInput[]
    NOT?: MasterApplicationScalarWhereWithAggregatesInput | MasterApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MasterApplication"> | string
    userId?: StringWithAggregatesFilter<"MasterApplication"> | string
    name?: StringWithAggregatesFilter<"MasterApplication"> | string
    phone?: StringWithAggregatesFilter<"MasterApplication"> | string
    email?: StringNullableWithAggregatesFilter<"MasterApplication"> | string | null
    experience?: StringNullableWithAggregatesFilter<"MasterApplication"> | string | null
    specialties?: StringNullableListFilter<"MasterApplication">
    description?: StringNullableWithAggregatesFilter<"MasterApplication"> | string | null
    status?: EnumMasterApplicationStatusWithAggregatesFilter<"MasterApplication"> | $Enums.MasterApplicationStatus
    processedAt?: DateTimeNullableWithAggregatesFilter<"MasterApplication"> | Date | string | null
    processedById?: StringNullableWithAggregatesFilter<"MasterApplication"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"MasterApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MasterApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MasterApplication"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    clientId?: StringNullableFilter<"Order"> | string | null
    masterId?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    recipient?: StringFilter<"Order"> | string
    clientName?: StringFilter<"Order"> | string
    clientPhone?: StringFilter<"Order"> | string
    city?: StringFilter<"Order"> | string
    address?: StringFilter<"Order"> | string
    apartment?: StringNullableFilter<"Order"> | string | null
    isPrivateHouse?: BoolFilter<"Order"> | boolean
    urgency?: EnumOrderUrgencyFilter<"Order"> | $Enums.OrderUrgency
    scheduledDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    scheduledTime?: StringNullableFilter<"Order"> | string | null
    totalPrice?: FloatNullableFilter<"Order"> | number | null
    workDescription?: StringNullableFilter<"Order"> | string | null
    warranty?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    client?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    master?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: OrderItemListRelationFilter
    steps?: OrderStepListRelationFilter
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrderInput | SortOrder
    masterId?: SortOrderInput | SortOrder
    status?: SortOrder
    recipient?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    city?: SortOrder
    address?: SortOrder
    apartment?: SortOrderInput | SortOrder
    isPrivateHouse?: SortOrder
    urgency?: SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    workDescription?: SortOrderInput | SortOrder
    warranty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    client?: UserOrderByWithRelationInput
    master?: UserOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    steps?: OrderStepOrderByRelationAggregateInput
    review?: ReviewOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    clientId?: StringNullableFilter<"Order"> | string | null
    masterId?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    recipient?: StringFilter<"Order"> | string
    clientName?: StringFilter<"Order"> | string
    clientPhone?: StringFilter<"Order"> | string
    city?: StringFilter<"Order"> | string
    address?: StringFilter<"Order"> | string
    apartment?: StringNullableFilter<"Order"> | string | null
    isPrivateHouse?: BoolFilter<"Order"> | boolean
    urgency?: EnumOrderUrgencyFilter<"Order"> | $Enums.OrderUrgency
    scheduledDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    scheduledTime?: StringNullableFilter<"Order"> | string | null
    totalPrice?: FloatNullableFilter<"Order"> | number | null
    workDescription?: StringNullableFilter<"Order"> | string | null
    warranty?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    client?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    master?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: OrderItemListRelationFilter
    steps?: OrderStepListRelationFilter
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrderInput | SortOrder
    masterId?: SortOrderInput | SortOrder
    status?: SortOrder
    recipient?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    city?: SortOrder
    address?: SortOrder
    apartment?: SortOrderInput | SortOrder
    isPrivateHouse?: SortOrder
    urgency?: SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    workDescription?: SortOrderInput | SortOrder
    warranty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    clientId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    masterId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    recipient?: StringWithAggregatesFilter<"Order"> | string
    clientName?: StringWithAggregatesFilter<"Order"> | string
    clientPhone?: StringWithAggregatesFilter<"Order"> | string
    city?: StringWithAggregatesFilter<"Order"> | string
    address?: StringWithAggregatesFilter<"Order"> | string
    apartment?: StringNullableWithAggregatesFilter<"Order"> | string | null
    isPrivateHouse?: BoolWithAggregatesFilter<"Order"> | boolean
    urgency?: EnumOrderUrgencyWithAggregatesFilter<"Order"> | $Enums.OrderUrgency
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    scheduledTime?: StringNullableWithAggregatesFilter<"Order"> | string | null
    totalPrice?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    workDescription?: StringNullableWithAggregatesFilter<"Order"> | string | null
    warranty?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    serviceId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type OrderStepWhereInput = {
    AND?: OrderStepWhereInput | OrderStepWhereInput[]
    OR?: OrderStepWhereInput[]
    NOT?: OrderStepWhereInput | OrderStepWhereInput[]
    id?: StringFilter<"OrderStep"> | string
    orderId?: StringFilter<"OrderStep"> | string
    title?: StringFilter<"OrderStep"> | string
    description?: StringNullableFilter<"OrderStep"> | string | null
    status?: EnumStepStatusFilter<"OrderStep"> | $Enums.StepStatus
    completedAt?: DateTimeNullableFilter<"OrderStep"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderStep"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderStepOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderStepWhereInput | OrderStepWhereInput[]
    OR?: OrderStepWhereInput[]
    NOT?: OrderStepWhereInput | OrderStepWhereInput[]
    orderId?: StringFilter<"OrderStep"> | string
    title?: StringFilter<"OrderStep"> | string
    description?: StringNullableFilter<"OrderStep"> | string | null
    status?: EnumStepStatusFilter<"OrderStep"> | $Enums.StepStatus
    completedAt?: DateTimeNullableFilter<"OrderStep"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderStep"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderStepOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderStepCountOrderByAggregateInput
    _max?: OrderStepMaxOrderByAggregateInput
    _min?: OrderStepMinOrderByAggregateInput
  }

  export type OrderStepScalarWhereWithAggregatesInput = {
    AND?: OrderStepScalarWhereWithAggregatesInput | OrderStepScalarWhereWithAggregatesInput[]
    OR?: OrderStepScalarWhereWithAggregatesInput[]
    NOT?: OrderStepScalarWhereWithAggregatesInput | OrderStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderStep"> | string
    orderId?: StringWithAggregatesFilter<"OrderStep"> | string
    title?: StringWithAggregatesFilter<"OrderStep"> | string
    description?: StringNullableWithAggregatesFilter<"OrderStep"> | string | null
    status?: EnumStepStatusWithAggregatesFilter<"OrderStep"> | $Enums.StepStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"OrderStep"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderStep"> | Date | string
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    points?: IntFilter<"PromoCode"> | number
    discount?: FloatNullableFilter<"PromoCode"> | number | null
    discountType?: StringNullableFilter<"PromoCode"> | string | null
    minAmount?: FloatNullableFilter<"PromoCode"> | number | null
    maxDiscount?: FloatNullableFilter<"PromoCode"> | number | null
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
    usages?: PromoCodeUsageListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    discount?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usages?: PromoCodeUsageOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    description?: StringNullableFilter<"PromoCode"> | string | null
    points?: IntFilter<"PromoCode"> | number
    discount?: FloatNullableFilter<"PromoCode"> | number | null
    discountType?: StringNullableFilter<"PromoCode"> | string | null
    minAmount?: FloatNullableFilter<"PromoCode"> | number | null
    maxDiscount?: FloatNullableFilter<"PromoCode"> | number | null
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
    usages?: PromoCodeUsageListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    discount?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    points?: IntWithAggregatesFilter<"PromoCode"> | number
    discount?: FloatNullableWithAggregatesFilter<"PromoCode"> | number | null
    discountType?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    minAmount?: FloatNullableWithAggregatesFilter<"PromoCode"> | number | null
    maxDiscount?: FloatNullableWithAggregatesFilter<"PromoCode"> | number | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"PromoCode"> | number
    isActive?: BoolWithAggregatesFilter<"PromoCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type PromoCodeUsageWhereInput = {
    AND?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    OR?: PromoCodeUsageWhereInput[]
    NOT?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    id?: StringFilter<"PromoCodeUsage"> | string
    promoCodeId?: StringFilter<"PromoCodeUsage"> | string
    userId?: StringFilter<"PromoCodeUsage"> | string
    points?: IntFilter<"PromoCodeUsage"> | number
    createdAt?: DateTimeFilter<"PromoCodeUsage"> | Date | string
    promoCode?: XOR<PromoCodeScalarRelationFilter, PromoCodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PromoCodeUsageOrderByWithRelationInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    promoCode?: PromoCodeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PromoCodeUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promoCodeId_userId?: PromoCodeUsagePromoCodeIdUserIdCompoundUniqueInput
    AND?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    OR?: PromoCodeUsageWhereInput[]
    NOT?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    promoCodeId?: StringFilter<"PromoCodeUsage"> | string
    userId?: StringFilter<"PromoCodeUsage"> | string
    points?: IntFilter<"PromoCodeUsage"> | number
    createdAt?: DateTimeFilter<"PromoCodeUsage"> | Date | string
    promoCode?: XOR<PromoCodeScalarRelationFilter, PromoCodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "promoCodeId_userId">

  export type PromoCodeUsageOrderByWithAggregationInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    _count?: PromoCodeUsageCountOrderByAggregateInput
    _avg?: PromoCodeUsageAvgOrderByAggregateInput
    _max?: PromoCodeUsageMaxOrderByAggregateInput
    _min?: PromoCodeUsageMinOrderByAggregateInput
    _sum?: PromoCodeUsageSumOrderByAggregateInput
  }

  export type PromoCodeUsageScalarWhereWithAggregatesInput = {
    AND?: PromoCodeUsageScalarWhereWithAggregatesInput | PromoCodeUsageScalarWhereWithAggregatesInput[]
    OR?: PromoCodeUsageScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeUsageScalarWhereWithAggregatesInput | PromoCodeUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCodeUsage"> | string
    promoCodeId?: StringWithAggregatesFilter<"PromoCodeUsage"> | string
    userId?: StringWithAggregatesFilter<"PromoCodeUsage"> | string
    points?: IntWithAggregatesFilter<"PromoCodeUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromoCodeUsage"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    points?: IntFilter<"Referral"> | number
    status?: EnumReferralStatusFilter<"Referral"> | $Enums.ReferralStatus
    completedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referred?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referred?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referredId?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    points?: IntFilter<"Referral"> | number
    status?: EnumReferralStatusFilter<"Referral"> | $Enums.ReferralStatus
    completedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referred?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "referredId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    referredId?: StringWithAggregatesFilter<"Referral"> | string
    points?: IntWithAggregatesFilter<"Referral"> | number
    status?: EnumReferralStatusWithAggregatesFilter<"Referral"> | $Enums.ReferralStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    orderId?: StringFilter<"Review"> | string
    serviceId?: StringFilter<"Review"> | string
    authorId?: StringFilter<"Review"> | string
    masterId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    master?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    authorId?: SortOrder
    masterId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    master?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    serviceId?: StringFilter<"Review"> | string
    authorId?: StringFilter<"Review"> | string
    masterId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    master?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "orderId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    authorId?: SortOrder
    masterId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    orderId?: StringWithAggregatesFilter<"Review"> | string
    serviceId?: StringWithAggregatesFilter<"Review"> | string
    authorId?: StringWithAggregatesFilter<"Review"> | string
    masterId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: StringFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    slug?: StringFilter<"ServiceCategory"> | string
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    icon?: StringNullableFilter<"ServiceCategory"> | string | null
    image?: StringNullableFilter<"ServiceCategory"> | string | null
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    services?: ServiceListRelationFilter
    homePageItems?: HomePageSectionItemListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    homePageItems?: HomePageSectionItemOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    icon?: StringNullableFilter<"ServiceCategory"> | string | null
    image?: StringNullableFilter<"ServiceCategory"> | string | null
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    services?: ServiceListRelationFilter
    homePageItems?: HomePageSectionItemListRelationFilter
  }, "id" | "name" | "slug">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    slug?: StringWithAggregatesFilter<"ServiceCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ServiceCategory"> | string | null
    image?: StringNullableWithAggregatesFilter<"ServiceCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: FloatNullableFilter<"Service"> | number | null
    image?: StringNullableFilter<"Service"> | string | null
    time?: StringNullableFilter<"Service"> | string | null
    categoryId?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    orders?: OrderItemListRelationFilter
    cities?: ServiceCityListRelationFilter
    homePageItems?: HomePageSectionItemListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    orders?: OrderItemOrderByRelationAggregateInput
    cities?: ServiceCityOrderByRelationAggregateInput
    homePageItems?: HomePageSectionItemOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId_slug?: ServiceCategoryIdSlugCompoundUniqueInput
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: FloatNullableFilter<"Service"> | number | null
    image?: StringNullableFilter<"Service"> | string | null
    time?: StringNullableFilter<"Service"> | string | null
    categoryId?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    category?: XOR<ServiceCategoryScalarRelationFilter, ServiceCategoryWhereInput>
    orders?: OrderItemListRelationFilter
    cities?: ServiceCityListRelationFilter
    homePageItems?: HomePageSectionItemListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "categoryId_slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Service"> | number | null
    image?: StringNullableWithAggregatesFilter<"Service"> | string | null
    time?: StringNullableWithAggregatesFilter<"Service"> | string | null
    categoryId?: StringWithAggregatesFilter<"Service"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServiceCityWhereInput = {
    AND?: ServiceCityWhereInput | ServiceCityWhereInput[]
    OR?: ServiceCityWhereInput[]
    NOT?: ServiceCityWhereInput | ServiceCityWhereInput[]
    id?: StringFilter<"ServiceCity"> | string
    serviceId?: StringFilter<"ServiceCity"> | string
    cityId?: StringFilter<"ServiceCity"> | string
    createdAt?: DateTimeFilter<"ServiceCity"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type ServiceCityOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
  }

  export type ServiceCityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceId_cityId?: ServiceCityServiceIdCityIdCompoundUniqueInput
    AND?: ServiceCityWhereInput | ServiceCityWhereInput[]
    OR?: ServiceCityWhereInput[]
    NOT?: ServiceCityWhereInput | ServiceCityWhereInput[]
    serviceId?: StringFilter<"ServiceCity"> | string
    cityId?: StringFilter<"ServiceCity"> | string
    createdAt?: DateTimeFilter<"ServiceCity"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id" | "serviceId_cityId">

  export type ServiceCityOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceCityCountOrderByAggregateInput
    _max?: ServiceCityMaxOrderByAggregateInput
    _min?: ServiceCityMinOrderByAggregateInput
  }

  export type ServiceCityScalarWhereWithAggregatesInput = {
    AND?: ServiceCityScalarWhereWithAggregatesInput | ServiceCityScalarWhereWithAggregatesInput[]
    OR?: ServiceCityScalarWhereWithAggregatesInput[]
    NOT?: ServiceCityScalarWhereWithAggregatesInput | ServiceCityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCity"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceCity"> | string
    cityId?: StringWithAggregatesFilter<"ServiceCity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCity"> | Date | string
  }

  export type StoryWhereInput = {
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    id?: StringFilter<"Story"> | string
    title?: StringFilter<"Story"> | string
    image?: StringNullableFilter<"Story"> | string | null
    isActive?: BoolFilter<"Story"> | boolean
    order?: IntFilter<"Story"> | number
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    images?: StoryImageListRelationFilter
  }

  export type StoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: StoryImageOrderByRelationAggregateInput
  }

  export type StoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    title?: StringFilter<"Story"> | string
    image?: StringNullableFilter<"Story"> | string | null
    isActive?: BoolFilter<"Story"> | boolean
    order?: IntFilter<"Story"> | number
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    images?: StoryImageListRelationFilter
  }, "id">

  export type StoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoryCountOrderByAggregateInput
    _avg?: StoryAvgOrderByAggregateInput
    _max?: StoryMaxOrderByAggregateInput
    _min?: StoryMinOrderByAggregateInput
    _sum?: StorySumOrderByAggregateInput
  }

  export type StoryScalarWhereWithAggregatesInput = {
    AND?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    OR?: StoryScalarWhereWithAggregatesInput[]
    NOT?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Story"> | string
    title?: StringWithAggregatesFilter<"Story"> | string
    image?: StringNullableWithAggregatesFilter<"Story"> | string | null
    isActive?: BoolWithAggregatesFilter<"Story"> | boolean
    order?: IntWithAggregatesFilter<"Story"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
  }

  export type StoryImageWhereInput = {
    AND?: StoryImageWhereInput | StoryImageWhereInput[]
    OR?: StoryImageWhereInput[]
    NOT?: StoryImageWhereInput | StoryImageWhereInput[]
    id?: StringFilter<"StoryImage"> | string
    storyId?: StringFilter<"StoryImage"> | string
    image?: StringFilter<"StoryImage"> | string
    title?: StringNullableFilter<"StoryImage"> | string | null
    duration?: IntFilter<"StoryImage"> | number
    order?: IntFilter<"StoryImage"> | number
    createdAt?: DateTimeFilter<"StoryImage"> | Date | string
    updatedAt?: DateTimeFilter<"StoryImage"> | Date | string
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
  }

  export type StoryImageOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    image?: SortOrder
    title?: SortOrderInput | SortOrder
    duration?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    story?: StoryOrderByWithRelationInput
  }

  export type StoryImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryImageWhereInput | StoryImageWhereInput[]
    OR?: StoryImageWhereInput[]
    NOT?: StoryImageWhereInput | StoryImageWhereInput[]
    storyId?: StringFilter<"StoryImage"> | string
    image?: StringFilter<"StoryImage"> | string
    title?: StringNullableFilter<"StoryImage"> | string | null
    duration?: IntFilter<"StoryImage"> | number
    order?: IntFilter<"StoryImage"> | number
    createdAt?: DateTimeFilter<"StoryImage"> | Date | string
    updatedAt?: DateTimeFilter<"StoryImage"> | Date | string
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
  }, "id">

  export type StoryImageOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    image?: SortOrder
    title?: SortOrderInput | SortOrder
    duration?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoryImageCountOrderByAggregateInput
    _avg?: StoryImageAvgOrderByAggregateInput
    _max?: StoryImageMaxOrderByAggregateInput
    _min?: StoryImageMinOrderByAggregateInput
    _sum?: StoryImageSumOrderByAggregateInput
  }

  export type StoryImageScalarWhereWithAggregatesInput = {
    AND?: StoryImageScalarWhereWithAggregatesInput | StoryImageScalarWhereWithAggregatesInput[]
    OR?: StoryImageScalarWhereWithAggregatesInput[]
    NOT?: StoryImageScalarWhereWithAggregatesInput | StoryImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryImage"> | string
    storyId?: StringWithAggregatesFilter<"StoryImage"> | string
    image?: StringWithAggregatesFilter<"StoryImage"> | string
    title?: StringNullableWithAggregatesFilter<"StoryImage"> | string | null
    duration?: IntWithAggregatesFilter<"StoryImage"> | number
    order?: IntWithAggregatesFilter<"StoryImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StoryImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoryImage"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    rating?: FloatNullableFilter<"User"> | number | null
    reviewsCount?: IntNullableFilter<"User"> | number | null
    isActive?: BoolNullableFilter<"User"> | boolean | null
    cityId?: StringNullableFilter<"User"> | string | null
    pushToken?: StringNullableFilter<"User"> | string | null
    referralCode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    ordersAsClient?: OrderListRelationFilter
    ordersAsMaster?: OrderListRelationFilter
    referrals?: ReferralListRelationFilter
    referred?: XOR<ReferralNullableScalarRelationFilter, ReferralWhereInput> | null
    masterApplication?: XOR<MasterApplicationNullableScalarRelationFilter, MasterApplicationWhereInput> | null
    processedApplications?: MasterApplicationListRelationFilter
    promoCodeUsages?: PromoCodeUsageListRelationFilter
    chatsAsUser?: ChatListRelationFilter
    chatsAsManager?: ChatListRelationFilter
    bugReports?: BugReportListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    points?: SortOrder
    role?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewsCount?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    pushToken?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    ordersAsClient?: OrderOrderByRelationAggregateInput
    ordersAsMaster?: OrderOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    referred?: ReferralOrderByWithRelationInput
    masterApplication?: MasterApplicationOrderByWithRelationInput
    processedApplications?: MasterApplicationOrderByRelationAggregateInput
    promoCodeUsages?: PromoCodeUsageOrderByRelationAggregateInput
    chatsAsUser?: ChatOrderByRelationAggregateInput
    chatsAsManager?: ChatOrderByRelationAggregateInput
    bugReports?: BugReportOrderByRelationAggregateInput
    reviewsGiven?: ReviewOrderByRelationAggregateInput
    reviewsReceived?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    rating?: FloatNullableFilter<"User"> | number | null
    reviewsCount?: IntNullableFilter<"User"> | number | null
    isActive?: BoolNullableFilter<"User"> | boolean | null
    cityId?: StringNullableFilter<"User"> | string | null
    pushToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    ordersAsClient?: OrderListRelationFilter
    ordersAsMaster?: OrderListRelationFilter
    referrals?: ReferralListRelationFilter
    referred?: XOR<ReferralNullableScalarRelationFilter, ReferralWhereInput> | null
    masterApplication?: XOR<MasterApplicationNullableScalarRelationFilter, MasterApplicationWhereInput> | null
    processedApplications?: MasterApplicationListRelationFilter
    promoCodeUsages?: PromoCodeUsageListRelationFilter
    chatsAsUser?: ChatListRelationFilter
    chatsAsManager?: ChatListRelationFilter
    bugReports?: BugReportListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
  }, "id" | "phone" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    points?: SortOrder
    role?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviewsCount?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    pushToken?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    points?: IntWithAggregatesFilter<"User"> | number
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    rating?: FloatNullableWithAggregatesFilter<"User"> | number | null
    reviewsCount?: IntNullableWithAggregatesFilter<"User"> | number | null
    isActive?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    cityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    pushToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AuthCodeCreateInput = {
    id?: string
    phone: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type AuthCodeUncheckedCreateInput = {
    id?: string
    phone: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type AuthCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthCodeCreateManyInput = {
    id?: string
    phone: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type AuthCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportCreateInput = {
    id?: string
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBugReportsInput
    images?: BugReportImageCreateNestedManyWithoutBugReportInput
  }

  export type BugReportUncheckedCreateInput = {
    id?: string
    userId?: string | null
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    images?: BugReportImageUncheckedCreateNestedManyWithoutBugReportInput
  }

  export type BugReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBugReportsNestedInput
    images?: BugReportImageUpdateManyWithoutBugReportNestedInput
  }

  export type BugReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: BugReportImageUncheckedUpdateManyWithoutBugReportNestedInput
  }

  export type BugReportCreateManyInput = {
    id?: string
    userId?: string | null
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type BugReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BugReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BugReportImageCreateInput = {
    id?: string
    imageUrl: string
    order?: number
    createdAt?: Date | string
    bugReport: BugReportCreateNestedOneWithoutImagesInput
  }

  export type BugReportImageUncheckedCreateInput = {
    id?: string
    bugReportId: string
    imageUrl: string
    order?: number
    createdAt?: Date | string
  }

  export type BugReportImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bugReport?: BugReportUpdateOneRequiredWithoutImagesNestedInput
  }

  export type BugReportImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bugReportId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportImageCreateManyInput = {
    id?: string
    bugReportId: string
    imageUrl: string
    order?: number
    createdAt?: Date | string
  }

  export type BugReportImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bugReportId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutChatsAsUserInput
    manager?: UserCreateNestedOneWithoutChatsAsManagerInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    userId: string
    managerId?: string | null
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChatsAsUserNestedInput
    manager?: UserUpdateOneWithoutChatsAsManagerNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    userId: string
    managerId?: string | null
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatMessageCreateInput = {
    id?: string
    text: string
    isFromUser?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    chatId: string
    text: string
    isFromUser?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    chatId: string
    text: string
    isFromUser?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCityInput
    services?: ServiceCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    services?: ServiceCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCityNestedInput
    services?: ServiceCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    services?: ServiceCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionCreateInput = {
    id?: string
    type: $Enums.HomePageSectionType
    title?: string | null
    icon?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: HomePageSectionItemCreateNestedManyWithoutSectionInput
  }

  export type HomePageSectionUncheckedCreateInput = {
    id?: string
    type: $Enums.HomePageSectionType
    title?: string | null
    icon?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: HomePageSectionItemUncheckedCreateNestedManyWithoutSectionInput
  }

  export type HomePageSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHomePageSectionTypeFieldUpdateOperationsInput | $Enums.HomePageSectionType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: HomePageSectionItemUpdateManyWithoutSectionNestedInput
  }

  export type HomePageSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHomePageSectionTypeFieldUpdateOperationsInput | $Enums.HomePageSectionType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: HomePageSectionItemUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type HomePageSectionCreateManyInput = {
    id?: string
    type: $Enums.HomePageSectionType
    title?: string | null
    icon?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHomePageSectionTypeFieldUpdateOperationsInput | $Enums.HomePageSectionType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHomePageSectionTypeFieldUpdateOperationsInput | $Enums.HomePageSectionType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemCreateInput = {
    id?: string
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: HomePageSectionCreateNestedOneWithoutItemsInput
    category?: ServiceCategoryCreateNestedOneWithoutHomePageItemsInput
    service?: ServiceCreateNestedOneWithoutHomePageItemsInput
  }

  export type HomePageSectionItemUncheckedCreateInput = {
    id?: string
    sectionId: string
    categoryId?: string | null
    serviceId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: HomePageSectionUpdateOneRequiredWithoutItemsNestedInput
    category?: ServiceCategoryUpdateOneWithoutHomePageItemsNestedInput
    service?: ServiceUpdateOneWithoutHomePageItemsNestedInput
  }

  export type HomePageSectionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemCreateManyInput = {
    id?: string
    sectionId: string
    categoryId?: string | null
    serviceId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationCreateInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedBy?: UserCreateNestedOneWithoutProcessedApplicationsInput
    user: UserCreateNestedOneWithoutMasterApplicationInput
  }

  export type MasterApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    processedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MasterApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedBy?: UserUpdateOneWithoutProcessedApplicationsNestedInput
    user?: UserUpdateOneRequiredWithoutMasterApplicationNestedInput
  }

  export type MasterApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationCreateManyInput = {
    id?: string
    userId: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    processedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MasterApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    client?: UserCreateNestedOneWithoutOrdersAsClientInput
    master?: UserCreateNestedOneWithoutOrdersAsMasterInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    steps?: OrderStepCreateNestedManyWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    steps?: OrderStepUncheckedCreateNestedManyWithoutOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: UserUpdateOneWithoutOrdersAsClientNestedInput
    master?: UserUpdateOneWithoutOrdersAsMasterNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUpdateManyWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUncheckedUpdateManyWithoutOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity?: number
    price: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    service: ServiceCreateNestedOneWithoutOrdersInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    serviceId: string
    quantity?: number
    price: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    serviceId: string
    quantity?: number
    price: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStepCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StepStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutStepsInput
  }

  export type OrderStepUncheckedCreateInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    status?: $Enums.StepStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutStepsNestedInput
  }

  export type OrderStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStepCreateManyInput = {
    id?: string
    orderId: string
    title: string
    description?: string | null
    status?: $Enums.StepStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    points?: number
    discount?: number | null
    discountType?: string | null
    minAmount?: number | null
    maxDiscount?: number | null
    expiresAt?: Date | string | null
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: PromoCodeUsageCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    points?: number
    discount?: number | null
    discountType?: string | null
    minAmount?: number | null
    maxDiscount?: number | null
    expiresAt?: Date | string | null
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    points?: number
    discount?: number | null
    discountType?: string | null
    minAmount?: number | null
    maxDiscount?: number | null
    expiresAt?: Date | string | null
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageCreateInput = {
    id?: string
    points?: number
    createdAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutUsagesInput
    user: UserCreateNestedOneWithoutPromoCodeUsagesInput
  }

  export type PromoCodeUsageUncheckedCreateInput = {
    id?: string
    promoCodeId: string
    userId: string
    points?: number
    createdAt?: Date | string
  }

  export type PromoCodeUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutUsagesNestedInput
    user?: UserUpdateOneRequiredWithoutPromoCodeUsagesNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageCreateManyInput = {
    id?: string
    promoCodeId: string
    userId: string
    points?: number
    createdAt?: Date | string
  }

  export type PromoCodeUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsInput
    referred: UserCreateNestedOneWithoutReferredInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    referredId: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
    referred?: UserUpdateOneRequiredWithoutReferredNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    referredId: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReviewInput
    service: ServiceCreateNestedOneWithoutReviewsInput
    author: UserCreateNestedOneWithoutReviewsGivenInput
    master?: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    orderId: string
    serviceId: string
    authorId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    service?: ServiceUpdateOneRequiredWithoutReviewsNestedInput
    author?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    master?: UserUpdateOneWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    orderId: string
    serviceId: string
    authorId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryInput
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
    homePageItems?: HomePageSectionItemUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    orders?: OrderItemCreateNestedManyWithoutServiceInput
    cities?: ServiceCityCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutServiceInput
    reviews?: ReviewCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
    cities?: ServiceCityUncheckedCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutServiceInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    orders?: OrderItemUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUncheckedUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityCreateInput = {
    id?: string
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutCitiesInput
    city: CityCreateNestedOneWithoutServicesInput
  }

  export type ServiceCityUncheckedCreateInput = {
    id?: string
    serviceId: string
    cityId: string
    createdAt?: Date | string
  }

  export type ServiceCityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutCitiesNestedInput
    city?: CityUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceCityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityCreateManyInput = {
    id?: string
    serviceId: string
    cityId: string
    createdAt?: Date | string
  }

  export type ServiceCityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCreateInput = {
    id?: string
    title: string
    image?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: StoryImageCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateInput = {
    id?: string
    title: string
    image?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: StoryImageUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StoryImageUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StoryImageUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateManyInput = {
    id?: string
    title: string
    image?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryImageCreateInput = {
    id?: string
    image: string
    title?: string | null
    duration?: number
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    story: StoryCreateNestedOneWithoutImagesInput
  }

  export type StoryImageUncheckedCreateInput = {
    id?: string
    storyId: string
    image: string
    title?: string | null
    duration?: number
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutImagesNestedInput
  }

  export type StoryImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryImageCreateManyInput = {
    id?: string
    storyId: string
    image: string
    title?: string | null
    duration?: number
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AuthCodeCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type AuthCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type AuthCodeMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumBugReportCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportCategory | EnumBugReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportCategoryFilter<$PrismaModel> | $Enums.BugReportCategory
  }

  export type EnumBugReportPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportPriority | EnumBugReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportPriorityFilter<$PrismaModel> | $Enums.BugReportPriority
  }

  export type EnumBugReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportStatus | EnumBugReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportStatusFilter<$PrismaModel> | $Enums.BugReportStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BugReportImageListRelationFilter = {
    every?: BugReportImageWhereInput
    some?: BugReportImageWhereInput
    none?: BugReportImageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BugReportImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BugReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    email?: SortOrder
    logFileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type BugReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    email?: SortOrder
    logFileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type BugReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    email?: SortOrder
    logFileUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumBugReportCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportCategory | EnumBugReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BugReportCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBugReportCategoryFilter<$PrismaModel>
    _max?: NestedEnumBugReportCategoryFilter<$PrismaModel>
  }

  export type EnumBugReportPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportPriority | EnumBugReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportPriorityWithAggregatesFilter<$PrismaModel> | $Enums.BugReportPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBugReportPriorityFilter<$PrismaModel>
    _max?: NestedEnumBugReportPriorityFilter<$PrismaModel>
  }

  export type EnumBugReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportStatus | EnumBugReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.BugReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBugReportStatusFilter<$PrismaModel>
    _max?: NestedEnumBugReportStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BugReportScalarRelationFilter = {
    is?: BugReportWhereInput
    isNot?: BugReportWhereInput
  }

  export type BugReportImageCountOrderByAggregateInput = {
    id?: SortOrder
    bugReportId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type BugReportImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BugReportImageMaxOrderByAggregateInput = {
    id?: SortOrder
    bugReportId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type BugReportImageMinOrderByAggregateInput = {
    id?: SortOrder
    bugReportId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type BugReportImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumChatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatStatus | EnumChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatStatusFilter<$PrismaModel> | $Enums.ChatStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    managerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    managerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    managerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type EnumChatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatStatus | EnumChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatStatusFilter<$PrismaModel>
    _max?: NestedEnumChatStatusFilter<$PrismaModel>
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    text?: SortOrder
    isFromUser?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    text?: SortOrder
    isFromUser?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    text?: SortOrder
    isFromUser?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ServiceCityListRelationFilter = {
    every?: ServiceCityWhereInput
    some?: ServiceCityWhereInput
    none?: ServiceCityWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumHomePageSectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HomePageSectionType | EnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomePageSectionTypeFilter<$PrismaModel> | $Enums.HomePageSectionType
  }

  export type HomePageSectionItemListRelationFilter = {
    every?: HomePageSectionItemWhereInput
    some?: HomePageSectionItemWhereInput
    none?: HomePageSectionItemWhereInput
  }

  export type HomePageSectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomePageSectionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HomePageSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSectionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumHomePageSectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HomePageSectionType | EnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomePageSectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.HomePageSectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHomePageSectionTypeFilter<$PrismaModel>
    _max?: NestedEnumHomePageSectionTypeFilter<$PrismaModel>
  }

  export type HomePageSectionScalarRelationFilter = {
    is?: HomePageSectionWhereInput
    isNot?: HomePageSectionWhereInput
  }

  export type ServiceCategoryNullableScalarRelationFilter = {
    is?: ServiceCategoryWhereInput | null
    isNot?: ServiceCategoryWhereInput | null
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type HomePageSectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    serviceId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSectionItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type HomePageSectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    serviceId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    categoryId?: SortOrder
    serviceId?: SortOrder
    imageUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HomePageSectionItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumMasterApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterApplicationStatus | EnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterApplicationStatusFilter<$PrismaModel> | $Enums.MasterApplicationStatus
  }

  export type MasterApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    experience?: SortOrder
    specialties?: SortOrder
    description?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MasterApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    experience?: SortOrder
    description?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MasterApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    experience?: SortOrder
    description?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMasterApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterApplicationStatus | EnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.MasterApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMasterApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumMasterApplicationStatusFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumOrderUrgencyFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderUrgency | EnumOrderUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderUrgencyFilter<$PrismaModel> | $Enums.OrderUrgency
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderStepListRelationFilter = {
    every?: OrderStepWhereInput
    some?: OrderStepWhereInput
    none?: OrderStepWhereInput
  }

  export type ReviewNullableScalarRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrder
    masterId?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    city?: SortOrder
    address?: SortOrder
    apartment?: SortOrder
    isPrivateHouse?: SortOrder
    urgency?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    totalPrice?: SortOrder
    workDescription?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrder
    masterId?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    city?: SortOrder
    address?: SortOrder
    apartment?: SortOrder
    isPrivateHouse?: SortOrder
    urgency?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    totalPrice?: SortOrder
    workDescription?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientId?: SortOrder
    masterId?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    city?: SortOrder
    address?: SortOrder
    apartment?: SortOrder
    isPrivateHouse?: SortOrder
    urgency?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    totalPrice?: SortOrder
    workDescription?: SortOrder
    warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumOrderUrgencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderUrgency | EnumOrderUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderUrgencyWithAggregatesFilter<$PrismaModel> | $Enums.OrderUrgency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderUrgencyFilter<$PrismaModel>
    _max?: NestedEnumOrderUrgencyFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type OrderStepCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStepMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStepMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PromoCodeUsageListRelationFilter = {
    every?: PromoCodeUsageWhereInput
    some?: PromoCodeUsageWhereInput
    none?: PromoCodeUsageWhereInput
  }

  export type PromoCodeUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    points?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    expiresAt?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    points?: SortOrder
    discount?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    points?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    expiresAt?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    points?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    expiresAt?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    points?: SortOrder
    discount?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
    usedCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PromoCodeScalarRelationFilter = {
    is?: PromoCodeWhereInput
    isNot?: PromoCodeWhereInput
  }

  export type PromoCodeUsagePromoCodeIdUserIdCompoundUniqueInput = {
    promoCodeId: string
    userId: string
  }

  export type PromoCodeUsageCountOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeUsageAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type PromoCodeUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeUsageMinOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeUsageSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumReferralStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusFilter<$PrismaModel> | $Enums.ReferralStatus
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumReferralStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReferralStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralStatusFilter<$PrismaModel>
    _max?: NestedEnumReferralStatusFilter<$PrismaModel>
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    authorId?: SortOrder
    masterId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    authorId?: SortOrder
    masterId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceId?: SortOrder
    authorId?: SortOrder
    masterId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryScalarRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryIdSlugCompoundUniqueInput = {
    categoryId: string
    slug: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    image?: SortOrder
    time?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    image?: SortOrder
    time?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    image?: SortOrder
    time?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type ServiceCityServiceIdCityIdCompoundUniqueInput = {
    serviceId: string
    cityId: string
  }

  export type ServiceCityCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCityMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceCityMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryImageListRelationFilter = {
    every?: StoryImageWhereInput
    some?: StoryImageWhereInput
    none?: StoryImageWhereInput
  }

  export type StoryImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StoryScalarRelationFilter = {
    is?: StoryWhereInput
    isNot?: StoryWhereInput
  }

  export type StoryImageCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    image?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryImageAvgOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type StoryImageMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    image?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryImageMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    image?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoryImageSumOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CityNullableScalarRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralNullableScalarRelationFilter = {
    is?: ReferralWhereInput | null
    isNot?: ReferralWhereInput | null
  }

  export type MasterApplicationNullableScalarRelationFilter = {
    is?: MasterApplicationWhereInput | null
    isNot?: MasterApplicationWhereInput | null
  }

  export type MasterApplicationListRelationFilter = {
    every?: MasterApplicationWhereInput
    some?: MasterApplicationWhereInput
    none?: MasterApplicationWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type BugReportListRelationFilter = {
    every?: BugReportWhereInput
    some?: BugReportWhereInput
    none?: BugReportWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BugReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    points?: SortOrder
    role?: SortOrder
    rating?: SortOrder
    reviewsCount?: SortOrder
    isActive?: SortOrder
    cityId?: SortOrder
    pushToken?: SortOrder
    referralCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
    rating?: SortOrder
    reviewsCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    points?: SortOrder
    role?: SortOrder
    rating?: SortOrder
    reviewsCount?: SortOrder
    isActive?: SortOrder
    cityId?: SortOrder
    pushToken?: SortOrder
    referralCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    points?: SortOrder
    role?: SortOrder
    rating?: SortOrder
    reviewsCount?: SortOrder
    isActive?: SortOrder
    cityId?: SortOrder
    pushToken?: SortOrder
    referralCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
    rating?: SortOrder
    reviewsCount?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutBugReportsInput = {
    create?: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBugReportsInput
    connect?: UserWhereUniqueInput
  }

  export type BugReportImageCreateNestedManyWithoutBugReportInput = {
    create?: XOR<BugReportImageCreateWithoutBugReportInput, BugReportImageUncheckedCreateWithoutBugReportInput> | BugReportImageCreateWithoutBugReportInput[] | BugReportImageUncheckedCreateWithoutBugReportInput[]
    connectOrCreate?: BugReportImageCreateOrConnectWithoutBugReportInput | BugReportImageCreateOrConnectWithoutBugReportInput[]
    createMany?: BugReportImageCreateManyBugReportInputEnvelope
    connect?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
  }

  export type BugReportImageUncheckedCreateNestedManyWithoutBugReportInput = {
    create?: XOR<BugReportImageCreateWithoutBugReportInput, BugReportImageUncheckedCreateWithoutBugReportInput> | BugReportImageCreateWithoutBugReportInput[] | BugReportImageUncheckedCreateWithoutBugReportInput[]
    connectOrCreate?: BugReportImageCreateOrConnectWithoutBugReportInput | BugReportImageCreateOrConnectWithoutBugReportInput[]
    createMany?: BugReportImageCreateManyBugReportInputEnvelope
    connect?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
  }

  export type EnumBugReportCategoryFieldUpdateOperationsInput = {
    set?: $Enums.BugReportCategory
  }

  export type EnumBugReportPriorityFieldUpdateOperationsInput = {
    set?: $Enums.BugReportPriority
  }

  export type EnumBugReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.BugReportStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutBugReportsNestedInput = {
    create?: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBugReportsInput
    upsert?: UserUpsertWithoutBugReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBugReportsInput, UserUpdateWithoutBugReportsInput>, UserUncheckedUpdateWithoutBugReportsInput>
  }

  export type BugReportImageUpdateManyWithoutBugReportNestedInput = {
    create?: XOR<BugReportImageCreateWithoutBugReportInput, BugReportImageUncheckedCreateWithoutBugReportInput> | BugReportImageCreateWithoutBugReportInput[] | BugReportImageUncheckedCreateWithoutBugReportInput[]
    connectOrCreate?: BugReportImageCreateOrConnectWithoutBugReportInput | BugReportImageCreateOrConnectWithoutBugReportInput[]
    upsert?: BugReportImageUpsertWithWhereUniqueWithoutBugReportInput | BugReportImageUpsertWithWhereUniqueWithoutBugReportInput[]
    createMany?: BugReportImageCreateManyBugReportInputEnvelope
    set?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    disconnect?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    delete?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    connect?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    update?: BugReportImageUpdateWithWhereUniqueWithoutBugReportInput | BugReportImageUpdateWithWhereUniqueWithoutBugReportInput[]
    updateMany?: BugReportImageUpdateManyWithWhereWithoutBugReportInput | BugReportImageUpdateManyWithWhereWithoutBugReportInput[]
    deleteMany?: BugReportImageScalarWhereInput | BugReportImageScalarWhereInput[]
  }

  export type BugReportImageUncheckedUpdateManyWithoutBugReportNestedInput = {
    create?: XOR<BugReportImageCreateWithoutBugReportInput, BugReportImageUncheckedCreateWithoutBugReportInput> | BugReportImageCreateWithoutBugReportInput[] | BugReportImageUncheckedCreateWithoutBugReportInput[]
    connectOrCreate?: BugReportImageCreateOrConnectWithoutBugReportInput | BugReportImageCreateOrConnectWithoutBugReportInput[]
    upsert?: BugReportImageUpsertWithWhereUniqueWithoutBugReportInput | BugReportImageUpsertWithWhereUniqueWithoutBugReportInput[]
    createMany?: BugReportImageCreateManyBugReportInputEnvelope
    set?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    disconnect?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    delete?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    connect?: BugReportImageWhereUniqueInput | BugReportImageWhereUniqueInput[]
    update?: BugReportImageUpdateWithWhereUniqueWithoutBugReportInput | BugReportImageUpdateWithWhereUniqueWithoutBugReportInput[]
    updateMany?: BugReportImageUpdateManyWithWhereWithoutBugReportInput | BugReportImageUpdateManyWithWhereWithoutBugReportInput[]
    deleteMany?: BugReportImageScalarWhereInput | BugReportImageScalarWhereInput[]
  }

  export type BugReportCreateNestedOneWithoutImagesInput = {
    create?: XOR<BugReportCreateWithoutImagesInput, BugReportUncheckedCreateWithoutImagesInput>
    connectOrCreate?: BugReportCreateOrConnectWithoutImagesInput
    connect?: BugReportWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BugReportUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<BugReportCreateWithoutImagesInput, BugReportUncheckedCreateWithoutImagesInput>
    connectOrCreate?: BugReportCreateOrConnectWithoutImagesInput
    upsert?: BugReportUpsertWithoutImagesInput
    connect?: BugReportWhereUniqueInput
    update?: XOR<XOR<BugReportUpdateToOneWithWhereWithoutImagesInput, BugReportUpdateWithoutImagesInput>, BugReportUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutChatsAsUserInput = {
    create?: XOR<UserCreateWithoutChatsAsUserInput, UserUncheckedCreateWithoutChatsAsUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsAsUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatsAsManagerInput = {
    create?: XOR<UserCreateWithoutChatsAsManagerInput, UserUncheckedCreateWithoutChatsAsManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsAsManagerInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type EnumChatStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChatStatus
  }

  export type UserUpdateOneRequiredWithoutChatsAsUserNestedInput = {
    create?: XOR<UserCreateWithoutChatsAsUserInput, UserUncheckedCreateWithoutChatsAsUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsAsUserInput
    upsert?: UserUpsertWithoutChatsAsUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsAsUserInput, UserUpdateWithoutChatsAsUserInput>, UserUncheckedUpdateWithoutChatsAsUserInput>
  }

  export type UserUpdateOneWithoutChatsAsManagerNestedInput = {
    create?: XOR<UserCreateWithoutChatsAsManagerInput, UserUncheckedCreateWithoutChatsAsManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsAsManagerInput
    upsert?: UserUpsertWithoutChatsAsManagerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsAsManagerInput, UserUpdateWithoutChatsAsManagerInput>, UserUncheckedUpdateWithoutChatsAsManagerInput>
  }

  export type ChatMessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ServiceCityCreateNestedManyWithoutCityInput = {
    create?: XOR<ServiceCityCreateWithoutCityInput, ServiceCityUncheckedCreateWithoutCityInput> | ServiceCityCreateWithoutCityInput[] | ServiceCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutCityInput | ServiceCityCreateOrConnectWithoutCityInput[]
    createMany?: ServiceCityCreateManyCityInputEnvelope
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ServiceCityUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<ServiceCityCreateWithoutCityInput, ServiceCityUncheckedCreateWithoutCityInput> | ServiceCityCreateWithoutCityInput[] | ServiceCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutCityInput | ServiceCityCreateOrConnectWithoutCityInput[]
    createMany?: ServiceCityCreateManyCityInputEnvelope
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ServiceCityUpdateManyWithoutCityNestedInput = {
    create?: XOR<ServiceCityCreateWithoutCityInput, ServiceCityUncheckedCreateWithoutCityInput> | ServiceCityCreateWithoutCityInput[] | ServiceCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutCityInput | ServiceCityCreateOrConnectWithoutCityInput[]
    upsert?: ServiceCityUpsertWithWhereUniqueWithoutCityInput | ServiceCityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: ServiceCityCreateManyCityInputEnvelope
    set?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    disconnect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    delete?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    update?: ServiceCityUpdateWithWhereUniqueWithoutCityInput | ServiceCityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: ServiceCityUpdateManyWithWhereWithoutCityInput | ServiceCityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: ServiceCityScalarWhereInput | ServiceCityScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ServiceCityUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<ServiceCityCreateWithoutCityInput, ServiceCityUncheckedCreateWithoutCityInput> | ServiceCityCreateWithoutCityInput[] | ServiceCityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutCityInput | ServiceCityCreateOrConnectWithoutCityInput[]
    upsert?: ServiceCityUpsertWithWhereUniqueWithoutCityInput | ServiceCityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: ServiceCityCreateManyCityInputEnvelope
    set?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    disconnect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    delete?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    update?: ServiceCityUpdateWithWhereUniqueWithoutCityInput | ServiceCityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: ServiceCityUpdateManyWithWhereWithoutCityInput | ServiceCityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: ServiceCityScalarWhereInput | ServiceCityScalarWhereInput[]
  }

  export type HomePageSectionItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<HomePageSectionItemCreateWithoutSectionInput, HomePageSectionItemUncheckedCreateWithoutSectionInput> | HomePageSectionItemCreateWithoutSectionInput[] | HomePageSectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutSectionInput | HomePageSectionItemCreateOrConnectWithoutSectionInput[]
    createMany?: HomePageSectionItemCreateManySectionInputEnvelope
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
  }

  export type HomePageSectionItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<HomePageSectionItemCreateWithoutSectionInput, HomePageSectionItemUncheckedCreateWithoutSectionInput> | HomePageSectionItemCreateWithoutSectionInput[] | HomePageSectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutSectionInput | HomePageSectionItemCreateOrConnectWithoutSectionInput[]
    createMany?: HomePageSectionItemCreateManySectionInputEnvelope
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
  }

  export type EnumHomePageSectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.HomePageSectionType
  }

  export type HomePageSectionItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<HomePageSectionItemCreateWithoutSectionInput, HomePageSectionItemUncheckedCreateWithoutSectionInput> | HomePageSectionItemCreateWithoutSectionInput[] | HomePageSectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutSectionInput | HomePageSectionItemCreateOrConnectWithoutSectionInput[]
    upsert?: HomePageSectionItemUpsertWithWhereUniqueWithoutSectionInput | HomePageSectionItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: HomePageSectionItemCreateManySectionInputEnvelope
    set?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    disconnect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    delete?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    update?: HomePageSectionItemUpdateWithWhereUniqueWithoutSectionInput | HomePageSectionItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: HomePageSectionItemUpdateManyWithWhereWithoutSectionInput | HomePageSectionItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
  }

  export type HomePageSectionItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<HomePageSectionItemCreateWithoutSectionInput, HomePageSectionItemUncheckedCreateWithoutSectionInput> | HomePageSectionItemCreateWithoutSectionInput[] | HomePageSectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutSectionInput | HomePageSectionItemCreateOrConnectWithoutSectionInput[]
    upsert?: HomePageSectionItemUpsertWithWhereUniqueWithoutSectionInput | HomePageSectionItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: HomePageSectionItemCreateManySectionInputEnvelope
    set?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    disconnect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    delete?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    update?: HomePageSectionItemUpdateWithWhereUniqueWithoutSectionInput | HomePageSectionItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: HomePageSectionItemUpdateManyWithWhereWithoutSectionInput | HomePageSectionItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
  }

  export type HomePageSectionCreateNestedOneWithoutItemsInput = {
    create?: XOR<HomePageSectionCreateWithoutItemsInput, HomePageSectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: HomePageSectionCreateOrConnectWithoutItemsInput
    connect?: HomePageSectionWhereUniqueInput
  }

  export type ServiceCategoryCreateNestedOneWithoutHomePageItemsInput = {
    create?: XOR<ServiceCategoryCreateWithoutHomePageItemsInput, ServiceCategoryUncheckedCreateWithoutHomePageItemsInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutHomePageItemsInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutHomePageItemsInput = {
    create?: XOR<ServiceCreateWithoutHomePageItemsInput, ServiceUncheckedCreateWithoutHomePageItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutHomePageItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type HomePageSectionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<HomePageSectionCreateWithoutItemsInput, HomePageSectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: HomePageSectionCreateOrConnectWithoutItemsInput
    upsert?: HomePageSectionUpsertWithoutItemsInput
    connect?: HomePageSectionWhereUniqueInput
    update?: XOR<XOR<HomePageSectionUpdateToOneWithWhereWithoutItemsInput, HomePageSectionUpdateWithoutItemsInput>, HomePageSectionUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceCategoryUpdateOneWithoutHomePageItemsNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutHomePageItemsInput, ServiceCategoryUncheckedCreateWithoutHomePageItemsInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutHomePageItemsInput
    upsert?: ServiceCategoryUpsertWithoutHomePageItemsInput
    disconnect?: ServiceCategoryWhereInput | boolean
    delete?: ServiceCategoryWhereInput | boolean
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutHomePageItemsInput, ServiceCategoryUpdateWithoutHomePageItemsInput>, ServiceCategoryUncheckedUpdateWithoutHomePageItemsInput>
  }

  export type ServiceUpdateOneWithoutHomePageItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutHomePageItemsInput, ServiceUncheckedCreateWithoutHomePageItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutHomePageItemsInput
    upsert?: ServiceUpsertWithoutHomePageItemsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutHomePageItemsInput, ServiceUpdateWithoutHomePageItemsInput>, ServiceUncheckedUpdateWithoutHomePageItemsInput>
  }

  export type MasterApplicationCreatespecialtiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProcessedApplicationsInput = {
    create?: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMasterApplicationInput = {
    create?: XOR<UserCreateWithoutMasterApplicationInput, UserUncheckedCreateWithoutMasterApplicationInput>
    connectOrCreate?: UserCreateOrConnectWithoutMasterApplicationInput
    connect?: UserWhereUniqueInput
  }

  export type MasterApplicationUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumMasterApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.MasterApplicationStatus
  }

  export type UserUpdateOneWithoutProcessedApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedApplicationsInput
    upsert?: UserUpsertWithoutProcessedApplicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedApplicationsInput, UserUpdateWithoutProcessedApplicationsInput>, UserUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type UserUpdateOneRequiredWithoutMasterApplicationNestedInput = {
    create?: XOR<UserCreateWithoutMasterApplicationInput, UserUncheckedCreateWithoutMasterApplicationInput>
    connectOrCreate?: UserCreateOrConnectWithoutMasterApplicationInput
    upsert?: UserUpsertWithoutMasterApplicationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMasterApplicationInput, UserUpdateWithoutMasterApplicationInput>, UserUncheckedUpdateWithoutMasterApplicationInput>
  }

  export type UserCreateNestedOneWithoutOrdersAsClientInput = {
    create?: XOR<UserCreateWithoutOrdersAsClientInput, UserUncheckedCreateWithoutOrdersAsClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersAsClientInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersAsMasterInput = {
    create?: XOR<UserCreateWithoutOrdersAsMasterInput, UserUncheckedCreateWithoutOrdersAsMasterInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersAsMasterInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderStepCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStepCreateWithoutOrderInput, OrderStepUncheckedCreateWithoutOrderInput> | OrderStepCreateWithoutOrderInput[] | OrderStepUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStepCreateOrConnectWithoutOrderInput | OrderStepCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStepCreateManyOrderInputEnvelope
    connect?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
  }

  export type ReviewCreateNestedOneWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    connect?: ReviewWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderStepUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStepCreateWithoutOrderInput, OrderStepUncheckedCreateWithoutOrderInput> | OrderStepCreateWithoutOrderInput[] | OrderStepUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStepCreateOrConnectWithoutOrderInput | OrderStepCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStepCreateManyOrderInputEnvelope
    connect?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    connect?: ReviewWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumOrderUrgencyFieldUpdateOperationsInput = {
    set?: $Enums.OrderUrgency
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutOrdersAsClientNestedInput = {
    create?: XOR<UserCreateWithoutOrdersAsClientInput, UserUncheckedCreateWithoutOrdersAsClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersAsClientInput
    upsert?: UserUpsertWithoutOrdersAsClientInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersAsClientInput, UserUpdateWithoutOrdersAsClientInput>, UserUncheckedUpdateWithoutOrdersAsClientInput>
  }

  export type UserUpdateOneWithoutOrdersAsMasterNestedInput = {
    create?: XOR<UserCreateWithoutOrdersAsMasterInput, UserUncheckedCreateWithoutOrdersAsMasterInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersAsMasterInput
    upsert?: UserUpsertWithoutOrdersAsMasterInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersAsMasterInput, UserUpdateWithoutOrdersAsMasterInput>, UserUncheckedUpdateWithoutOrdersAsMasterInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderStepUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStepCreateWithoutOrderInput, OrderStepUncheckedCreateWithoutOrderInput> | OrderStepCreateWithoutOrderInput[] | OrderStepUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStepCreateOrConnectWithoutOrderInput | OrderStepCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStepUpsertWithWhereUniqueWithoutOrderInput | OrderStepUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStepCreateManyOrderInputEnvelope
    set?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    disconnect?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    delete?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    connect?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    update?: OrderStepUpdateWithWhereUniqueWithoutOrderInput | OrderStepUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStepUpdateManyWithWhereWithoutOrderInput | OrderStepUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStepScalarWhereInput | OrderStepScalarWhereInput[]
  }

  export type ReviewUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    upsert?: ReviewUpsertWithoutOrderInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutOrderInput, ReviewUpdateWithoutOrderInput>, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderStepUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStepCreateWithoutOrderInput, OrderStepUncheckedCreateWithoutOrderInput> | OrderStepCreateWithoutOrderInput[] | OrderStepUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStepCreateOrConnectWithoutOrderInput | OrderStepCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStepUpsertWithWhereUniqueWithoutOrderInput | OrderStepUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStepCreateManyOrderInputEnvelope
    set?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    disconnect?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    delete?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    connect?: OrderStepWhereUniqueInput | OrderStepWhereUniqueInput[]
    update?: OrderStepUpdateWithWhereUniqueWithoutOrderInput | OrderStepUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStepUpdateManyWithWhereWithoutOrderInput | OrderStepUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStepScalarWhereInput | OrderStepScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput
    upsert?: ReviewUpsertWithoutOrderInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutOrderInput, ReviewUpdateWithoutOrderInput>, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput
    connect?: ServiceWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput
    upsert?: ServiceUpsertWithoutOrdersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutOrdersInput, ServiceUpdateWithoutOrdersInput>, ServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderCreateNestedOneWithoutStepsInput = {
    create?: XOR<OrderCreateWithoutStepsInput, OrderUncheckedCreateWithoutStepsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStepsInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.StepStatus
  }

  export type OrderUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<OrderCreateWithoutStepsInput, OrderUncheckedCreateWithoutStepsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStepsInput
    upsert?: OrderUpsertWithoutStepsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutStepsInput, OrderUpdateWithoutStepsInput>, OrderUncheckedUpdateWithoutStepsInput>
  }

  export type PromoCodeUsageCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput | PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput | PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type PromoCodeCreateNestedOneWithoutUsagesInput = {
    create?: XOR<PromoCodeCreateWithoutUsagesInput, PromoCodeUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUsagesInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPromoCodeUsagesInput = {
    create?: XOR<UserCreateWithoutPromoCodeUsagesInput, UserUncheckedCreateWithoutPromoCodeUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromoCodeUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type PromoCodeUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<PromoCodeCreateWithoutUsagesInput, PromoCodeUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUsagesInput
    upsert?: PromoCodeUpsertWithoutUsagesInput
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutUsagesInput, PromoCodeUpdateWithoutUsagesInput>, PromoCodeUncheckedUpdateWithoutUsagesInput>
  }

  export type UserUpdateOneRequiredWithoutPromoCodeUsagesNestedInput = {
    create?: XOR<UserCreateWithoutPromoCodeUsagesInput, UserUncheckedCreateWithoutPromoCodeUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromoCodeUsagesInput
    upsert?: UserUpsertWithoutPromoCodeUsagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPromoCodeUsagesInput, UserUpdateWithoutPromoCodeUsagesInput>, UserUncheckedUpdateWithoutPromoCodeUsagesInput>
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferredInput = {
    create?: XOR<UserCreateWithoutReferredInput, UserUncheckedCreateWithoutReferredInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReferralStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReferralStatus
  }

  export type UserUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateOneRequiredWithoutReferredNestedInput = {
    create?: XOR<UserCreateWithoutReferredInput, UserUncheckedCreateWithoutReferredInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredInput
    upsert?: UserUpsertWithoutReferredInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredInput, UserUpdateWithoutReferredInput>, UserUncheckedUpdateWithoutReferredInput>
  }

  export type OrderCreateNestedOneWithoutReviewInput = {
    create?: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewInput
    connect?: OrderWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ServiceCreateWithoutReviewsInput, ServiceUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutReviewsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsGivenInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsReceivedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewInput
    upsert?: OrderUpsertWithoutReviewInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReviewInput, OrderUpdateWithoutReviewInput>, OrderUncheckedUpdateWithoutReviewInput>
  }

  export type ServiceUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ServiceCreateWithoutReviewsInput, ServiceUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutReviewsInput
    upsert?: ServiceUpsertWithoutReviewsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutReviewsInput, ServiceUpdateWithoutReviewsInput>, ServiceUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    upsert?: UserUpsertWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsGivenInput, UserUpdateWithoutReviewsGivenInput>, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateOneWithoutReviewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    upsert?: UserUpsertWithoutReviewsReceivedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsReceivedInput, UserUpdateWithoutReviewsReceivedInput>, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type HomePageSectionItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HomePageSectionItemCreateWithoutCategoryInput, HomePageSectionItemUncheckedCreateWithoutCategoryInput> | HomePageSectionItemCreateWithoutCategoryInput[] | HomePageSectionItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutCategoryInput | HomePageSectionItemCreateOrConnectWithoutCategoryInput[]
    createMany?: HomePageSectionItemCreateManyCategoryInputEnvelope
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type HomePageSectionItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HomePageSectionItemCreateWithoutCategoryInput, HomePageSectionItemUncheckedCreateWithoutCategoryInput> | HomePageSectionItemCreateWithoutCategoryInput[] | HomePageSectionItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutCategoryInput | HomePageSectionItemCreateOrConnectWithoutCategoryInput[]
    createMany?: HomePageSectionItemCreateManyCategoryInputEnvelope
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type HomePageSectionItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HomePageSectionItemCreateWithoutCategoryInput, HomePageSectionItemUncheckedCreateWithoutCategoryInput> | HomePageSectionItemCreateWithoutCategoryInput[] | HomePageSectionItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutCategoryInput | HomePageSectionItemCreateOrConnectWithoutCategoryInput[]
    upsert?: HomePageSectionItemUpsertWithWhereUniqueWithoutCategoryInput | HomePageSectionItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HomePageSectionItemCreateManyCategoryInputEnvelope
    set?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    disconnect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    delete?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    update?: HomePageSectionItemUpdateWithWhereUniqueWithoutCategoryInput | HomePageSectionItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HomePageSectionItemUpdateManyWithWhereWithoutCategoryInput | HomePageSectionItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type HomePageSectionItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HomePageSectionItemCreateWithoutCategoryInput, HomePageSectionItemUncheckedCreateWithoutCategoryInput> | HomePageSectionItemCreateWithoutCategoryInput[] | HomePageSectionItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutCategoryInput | HomePageSectionItemCreateOrConnectWithoutCategoryInput[]
    upsert?: HomePageSectionItemUpsertWithWhereUniqueWithoutCategoryInput | HomePageSectionItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HomePageSectionItemCreateManyCategoryInputEnvelope
    set?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    disconnect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    delete?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    update?: HomePageSectionItemUpdateWithWhereUniqueWithoutCategoryInput | HomePageSectionItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HomePageSectionItemUpdateManyWithWhereWithoutCategoryInput | HomePageSectionItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ServiceCityCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceCityCreateWithoutServiceInput, ServiceCityUncheckedCreateWithoutServiceInput> | ServiceCityCreateWithoutServiceInput[] | ServiceCityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutServiceInput | ServiceCityCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceCityCreateManyServiceInputEnvelope
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
  }

  export type HomePageSectionItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<HomePageSectionItemCreateWithoutServiceInput, HomePageSectionItemUncheckedCreateWithoutServiceInput> | HomePageSectionItemCreateWithoutServiceInput[] | HomePageSectionItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutServiceInput | HomePageSectionItemCreateOrConnectWithoutServiceInput[]
    createMany?: HomePageSectionItemCreateManyServiceInputEnvelope
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutServiceInput = {
    create?: XOR<ReviewCreateWithoutServiceInput, ReviewUncheckedCreateWithoutServiceInput> | ReviewCreateWithoutServiceInput[] | ReviewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceInput | ReviewCreateOrConnectWithoutServiceInput[]
    createMany?: ReviewCreateManyServiceInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ServiceCityUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceCityCreateWithoutServiceInput, ServiceCityUncheckedCreateWithoutServiceInput> | ServiceCityCreateWithoutServiceInput[] | ServiceCityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutServiceInput | ServiceCityCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceCityCreateManyServiceInputEnvelope
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
  }

  export type HomePageSectionItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<HomePageSectionItemCreateWithoutServiceInput, HomePageSectionItemUncheckedCreateWithoutServiceInput> | HomePageSectionItemCreateWithoutServiceInput[] | HomePageSectionItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutServiceInput | HomePageSectionItemCreateOrConnectWithoutServiceInput[]
    createMany?: HomePageSectionItemCreateManyServiceInputEnvelope
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ReviewCreateWithoutServiceInput, ReviewUncheckedCreateWithoutServiceInput> | ReviewCreateWithoutServiceInput[] | ReviewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceInput | ReviewCreateOrConnectWithoutServiceInput[]
    createMany?: ReviewCreateManyServiceInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    upsert?: ServiceCategoryUpsertWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutServicesInput, ServiceCategoryUpdateWithoutServicesInput>, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type OrderItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutServiceInput | OrderItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutServiceInput | OrderItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutServiceInput | OrderItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ServiceCityUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceCityCreateWithoutServiceInput, ServiceCityUncheckedCreateWithoutServiceInput> | ServiceCityCreateWithoutServiceInput[] | ServiceCityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutServiceInput | ServiceCityCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceCityUpsertWithWhereUniqueWithoutServiceInput | ServiceCityUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceCityCreateManyServiceInputEnvelope
    set?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    disconnect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    delete?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    update?: ServiceCityUpdateWithWhereUniqueWithoutServiceInput | ServiceCityUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceCityUpdateManyWithWhereWithoutServiceInput | ServiceCityUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceCityScalarWhereInput | ServiceCityScalarWhereInput[]
  }

  export type HomePageSectionItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<HomePageSectionItemCreateWithoutServiceInput, HomePageSectionItemUncheckedCreateWithoutServiceInput> | HomePageSectionItemCreateWithoutServiceInput[] | HomePageSectionItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutServiceInput | HomePageSectionItemCreateOrConnectWithoutServiceInput[]
    upsert?: HomePageSectionItemUpsertWithWhereUniqueWithoutServiceInput | HomePageSectionItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: HomePageSectionItemCreateManyServiceInputEnvelope
    set?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    disconnect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    delete?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    update?: HomePageSectionItemUpdateWithWhereUniqueWithoutServiceInput | HomePageSectionItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: HomePageSectionItemUpdateManyWithWhereWithoutServiceInput | HomePageSectionItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ReviewCreateWithoutServiceInput, ReviewUncheckedCreateWithoutServiceInput> | ReviewCreateWithoutServiceInput[] | ReviewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceInput | ReviewCreateOrConnectWithoutServiceInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutServiceInput | ReviewUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ReviewCreateManyServiceInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutServiceInput | ReviewUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutServiceInput | ReviewUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput> | OrderItemCreateWithoutServiceInput[] | OrderItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutServiceInput | OrderItemCreateOrConnectWithoutServiceInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutServiceInput | OrderItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderItemCreateManyServiceInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutServiceInput | OrderItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutServiceInput | OrderItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ServiceCityUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceCityCreateWithoutServiceInput, ServiceCityUncheckedCreateWithoutServiceInput> | ServiceCityCreateWithoutServiceInput[] | ServiceCityUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceCityCreateOrConnectWithoutServiceInput | ServiceCityCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceCityUpsertWithWhereUniqueWithoutServiceInput | ServiceCityUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceCityCreateManyServiceInputEnvelope
    set?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    disconnect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    delete?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    connect?: ServiceCityWhereUniqueInput | ServiceCityWhereUniqueInput[]
    update?: ServiceCityUpdateWithWhereUniqueWithoutServiceInput | ServiceCityUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceCityUpdateManyWithWhereWithoutServiceInput | ServiceCityUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceCityScalarWhereInput | ServiceCityScalarWhereInput[]
  }

  export type HomePageSectionItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<HomePageSectionItemCreateWithoutServiceInput, HomePageSectionItemUncheckedCreateWithoutServiceInput> | HomePageSectionItemCreateWithoutServiceInput[] | HomePageSectionItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HomePageSectionItemCreateOrConnectWithoutServiceInput | HomePageSectionItemCreateOrConnectWithoutServiceInput[]
    upsert?: HomePageSectionItemUpsertWithWhereUniqueWithoutServiceInput | HomePageSectionItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: HomePageSectionItemCreateManyServiceInputEnvelope
    set?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    disconnect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    delete?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    connect?: HomePageSectionItemWhereUniqueInput | HomePageSectionItemWhereUniqueInput[]
    update?: HomePageSectionItemUpdateWithWhereUniqueWithoutServiceInput | HomePageSectionItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: HomePageSectionItemUpdateManyWithWhereWithoutServiceInput | HomePageSectionItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ReviewCreateWithoutServiceInput, ReviewUncheckedCreateWithoutServiceInput> | ReviewCreateWithoutServiceInput[] | ReviewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutServiceInput | ReviewCreateOrConnectWithoutServiceInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutServiceInput | ReviewUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ReviewCreateManyServiceInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutServiceInput | ReviewUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutServiceInput | ReviewUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutCitiesInput = {
    create?: XOR<ServiceCreateWithoutCitiesInput, ServiceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCitiesInput
    connect?: ServiceWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutServicesInput = {
    create?: XOR<CityCreateWithoutServicesInput, CityUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CityCreateOrConnectWithoutServicesInput
    connect?: CityWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<ServiceCreateWithoutCitiesInput, ServiceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCitiesInput
    upsert?: ServiceUpsertWithoutCitiesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutCitiesInput, ServiceUpdateWithoutCitiesInput>, ServiceUncheckedUpdateWithoutCitiesInput>
  }

  export type CityUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<CityCreateWithoutServicesInput, CityUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CityCreateOrConnectWithoutServicesInput
    upsert?: CityUpsertWithoutServicesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutServicesInput, CityUpdateWithoutServicesInput>, CityUncheckedUpdateWithoutServicesInput>
  }

  export type StoryImageCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryImageCreateWithoutStoryInput, StoryImageUncheckedCreateWithoutStoryInput> | StoryImageCreateWithoutStoryInput[] | StoryImageUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryImageCreateOrConnectWithoutStoryInput | StoryImageCreateOrConnectWithoutStoryInput[]
    createMany?: StoryImageCreateManyStoryInputEnvelope
    connect?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
  }

  export type StoryImageUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryImageCreateWithoutStoryInput, StoryImageUncheckedCreateWithoutStoryInput> | StoryImageCreateWithoutStoryInput[] | StoryImageUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryImageCreateOrConnectWithoutStoryInput | StoryImageCreateOrConnectWithoutStoryInput[]
    createMany?: StoryImageCreateManyStoryInputEnvelope
    connect?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
  }

  export type StoryImageUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryImageCreateWithoutStoryInput, StoryImageUncheckedCreateWithoutStoryInput> | StoryImageCreateWithoutStoryInput[] | StoryImageUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryImageCreateOrConnectWithoutStoryInput | StoryImageCreateOrConnectWithoutStoryInput[]
    upsert?: StoryImageUpsertWithWhereUniqueWithoutStoryInput | StoryImageUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryImageCreateManyStoryInputEnvelope
    set?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    disconnect?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    delete?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    connect?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    update?: StoryImageUpdateWithWhereUniqueWithoutStoryInput | StoryImageUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryImageUpdateManyWithWhereWithoutStoryInput | StoryImageUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryImageScalarWhereInput | StoryImageScalarWhereInput[]
  }

  export type StoryImageUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryImageCreateWithoutStoryInput, StoryImageUncheckedCreateWithoutStoryInput> | StoryImageCreateWithoutStoryInput[] | StoryImageUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryImageCreateOrConnectWithoutStoryInput | StoryImageCreateOrConnectWithoutStoryInput[]
    upsert?: StoryImageUpsertWithWhereUniqueWithoutStoryInput | StoryImageUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryImageCreateManyStoryInputEnvelope
    set?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    disconnect?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    delete?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    connect?: StoryImageWhereUniqueInput | StoryImageWhereUniqueInput[]
    update?: StoryImageUpdateWithWhereUniqueWithoutStoryInput | StoryImageUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryImageUpdateManyWithWhereWithoutStoryInput | StoryImageUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryImageScalarWhereInput | StoryImageScalarWhereInput[]
  }

  export type StoryCreateNestedOneWithoutImagesInput = {
    create?: XOR<StoryCreateWithoutImagesInput, StoryUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StoryCreateOrConnectWithoutImagesInput
    connect?: StoryWhereUniqueInput
  }

  export type StoryUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<StoryCreateWithoutImagesInput, StoryUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StoryCreateOrConnectWithoutImagesInput
    upsert?: StoryUpsertWithoutImagesInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutImagesInput, StoryUpdateWithoutImagesInput>, StoryUncheckedUpdateWithoutImagesInput>
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutMasterInput = {
    create?: XOR<OrderCreateWithoutMasterInput, OrderUncheckedCreateWithoutMasterInput> | OrderCreateWithoutMasterInput[] | OrderUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMasterInput | OrderCreateOrConnectWithoutMasterInput[]
    createMany?: OrderCreateManyMasterInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedOneWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    connect?: ReferralWhereUniqueInput
  }

  export type MasterApplicationCreateNestedOneWithoutUserInput = {
    create?: XOR<MasterApplicationCreateWithoutUserInput, MasterApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutUserInput
    connect?: MasterApplicationWhereUniqueInput
  }

  export type MasterApplicationCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<MasterApplicationCreateWithoutProcessedByInput, MasterApplicationUncheckedCreateWithoutProcessedByInput> | MasterApplicationCreateWithoutProcessedByInput[] | MasterApplicationUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutProcessedByInput | MasterApplicationCreateOrConnectWithoutProcessedByInput[]
    createMany?: MasterApplicationCreateManyProcessedByInputEnvelope
    connect?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
  }

  export type PromoCodeUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutManagerInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BugReportCreateNestedManyWithoutUserInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput> | ReviewCreateWithoutAuthorInput[] | ReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAuthorInput | ReviewCreateOrConnectWithoutAuthorInput[]
    createMany?: ReviewCreateManyAuthorInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutMasterInput = {
    create?: XOR<ReviewCreateWithoutMasterInput, ReviewUncheckedCreateWithoutMasterInput> | ReviewCreateWithoutMasterInput[] | ReviewUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMasterInput | ReviewCreateOrConnectWithoutMasterInput[]
    createMany?: ReviewCreateManyMasterInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutMasterInput = {
    create?: XOR<OrderCreateWithoutMasterInput, OrderUncheckedCreateWithoutMasterInput> | OrderCreateWithoutMasterInput[] | OrderUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMasterInput | OrderCreateOrConnectWithoutMasterInput[]
    createMany?: OrderCreateManyMasterInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedOneWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    connect?: ReferralWhereUniqueInput
  }

  export type MasterApplicationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MasterApplicationCreateWithoutUserInput, MasterApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutUserInput
    connect?: MasterApplicationWhereUniqueInput
  }

  export type MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<MasterApplicationCreateWithoutProcessedByInput, MasterApplicationUncheckedCreateWithoutProcessedByInput> | MasterApplicationCreateWithoutProcessedByInput[] | MasterApplicationUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutProcessedByInput | MasterApplicationCreateOrConnectWithoutProcessedByInput[]
    createMany?: MasterApplicationCreateManyProcessedByInputEnvelope
    connect?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
  }

  export type PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BugReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput> | ReviewCreateWithoutAuthorInput[] | ReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAuthorInput | ReviewCreateOrConnectWithoutAuthorInput[]
    createMany?: ReviewCreateManyAuthorInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutMasterInput = {
    create?: XOR<ReviewCreateWithoutMasterInput, ReviewUncheckedCreateWithoutMasterInput> | ReviewCreateWithoutMasterInput[] | ReviewUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMasterInput | ReviewCreateOrConnectWithoutMasterInput[]
    createMany?: ReviewCreateManyMasterInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutUsersInput, CityUpdateWithoutUsersInput>, CityUncheckedUpdateWithoutUsersInput>
  }

  export type OrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutMasterNestedInput = {
    create?: XOR<OrderCreateWithoutMasterInput, OrderUncheckedCreateWithoutMasterInput> | OrderCreateWithoutMasterInput[] | OrderUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMasterInput | OrderCreateOrConnectWithoutMasterInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutMasterInput | OrderUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: OrderCreateManyMasterInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutMasterInput | OrderUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutMasterInput | OrderUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateOneWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    upsert?: ReferralUpsertWithoutReferredInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutReferredInput, ReferralUpdateWithoutReferredInput>, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type MasterApplicationUpdateOneWithoutUserNestedInput = {
    create?: XOR<MasterApplicationCreateWithoutUserInput, MasterApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutUserInput
    upsert?: MasterApplicationUpsertWithoutUserInput
    disconnect?: MasterApplicationWhereInput | boolean
    delete?: MasterApplicationWhereInput | boolean
    connect?: MasterApplicationWhereUniqueInput
    update?: XOR<XOR<MasterApplicationUpdateToOneWithWhereWithoutUserInput, MasterApplicationUpdateWithoutUserInput>, MasterApplicationUncheckedUpdateWithoutUserInput>
  }

  export type MasterApplicationUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<MasterApplicationCreateWithoutProcessedByInput, MasterApplicationUncheckedCreateWithoutProcessedByInput> | MasterApplicationCreateWithoutProcessedByInput[] | MasterApplicationUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutProcessedByInput | MasterApplicationCreateOrConnectWithoutProcessedByInput[]
    upsert?: MasterApplicationUpsertWithWhereUniqueWithoutProcessedByInput | MasterApplicationUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: MasterApplicationCreateManyProcessedByInputEnvelope
    set?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    disconnect?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    delete?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    connect?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    update?: MasterApplicationUpdateWithWhereUniqueWithoutProcessedByInput | MasterApplicationUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: MasterApplicationUpdateManyWithWhereWithoutProcessedByInput | MasterApplicationUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: MasterApplicationScalarWhereInput | MasterApplicationScalarWhereInput[]
  }

  export type PromoCodeUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput | PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput | PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutUserInput | PromoCodeUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutManagerInput | ChatUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutManagerInput | ChatUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutManagerInput | ChatUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BugReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    upsert?: BugReportUpsertWithWhereUniqueWithoutUserInput | BugReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    set?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    disconnect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    delete?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    update?: BugReportUpdateWithWhereUniqueWithoutUserInput | BugReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BugReportUpdateManyWithWhereWithoutUserInput | BugReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput> | ReviewCreateWithoutAuthorInput[] | ReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAuthorInput | ReviewCreateOrConnectWithoutAuthorInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutAuthorInput | ReviewUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReviewCreateManyAuthorInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutAuthorInput | ReviewUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutAuthorInput | ReviewUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutMasterNestedInput = {
    create?: XOR<ReviewCreateWithoutMasterInput, ReviewUncheckedCreateWithoutMasterInput> | ReviewCreateWithoutMasterInput[] | ReviewUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMasterInput | ReviewCreateOrConnectWithoutMasterInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMasterInput | ReviewUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: ReviewCreateManyMasterInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMasterInput | ReviewUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMasterInput | ReviewUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutMasterNestedInput = {
    create?: XOR<OrderCreateWithoutMasterInput, OrderUncheckedCreateWithoutMasterInput> | OrderCreateWithoutMasterInput[] | OrderUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMasterInput | OrderCreateOrConnectWithoutMasterInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutMasterInput | OrderUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: OrderCreateManyMasterInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutMasterInput | OrderUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutMasterInput | OrderUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateOneWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    upsert?: ReferralUpsertWithoutReferredInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutReferredInput, ReferralUpdateWithoutReferredInput>, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type MasterApplicationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MasterApplicationCreateWithoutUserInput, MasterApplicationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutUserInput
    upsert?: MasterApplicationUpsertWithoutUserInput
    disconnect?: MasterApplicationWhereInput | boolean
    delete?: MasterApplicationWhereInput | boolean
    connect?: MasterApplicationWhereUniqueInput
    update?: XOR<XOR<MasterApplicationUpdateToOneWithWhereWithoutUserInput, MasterApplicationUpdateWithoutUserInput>, MasterApplicationUncheckedUpdateWithoutUserInput>
  }

  export type MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<MasterApplicationCreateWithoutProcessedByInput, MasterApplicationUncheckedCreateWithoutProcessedByInput> | MasterApplicationCreateWithoutProcessedByInput[] | MasterApplicationUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: MasterApplicationCreateOrConnectWithoutProcessedByInput | MasterApplicationCreateOrConnectWithoutProcessedByInput[]
    upsert?: MasterApplicationUpsertWithWhereUniqueWithoutProcessedByInput | MasterApplicationUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: MasterApplicationCreateManyProcessedByInputEnvelope
    set?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    disconnect?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    delete?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    connect?: MasterApplicationWhereUniqueInput | MasterApplicationWhereUniqueInput[]
    update?: MasterApplicationUpdateWithWhereUniqueWithoutProcessedByInput | MasterApplicationUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: MasterApplicationUpdateManyWithWhereWithoutProcessedByInput | MasterApplicationUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: MasterApplicationScalarWhereInput | MasterApplicationScalarWhereInput[]
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput | PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput | PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutUserInput | PromoCodeUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutManagerInput | ChatUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutManagerInput | ChatUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutManagerInput | ChatUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BugReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput> | BugReportCreateWithoutUserInput[] | BugReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BugReportCreateOrConnectWithoutUserInput | BugReportCreateOrConnectWithoutUserInput[]
    upsert?: BugReportUpsertWithWhereUniqueWithoutUserInput | BugReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BugReportCreateManyUserInputEnvelope
    set?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    disconnect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    delete?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    connect?: BugReportWhereUniqueInput | BugReportWhereUniqueInput[]
    update?: BugReportUpdateWithWhereUniqueWithoutUserInput | BugReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BugReportUpdateManyWithWhereWithoutUserInput | BugReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput> | ReviewCreateWithoutAuthorInput[] | ReviewUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutAuthorInput | ReviewCreateOrConnectWithoutAuthorInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutAuthorInput | ReviewUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReviewCreateManyAuthorInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutAuthorInput | ReviewUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutAuthorInput | ReviewUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutMasterNestedInput = {
    create?: XOR<ReviewCreateWithoutMasterInput, ReviewUncheckedCreateWithoutMasterInput> | ReviewCreateWithoutMasterInput[] | ReviewUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMasterInput | ReviewCreateOrConnectWithoutMasterInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMasterInput | ReviewUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: ReviewCreateManyMasterInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMasterInput | ReviewUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMasterInput | ReviewUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumBugReportCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportCategory | EnumBugReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportCategoryFilter<$PrismaModel> | $Enums.BugReportCategory
  }

  export type NestedEnumBugReportPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportPriority | EnumBugReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportPriorityFilter<$PrismaModel> | $Enums.BugReportPriority
  }

  export type NestedEnumBugReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportStatus | EnumBugReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportStatusFilter<$PrismaModel> | $Enums.BugReportStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBugReportCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportCategory | EnumBugReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportCategory[] | ListEnumBugReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BugReportCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBugReportCategoryFilter<$PrismaModel>
    _max?: NestedEnumBugReportCategoryFilter<$PrismaModel>
  }

  export type NestedEnumBugReportPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportPriority | EnumBugReportPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportPriority[] | ListEnumBugReportPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportPriorityWithAggregatesFilter<$PrismaModel> | $Enums.BugReportPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBugReportPriorityFilter<$PrismaModel>
    _max?: NestedEnumBugReportPriorityFilter<$PrismaModel>
  }

  export type NestedEnumBugReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BugReportStatus | EnumBugReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BugReportStatus[] | ListEnumBugReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBugReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.BugReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBugReportStatusFilter<$PrismaModel>
    _max?: NestedEnumBugReportStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumChatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatStatus | EnumChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatStatusFilter<$PrismaModel> | $Enums.ChatStatus
  }

  export type NestedEnumChatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatStatus | EnumChatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatStatus[] | ListEnumChatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChatStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatStatusFilter<$PrismaModel>
    _max?: NestedEnumChatStatusFilter<$PrismaModel>
  }

  export type NestedEnumHomePageSectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HomePageSectionType | EnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomePageSectionTypeFilter<$PrismaModel> | $Enums.HomePageSectionType
  }

  export type NestedEnumHomePageSectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HomePageSectionType | EnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomePageSectionType[] | ListEnumHomePageSectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHomePageSectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.HomePageSectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHomePageSectionTypeFilter<$PrismaModel>
    _max?: NestedEnumHomePageSectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumMasterApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterApplicationStatus | EnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterApplicationStatusFilter<$PrismaModel> | $Enums.MasterApplicationStatus
  }

  export type NestedEnumMasterApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MasterApplicationStatus | EnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasterApplicationStatus[] | ListEnumMasterApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMasterApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.MasterApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMasterApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumMasterApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderUrgencyFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderUrgency | EnumOrderUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderUrgencyFilter<$PrismaModel> | $Enums.OrderUrgency
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderUrgencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderUrgency | EnumOrderUrgencyFieldRefInput<$PrismaModel>
    in?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderUrgency[] | ListEnumOrderUrgencyFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderUrgencyWithAggregatesFilter<$PrismaModel> | $Enums.OrderUrgency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderUrgencyFilter<$PrismaModel>
    _max?: NestedEnumOrderUrgencyFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type NestedEnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumReferralStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusFilter<$PrismaModel> | $Enums.ReferralStatus
  }

  export type NestedEnumReferralStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReferralStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralStatusFilter<$PrismaModel>
    _max?: NestedEnumReferralStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutBugReportsInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutBugReportsInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutBugReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
  }

  export type BugReportImageCreateWithoutBugReportInput = {
    id?: string
    imageUrl: string
    order?: number
    createdAt?: Date | string
  }

  export type BugReportImageUncheckedCreateWithoutBugReportInput = {
    id?: string
    imageUrl: string
    order?: number
    createdAt?: Date | string
  }

  export type BugReportImageCreateOrConnectWithoutBugReportInput = {
    where: BugReportImageWhereUniqueInput
    create: XOR<BugReportImageCreateWithoutBugReportInput, BugReportImageUncheckedCreateWithoutBugReportInput>
  }

  export type BugReportImageCreateManyBugReportInputEnvelope = {
    data: BugReportImageCreateManyBugReportInput | BugReportImageCreateManyBugReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBugReportsInput = {
    update: XOR<UserUpdateWithoutBugReportsInput, UserUncheckedUpdateWithoutBugReportsInput>
    create: XOR<UserCreateWithoutBugReportsInput, UserUncheckedCreateWithoutBugReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBugReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBugReportsInput, UserUncheckedUpdateWithoutBugReportsInput>
  }

  export type UserUpdateWithoutBugReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutBugReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type BugReportImageUpsertWithWhereUniqueWithoutBugReportInput = {
    where: BugReportImageWhereUniqueInput
    update: XOR<BugReportImageUpdateWithoutBugReportInput, BugReportImageUncheckedUpdateWithoutBugReportInput>
    create: XOR<BugReportImageCreateWithoutBugReportInput, BugReportImageUncheckedCreateWithoutBugReportInput>
  }

  export type BugReportImageUpdateWithWhereUniqueWithoutBugReportInput = {
    where: BugReportImageWhereUniqueInput
    data: XOR<BugReportImageUpdateWithoutBugReportInput, BugReportImageUncheckedUpdateWithoutBugReportInput>
  }

  export type BugReportImageUpdateManyWithWhereWithoutBugReportInput = {
    where: BugReportImageScalarWhereInput
    data: XOR<BugReportImageUpdateManyMutationInput, BugReportImageUncheckedUpdateManyWithoutBugReportInput>
  }

  export type BugReportImageScalarWhereInput = {
    AND?: BugReportImageScalarWhereInput | BugReportImageScalarWhereInput[]
    OR?: BugReportImageScalarWhereInput[]
    NOT?: BugReportImageScalarWhereInput | BugReportImageScalarWhereInput[]
    id?: StringFilter<"BugReportImage"> | string
    bugReportId?: StringFilter<"BugReportImage"> | string
    imageUrl?: StringFilter<"BugReportImage"> | string
    order?: IntFilter<"BugReportImage"> | number
    createdAt?: DateTimeFilter<"BugReportImage"> | Date | string
  }

  export type BugReportCreateWithoutImagesInput = {
    id?: string
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBugReportsInput
  }

  export type BugReportUncheckedCreateWithoutImagesInput = {
    id?: string
    userId?: string | null
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type BugReportCreateOrConnectWithoutImagesInput = {
    where: BugReportWhereUniqueInput
    create: XOR<BugReportCreateWithoutImagesInput, BugReportUncheckedCreateWithoutImagesInput>
  }

  export type BugReportUpsertWithoutImagesInput = {
    update: XOR<BugReportUpdateWithoutImagesInput, BugReportUncheckedUpdateWithoutImagesInput>
    create: XOR<BugReportCreateWithoutImagesInput, BugReportUncheckedCreateWithoutImagesInput>
    where?: BugReportWhereInput
  }

  export type BugReportUpdateToOneWithWhereWithoutImagesInput = {
    where?: BugReportWhereInput
    data: XOR<BugReportUpdateWithoutImagesInput, BugReportUncheckedUpdateWithoutImagesInput>
  }

  export type BugReportUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBugReportsNestedInput
  }

  export type BugReportUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutChatsAsUserInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutChatsAsUserInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutChatsAsUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsAsUserInput, UserUncheckedCreateWithoutChatsAsUserInput>
  }

  export type UserCreateWithoutChatsAsManagerInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutChatsAsManagerInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutChatsAsManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsAsManagerInput, UserUncheckedCreateWithoutChatsAsManagerInput>
  }

  export type ChatMessageCreateWithoutChatInput = {
    id?: string
    text: string
    isFromUser?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutChatInput = {
    id?: string
    text: string
    isFromUser?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageCreateManyChatInputEnvelope = {
    data: ChatMessageCreateManyChatInput | ChatMessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatsAsUserInput = {
    update: XOR<UserUpdateWithoutChatsAsUserInput, UserUncheckedUpdateWithoutChatsAsUserInput>
    create: XOR<UserCreateWithoutChatsAsUserInput, UserUncheckedCreateWithoutChatsAsUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsAsUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsAsUserInput, UserUncheckedUpdateWithoutChatsAsUserInput>
  }

  export type UserUpdateWithoutChatsAsUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsAsUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserUpsertWithoutChatsAsManagerInput = {
    update: XOR<UserUpdateWithoutChatsAsManagerInput, UserUncheckedUpdateWithoutChatsAsManagerInput>
    create: XOR<UserCreateWithoutChatsAsManagerInput, UserUncheckedCreateWithoutChatsAsManagerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsAsManagerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsAsManagerInput, UserUncheckedUpdateWithoutChatsAsManagerInput>
  }

  export type UserUpdateWithoutChatsAsManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsAsManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutChatInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    chatId?: StringFilter<"ChatMessage"> | string
    text?: StringFilter<"ChatMessage"> | string
    isFromUser?: BoolFilter<"ChatMessage"> | boolean
    readAt?: DateTimeNullableFilter<"ChatMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutChatsAsUserInput
    manager?: UserCreateNestedOneWithoutChatsAsManagerInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    managerId?: string | null
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChatsAsUserNestedInput
    manager?: UserUpdateOneWithoutChatsAsManagerNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCityCreateWithoutCityInput = {
    id?: string
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutCitiesInput
  }

  export type ServiceCityUncheckedCreateWithoutCityInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type ServiceCityCreateOrConnectWithoutCityInput = {
    where: ServiceCityWhereUniqueInput
    create: XOR<ServiceCityCreateWithoutCityInput, ServiceCityUncheckedCreateWithoutCityInput>
  }

  export type ServiceCityCreateManyCityInputEnvelope = {
    data: ServiceCityCreateManyCityInput | ServiceCityCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCityInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    rating?: FloatNullableFilter<"User"> | number | null
    reviewsCount?: IntNullableFilter<"User"> | number | null
    isActive?: BoolNullableFilter<"User"> | boolean | null
    cityId?: StringNullableFilter<"User"> | string | null
    pushToken?: StringNullableFilter<"User"> | string | null
    referralCode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ServiceCityUpsertWithWhereUniqueWithoutCityInput = {
    where: ServiceCityWhereUniqueInput
    update: XOR<ServiceCityUpdateWithoutCityInput, ServiceCityUncheckedUpdateWithoutCityInput>
    create: XOR<ServiceCityCreateWithoutCityInput, ServiceCityUncheckedCreateWithoutCityInput>
  }

  export type ServiceCityUpdateWithWhereUniqueWithoutCityInput = {
    where: ServiceCityWhereUniqueInput
    data: XOR<ServiceCityUpdateWithoutCityInput, ServiceCityUncheckedUpdateWithoutCityInput>
  }

  export type ServiceCityUpdateManyWithWhereWithoutCityInput = {
    where: ServiceCityScalarWhereInput
    data: XOR<ServiceCityUpdateManyMutationInput, ServiceCityUncheckedUpdateManyWithoutCityInput>
  }

  export type ServiceCityScalarWhereInput = {
    AND?: ServiceCityScalarWhereInput | ServiceCityScalarWhereInput[]
    OR?: ServiceCityScalarWhereInput[]
    NOT?: ServiceCityScalarWhereInput | ServiceCityScalarWhereInput[]
    id?: StringFilter<"ServiceCity"> | string
    serviceId?: StringFilter<"ServiceCity"> | string
    cityId?: StringFilter<"ServiceCity"> | string
    createdAt?: DateTimeFilter<"ServiceCity"> | Date | string
  }

  export type HomePageSectionItemCreateWithoutSectionInput = {
    id?: string
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ServiceCategoryCreateNestedOneWithoutHomePageItemsInput
    service?: ServiceCreateNestedOneWithoutHomePageItemsInput
  }

  export type HomePageSectionItemUncheckedCreateWithoutSectionInput = {
    id?: string
    categoryId?: string | null
    serviceId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemCreateOrConnectWithoutSectionInput = {
    where: HomePageSectionItemWhereUniqueInput
    create: XOR<HomePageSectionItemCreateWithoutSectionInput, HomePageSectionItemUncheckedCreateWithoutSectionInput>
  }

  export type HomePageSectionItemCreateManySectionInputEnvelope = {
    data: HomePageSectionItemCreateManySectionInput | HomePageSectionItemCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type HomePageSectionItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: HomePageSectionItemWhereUniqueInput
    update: XOR<HomePageSectionItemUpdateWithoutSectionInput, HomePageSectionItemUncheckedUpdateWithoutSectionInput>
    create: XOR<HomePageSectionItemCreateWithoutSectionInput, HomePageSectionItemUncheckedCreateWithoutSectionInput>
  }

  export type HomePageSectionItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: HomePageSectionItemWhereUniqueInput
    data: XOR<HomePageSectionItemUpdateWithoutSectionInput, HomePageSectionItemUncheckedUpdateWithoutSectionInput>
  }

  export type HomePageSectionItemUpdateManyWithWhereWithoutSectionInput = {
    where: HomePageSectionItemScalarWhereInput
    data: XOR<HomePageSectionItemUpdateManyMutationInput, HomePageSectionItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type HomePageSectionItemScalarWhereInput = {
    AND?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
    OR?: HomePageSectionItemScalarWhereInput[]
    NOT?: HomePageSectionItemScalarWhereInput | HomePageSectionItemScalarWhereInput[]
    id?: StringFilter<"HomePageSectionItem"> | string
    sectionId?: StringFilter<"HomePageSectionItem"> | string
    categoryId?: StringNullableFilter<"HomePageSectionItem"> | string | null
    serviceId?: StringNullableFilter<"HomePageSectionItem"> | string | null
    imageUrl?: StringNullableFilter<"HomePageSectionItem"> | string | null
    order?: IntFilter<"HomePageSectionItem"> | number
    createdAt?: DateTimeFilter<"HomePageSectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"HomePageSectionItem"> | Date | string
  }

  export type HomePageSectionCreateWithoutItemsInput = {
    id?: string
    type: $Enums.HomePageSectionType
    title?: string | null
    icon?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionUncheckedCreateWithoutItemsInput = {
    id?: string
    type: $Enums.HomePageSectionType
    title?: string | null
    icon?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionCreateOrConnectWithoutItemsInput = {
    where: HomePageSectionWhereUniqueInput
    create: XOR<HomePageSectionCreateWithoutItemsInput, HomePageSectionUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCategoryCreateWithoutHomePageItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateWithoutHomePageItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryCreateOrConnectWithoutHomePageItemsInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutHomePageItemsInput, ServiceCategoryUncheckedCreateWithoutHomePageItemsInput>
  }

  export type ServiceCreateWithoutHomePageItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    orders?: OrderItemCreateNestedManyWithoutServiceInput
    cities?: ServiceCityCreateNestedManyWithoutServiceInput
    reviews?: ReviewCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutHomePageItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
    cities?: ServiceCityUncheckedCreateNestedManyWithoutServiceInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutHomePageItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutHomePageItemsInput, ServiceUncheckedCreateWithoutHomePageItemsInput>
  }

  export type HomePageSectionUpsertWithoutItemsInput = {
    update: XOR<HomePageSectionUpdateWithoutItemsInput, HomePageSectionUncheckedUpdateWithoutItemsInput>
    create: XOR<HomePageSectionCreateWithoutItemsInput, HomePageSectionUncheckedCreateWithoutItemsInput>
    where?: HomePageSectionWhereInput
  }

  export type HomePageSectionUpdateToOneWithWhereWithoutItemsInput = {
    where?: HomePageSectionWhereInput
    data: XOR<HomePageSectionUpdateWithoutItemsInput, HomePageSectionUncheckedUpdateWithoutItemsInput>
  }

  export type HomePageSectionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHomePageSectionTypeFieldUpdateOperationsInput | $Enums.HomePageSectionType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumHomePageSectionTypeFieldUpdateOperationsInput | $Enums.HomePageSectionType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUpsertWithoutHomePageItemsInput = {
    update: XOR<ServiceCategoryUpdateWithoutHomePageItemsInput, ServiceCategoryUncheckedUpdateWithoutHomePageItemsInput>
    create: XOR<ServiceCategoryCreateWithoutHomePageItemsInput, ServiceCategoryUncheckedCreateWithoutHomePageItemsInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutHomePageItemsInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutHomePageItemsInput, ServiceCategoryUncheckedUpdateWithoutHomePageItemsInput>
  }

  export type ServiceCategoryUpdateWithoutHomePageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateWithoutHomePageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceUpsertWithoutHomePageItemsInput = {
    update: XOR<ServiceUpdateWithoutHomePageItemsInput, ServiceUncheckedUpdateWithoutHomePageItemsInput>
    create: XOR<ServiceCreateWithoutHomePageItemsInput, ServiceUncheckedCreateWithoutHomePageItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutHomePageItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutHomePageItemsInput, ServiceUncheckedUpdateWithoutHomePageItemsInput>
  }

  export type ServiceUpdateWithoutHomePageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    orders?: OrderItemUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutHomePageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUncheckedUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutProcessedApplicationsInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutProcessedApplicationsInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutProcessedApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
  }

  export type UserCreateWithoutMasterApplicationInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutMasterApplicationInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutMasterApplicationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMasterApplicationInput, UserUncheckedCreateWithoutMasterApplicationInput>
  }

  export type UserUpsertWithoutProcessedApplicationsInput = {
    update: XOR<UserUpdateWithoutProcessedApplicationsInput, UserUncheckedUpdateWithoutProcessedApplicationsInput>
    create: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedApplicationsInput, UserUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type UserUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserUpsertWithoutMasterApplicationInput = {
    update: XOR<UserUpdateWithoutMasterApplicationInput, UserUncheckedUpdateWithoutMasterApplicationInput>
    create: XOR<UserCreateWithoutMasterApplicationInput, UserUncheckedCreateWithoutMasterApplicationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMasterApplicationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMasterApplicationInput, UserUncheckedUpdateWithoutMasterApplicationInput>
  }

  export type UserUpdateWithoutMasterApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutMasterApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserCreateWithoutOrdersAsClientInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutOrdersAsClientInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutOrdersAsClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersAsClientInput, UserUncheckedCreateWithoutOrdersAsClientInput>
  }

  export type UserCreateWithoutOrdersAsMasterInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutOrdersAsMasterInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutOrdersAsMasterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersAsMasterInput, UserUncheckedCreateWithoutOrdersAsMasterInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity?: number
    price: number
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutOrdersInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    serviceId: string
    quantity?: number
    price: number
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderStepCreateWithoutOrderInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StepStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderStepUncheckedCreateWithoutOrderInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StepStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderStepCreateOrConnectWithoutOrderInput = {
    where: OrderStepWhereUniqueInput
    create: XOR<OrderStepCreateWithoutOrderInput, OrderStepUncheckedCreateWithoutOrderInput>
  }

  export type OrderStepCreateManyOrderInputEnvelope = {
    data: OrderStepCreateManyOrderInput | OrderStepCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutOrderInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutReviewsInput
    author: UserCreateNestedOneWithoutReviewsGivenInput
    master?: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutOrderInput = {
    id?: string
    serviceId: string
    authorId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersAsClientInput = {
    update: XOR<UserUpdateWithoutOrdersAsClientInput, UserUncheckedUpdateWithoutOrdersAsClientInput>
    create: XOR<UserCreateWithoutOrdersAsClientInput, UserUncheckedCreateWithoutOrdersAsClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersAsClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersAsClientInput, UserUncheckedUpdateWithoutOrdersAsClientInput>
  }

  export type UserUpdateWithoutOrdersAsClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersAsClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserUpsertWithoutOrdersAsMasterInput = {
    update: XOR<UserUpdateWithoutOrdersAsMasterInput, UserUncheckedUpdateWithoutOrdersAsMasterInput>
    create: XOR<UserCreateWithoutOrdersAsMasterInput, UserUncheckedCreateWithoutOrdersAsMasterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersAsMasterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersAsMasterInput, UserUncheckedUpdateWithoutOrdersAsMasterInput>
  }

  export type UserUpdateWithoutOrdersAsMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersAsMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    serviceId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type OrderStepUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderStepWhereUniqueInput
    update: XOR<OrderStepUpdateWithoutOrderInput, OrderStepUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderStepCreateWithoutOrderInput, OrderStepUncheckedCreateWithoutOrderInput>
  }

  export type OrderStepUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderStepWhereUniqueInput
    data: XOR<OrderStepUpdateWithoutOrderInput, OrderStepUncheckedUpdateWithoutOrderInput>
  }

  export type OrderStepUpdateManyWithWhereWithoutOrderInput = {
    where: OrderStepScalarWhereInput
    data: XOR<OrderStepUpdateManyMutationInput, OrderStepUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderStepScalarWhereInput = {
    AND?: OrderStepScalarWhereInput | OrderStepScalarWhereInput[]
    OR?: OrderStepScalarWhereInput[]
    NOT?: OrderStepScalarWhereInput | OrderStepScalarWhereInput[]
    id?: StringFilter<"OrderStep"> | string
    orderId?: StringFilter<"OrderStep"> | string
    title?: StringFilter<"OrderStep"> | string
    description?: StringNullableFilter<"OrderStep"> | string | null
    status?: EnumStepStatusFilter<"OrderStep"> | $Enums.StepStatus
    completedAt?: DateTimeNullableFilter<"OrderStep"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderStep"> | Date | string
  }

  export type ReviewUpsertWithoutOrderInput = {
    update: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutOrderInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutReviewsNestedInput
    author?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    master?: UserUpdateOneWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    client?: UserCreateNestedOneWithoutOrdersAsClientInput
    master?: UserCreateNestedOneWithoutOrdersAsMasterInput
    steps?: OrderStepCreateNestedManyWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    steps?: OrderStepUncheckedCreateNestedManyWithoutOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    cities?: ServiceCityCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutServiceInput
    reviews?: ReviewCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: ServiceCityUncheckedCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutServiceInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutOrdersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: UserUpdateOneWithoutOrdersAsClientNestedInput
    master?: UserUpdateOneWithoutOrdersAsMasterNestedInput
    steps?: OrderStepUpdateManyWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: OrderStepUncheckedUpdateManyWithoutOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ServiceUpsertWithoutOrdersInput = {
    update: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type ServiceUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    cities?: ServiceCityUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: ServiceCityUncheckedUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type OrderCreateWithoutStepsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    client?: UserCreateNestedOneWithoutOrdersAsClientInput
    master?: UserCreateNestedOneWithoutOrdersAsMasterInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStepsInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStepsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStepsInput, OrderUncheckedCreateWithoutStepsInput>
  }

  export type OrderUpsertWithoutStepsInput = {
    update: XOR<OrderUpdateWithoutStepsInput, OrderUncheckedUpdateWithoutStepsInput>
    create: XOR<OrderCreateWithoutStepsInput, OrderUncheckedCreateWithoutStepsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutStepsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutStepsInput, OrderUncheckedUpdateWithoutStepsInput>
  }

  export type OrderUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: UserUpdateOneWithoutOrdersAsClientNestedInput
    master?: UserUpdateOneWithoutOrdersAsMasterNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type PromoCodeUsageCreateWithoutPromoCodeInput = {
    id?: string
    points?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPromoCodeUsagesInput
  }

  export type PromoCodeUsageUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    userId: string
    points?: number
    createdAt?: Date | string
  }

  export type PromoCodeUsageCreateOrConnectWithoutPromoCodeInput = {
    where: PromoCodeUsageWhereUniqueInput
    create: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput>
  }

  export type PromoCodeUsageCreateManyPromoCodeInputEnvelope = {
    data: PromoCodeUsageCreateManyPromoCodeInput | PromoCodeUsageCreateManyPromoCodeInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: PromoCodeUsageWhereUniqueInput
    update: XOR<PromoCodeUsageUpdateWithoutPromoCodeInput, PromoCodeUsageUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput>
  }

  export type PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: PromoCodeUsageWhereUniqueInput
    data: XOR<PromoCodeUsageUpdateWithoutPromoCodeInput, PromoCodeUsageUncheckedUpdateWithoutPromoCodeInput>
  }

  export type PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput = {
    where: PromoCodeUsageScalarWhereInput
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type PromoCodeUsageScalarWhereInput = {
    AND?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
    OR?: PromoCodeUsageScalarWhereInput[]
    NOT?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
    id?: StringFilter<"PromoCodeUsage"> | string
    promoCodeId?: StringFilter<"PromoCodeUsage"> | string
    userId?: StringFilter<"PromoCodeUsage"> | string
    points?: IntFilter<"PromoCodeUsage"> | number
    createdAt?: DateTimeFilter<"PromoCodeUsage"> | Date | string
  }

  export type PromoCodeCreateWithoutUsagesInput = {
    id?: string
    code: string
    description?: string | null
    points?: number
    discount?: number | null
    discountType?: string | null
    minAmount?: number | null
    maxDiscount?: number | null
    expiresAt?: Date | string | null
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutUsagesInput = {
    id?: string
    code: string
    description?: string | null
    points?: number
    discount?: number | null
    discountType?: string | null
    minAmount?: number | null
    maxDiscount?: number | null
    expiresAt?: Date | string | null
    usageLimit?: number | null
    usedCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutUsagesInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutUsagesInput, PromoCodeUncheckedCreateWithoutUsagesInput>
  }

  export type UserCreateWithoutPromoCodeUsagesInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutPromoCodeUsagesInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutPromoCodeUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPromoCodeUsagesInput, UserUncheckedCreateWithoutPromoCodeUsagesInput>
  }

  export type PromoCodeUpsertWithoutUsagesInput = {
    update: XOR<PromoCodeUpdateWithoutUsagesInput, PromoCodeUncheckedUpdateWithoutUsagesInput>
    create: XOR<PromoCodeCreateWithoutUsagesInput, PromoCodeUncheckedCreateWithoutUsagesInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutUsagesInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutUsagesInput, PromoCodeUncheckedUpdateWithoutUsagesInput>
  }

  export type PromoCodeUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maxDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPromoCodeUsagesInput = {
    update: XOR<UserUpdateWithoutPromoCodeUsagesInput, UserUncheckedUpdateWithoutPromoCodeUsagesInput>
    create: XOR<UserCreateWithoutPromoCodeUsagesInput, UserUncheckedCreateWithoutPromoCodeUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPromoCodeUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPromoCodeUsagesInput, UserUncheckedUpdateWithoutPromoCodeUsagesInput>
  }

  export type UserUpdateWithoutPromoCodeUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutPromoCodeUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutReferredInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutReferredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredInput, UserUncheckedCreateWithoutReferredInput>
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserUpsertWithoutReferredInput = {
    update: XOR<UserUpdateWithoutReferredInput, UserUncheckedUpdateWithoutReferredInput>
    create: XOR<UserCreateWithoutReferredInput, UserUncheckedCreateWithoutReferredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredInput, UserUncheckedUpdateWithoutReferredInput>
  }

  export type UserUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type OrderCreateWithoutReviewInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    client?: UserCreateNestedOneWithoutOrdersAsClientInput
    master?: UserCreateNestedOneWithoutOrdersAsMasterInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    steps?: OrderStepCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReviewInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    steps?: OrderStepUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReviewInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
  }

  export type ServiceCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    orders?: OrderItemCreateNestedManyWithoutServiceInput
    cities?: ServiceCityCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
    cities?: ServiceCityUncheckedCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutReviewsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutReviewsInput, ServiceUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsGivenInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsReceived?: ReviewCreateNestedManyWithoutMasterInput
  }

  export type UserUncheckedCreateWithoutReviewsGivenInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutMasterInput
  }

  export type UserCreateOrConnectWithoutReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
  }

  export type UserCreateWithoutReviewsReceivedInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutUsersInput
    ordersAsClient?: OrderCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderCreateNestedManyWithoutMasterInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referred?: ReferralCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatCreateNestedManyWithoutManagerInput
    bugReports?: BugReportCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutReviewsReceivedInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    cityId?: string | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ordersAsClient?: OrderUncheckedCreateNestedManyWithoutClientInput
    ordersAsMaster?: OrderUncheckedCreateNestedManyWithoutMasterInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referred?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    masterApplication?: MasterApplicationUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: MasterApplicationUncheckedCreateNestedManyWithoutProcessedByInput
    promoCodeUsages?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    chatsAsUser?: ChatUncheckedCreateNestedManyWithoutUserInput
    chatsAsManager?: ChatUncheckedCreateNestedManyWithoutManagerInput
    bugReports?: BugReportUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutReviewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
  }

  export type OrderUpsertWithoutReviewInput = {
    update: XOR<OrderUpdateWithoutReviewInput, OrderUncheckedUpdateWithoutReviewInput>
    create: XOR<OrderCreateWithoutReviewInput, OrderUncheckedCreateWithoutReviewInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReviewInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReviewInput, OrderUncheckedUpdateWithoutReviewInput>
  }

  export type OrderUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: UserUpdateOneWithoutOrdersAsClientNestedInput
    master?: UserUpdateOneWithoutOrdersAsMasterNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ServiceUpsertWithoutReviewsInput = {
    update: XOR<ServiceUpdateWithoutReviewsInput, ServiceUncheckedUpdateWithoutReviewsInput>
    create: XOR<ServiceCreateWithoutReviewsInput, ServiceUncheckedCreateWithoutReviewsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutReviewsInput, ServiceUncheckedUpdateWithoutReviewsInput>
  }

  export type ServiceUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    orders?: OrderItemUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUncheckedUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutReviewsGivenInput = {
    update: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserUpsertWithoutReviewsReceivedInput = {
    update: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type UserUpdateWithoutReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutUsersNestedInput
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ServiceCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderItemCreateNestedManyWithoutServiceInput
    cities?: ServiceCityCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutServiceInput
    reviews?: ReviewCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
    cities?: ServiceCityUncheckedCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutServiceInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type HomePageSectionItemCreateWithoutCategoryInput = {
    id?: string
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: HomePageSectionCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutHomePageItemsInput
  }

  export type HomePageSectionItemUncheckedCreateWithoutCategoryInput = {
    id?: string
    sectionId: string
    serviceId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemCreateOrConnectWithoutCategoryInput = {
    where: HomePageSectionItemWhereUniqueInput
    create: XOR<HomePageSectionItemCreateWithoutCategoryInput, HomePageSectionItemUncheckedCreateWithoutCategoryInput>
  }

  export type HomePageSectionItemCreateManyCategoryInputEnvelope = {
    data: HomePageSectionItemCreateManyCategoryInput | HomePageSectionItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: FloatNullableFilter<"Service"> | number | null
    image?: StringNullableFilter<"Service"> | string | null
    time?: StringNullableFilter<"Service"> | string | null
    categoryId?: StringFilter<"Service"> | string
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type HomePageSectionItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: HomePageSectionItemWhereUniqueInput
    update: XOR<HomePageSectionItemUpdateWithoutCategoryInput, HomePageSectionItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<HomePageSectionItemCreateWithoutCategoryInput, HomePageSectionItemUncheckedCreateWithoutCategoryInput>
  }

  export type HomePageSectionItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: HomePageSectionItemWhereUniqueInput
    data: XOR<HomePageSectionItemUpdateWithoutCategoryInput, HomePageSectionItemUncheckedUpdateWithoutCategoryInput>
  }

  export type HomePageSectionItemUpdateManyWithWhereWithoutCategoryInput = {
    where: HomePageSectionItemScalarWhereInput
    data: XOR<HomePageSectionItemUpdateManyMutationInput, HomePageSectionItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceCategoryCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryCreateOrConnectWithoutServicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type OrderItemCreateWithoutServiceInput = {
    id?: string
    quantity?: number
    price: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutServiceInput = {
    id?: string
    orderId: string
    quantity?: number
    price: number
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemCreateManyServiceInputEnvelope = {
    data: OrderItemCreateManyServiceInput | OrderItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCityCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    city: CityCreateNestedOneWithoutServicesInput
  }

  export type ServiceCityUncheckedCreateWithoutServiceInput = {
    id?: string
    cityId: string
    createdAt?: Date | string
  }

  export type ServiceCityCreateOrConnectWithoutServiceInput = {
    where: ServiceCityWhereUniqueInput
    create: XOR<ServiceCityCreateWithoutServiceInput, ServiceCityUncheckedCreateWithoutServiceInput>
  }

  export type ServiceCityCreateManyServiceInputEnvelope = {
    data: ServiceCityCreateManyServiceInput | ServiceCityCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type HomePageSectionItemCreateWithoutServiceInput = {
    id?: string
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    section: HomePageSectionCreateNestedOneWithoutItemsInput
    category?: ServiceCategoryCreateNestedOneWithoutHomePageItemsInput
  }

  export type HomePageSectionItemUncheckedCreateWithoutServiceInput = {
    id?: string
    sectionId: string
    categoryId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemCreateOrConnectWithoutServiceInput = {
    where: HomePageSectionItemWhereUniqueInput
    create: XOR<HomePageSectionItemCreateWithoutServiceInput, HomePageSectionItemUncheckedCreateWithoutServiceInput>
  }

  export type HomePageSectionItemCreateManyServiceInputEnvelope = {
    data: HomePageSectionItemCreateManyServiceInput | HomePageSectionItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutServiceInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReviewInput
    author: UserCreateNestedOneWithoutReviewsGivenInput
    master?: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutServiceInput = {
    id?: string
    orderId: string
    authorId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutServiceInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutServiceInput, ReviewUncheckedCreateWithoutServiceInput>
  }

  export type ReviewCreateManyServiceInputEnvelope = {
    data: ReviewCreateManyServiceInput | ReviewCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCategoryUpsertWithoutServicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceCategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homePageItems?: HomePageSectionItemUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutServiceInput, OrderItemUncheckedUpdateWithoutServiceInput>
    create: XOR<OrderItemCreateWithoutServiceInput, OrderItemUncheckedCreateWithoutServiceInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutServiceInput, OrderItemUncheckedUpdateWithoutServiceInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutServiceInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCityUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceCityWhereUniqueInput
    update: XOR<ServiceCityUpdateWithoutServiceInput, ServiceCityUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceCityCreateWithoutServiceInput, ServiceCityUncheckedCreateWithoutServiceInput>
  }

  export type ServiceCityUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceCityWhereUniqueInput
    data: XOR<ServiceCityUpdateWithoutServiceInput, ServiceCityUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceCityUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceCityScalarWhereInput
    data: XOR<ServiceCityUpdateManyMutationInput, ServiceCityUncheckedUpdateManyWithoutServiceInput>
  }

  export type HomePageSectionItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: HomePageSectionItemWhereUniqueInput
    update: XOR<HomePageSectionItemUpdateWithoutServiceInput, HomePageSectionItemUncheckedUpdateWithoutServiceInput>
    create: XOR<HomePageSectionItemCreateWithoutServiceInput, HomePageSectionItemUncheckedCreateWithoutServiceInput>
  }

  export type HomePageSectionItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: HomePageSectionItemWhereUniqueInput
    data: XOR<HomePageSectionItemUpdateWithoutServiceInput, HomePageSectionItemUncheckedUpdateWithoutServiceInput>
  }

  export type HomePageSectionItemUpdateManyWithWhereWithoutServiceInput = {
    where: HomePageSectionItemScalarWhereInput
    data: XOR<HomePageSectionItemUpdateManyMutationInput, HomePageSectionItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutServiceInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutServiceInput, ReviewUncheckedUpdateWithoutServiceInput>
    create: XOR<ReviewCreateWithoutServiceInput, ReviewUncheckedCreateWithoutServiceInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutServiceInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutServiceInput, ReviewUncheckedUpdateWithoutServiceInput>
  }

  export type ReviewUpdateManyWithWhereWithoutServiceInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutServiceInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    orderId?: StringFilter<"Review"> | string
    serviceId?: StringFilter<"Review"> | string
    authorId?: StringFilter<"Review"> | string
    masterId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ServiceCreateWithoutCitiesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    orders?: OrderItemCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemCreateNestedManyWithoutServiceInput
    reviews?: ReviewCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderItemUncheckedCreateNestedManyWithoutServiceInput
    homePageItems?: HomePageSectionItemUncheckedCreateNestedManyWithoutServiceInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCitiesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCitiesInput, ServiceUncheckedCreateWithoutCitiesInput>
  }

  export type CityCreateWithoutServicesInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutServicesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutServicesInput, CityUncheckedCreateWithoutServicesInput>
  }

  export type ServiceUpsertWithoutCitiesInput = {
    update: XOR<ServiceUpdateWithoutCitiesInput, ServiceUncheckedUpdateWithoutCitiesInput>
    create: XOR<ServiceCreateWithoutCitiesInput, ServiceUncheckedCreateWithoutCitiesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutCitiesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutCitiesInput, ServiceUncheckedUpdateWithoutCitiesInput>
  }

  export type ServiceUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    orders?: OrderItemUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CityUpsertWithoutServicesInput = {
    update: XOR<CityUpdateWithoutServicesInput, CityUncheckedUpdateWithoutServicesInput>
    create: XOR<CityCreateWithoutServicesInput, CityUncheckedCreateWithoutServicesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutServicesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutServicesInput, CityUncheckedUpdateWithoutServicesInput>
  }

  export type CityUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
  }

  export type StoryImageCreateWithoutStoryInput = {
    id?: string
    image: string
    title?: string | null
    duration?: number
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryImageUncheckedCreateWithoutStoryInput = {
    id?: string
    image: string
    title?: string | null
    duration?: number
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryImageCreateOrConnectWithoutStoryInput = {
    where: StoryImageWhereUniqueInput
    create: XOR<StoryImageCreateWithoutStoryInput, StoryImageUncheckedCreateWithoutStoryInput>
  }

  export type StoryImageCreateManyStoryInputEnvelope = {
    data: StoryImageCreateManyStoryInput | StoryImageCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StoryImageUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryImageWhereUniqueInput
    update: XOR<StoryImageUpdateWithoutStoryInput, StoryImageUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryImageCreateWithoutStoryInput, StoryImageUncheckedCreateWithoutStoryInput>
  }

  export type StoryImageUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryImageWhereUniqueInput
    data: XOR<StoryImageUpdateWithoutStoryInput, StoryImageUncheckedUpdateWithoutStoryInput>
  }

  export type StoryImageUpdateManyWithWhereWithoutStoryInput = {
    where: StoryImageScalarWhereInput
    data: XOR<StoryImageUpdateManyMutationInput, StoryImageUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryImageScalarWhereInput = {
    AND?: StoryImageScalarWhereInput | StoryImageScalarWhereInput[]
    OR?: StoryImageScalarWhereInput[]
    NOT?: StoryImageScalarWhereInput | StoryImageScalarWhereInput[]
    id?: StringFilter<"StoryImage"> | string
    storyId?: StringFilter<"StoryImage"> | string
    image?: StringFilter<"StoryImage"> | string
    title?: StringNullableFilter<"StoryImage"> | string | null
    duration?: IntFilter<"StoryImage"> | number
    order?: IntFilter<"StoryImage"> | number
    createdAt?: DateTimeFilter<"StoryImage"> | Date | string
    updatedAt?: DateTimeFilter<"StoryImage"> | Date | string
  }

  export type StoryCreateWithoutImagesInput = {
    id?: string
    title: string
    image?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryUncheckedCreateWithoutImagesInput = {
    id?: string
    title: string
    image?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryCreateOrConnectWithoutImagesInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutImagesInput, StoryUncheckedCreateWithoutImagesInput>
  }

  export type StoryUpsertWithoutImagesInput = {
    update: XOR<StoryUpdateWithoutImagesInput, StoryUncheckedUpdateWithoutImagesInput>
    create: XOR<StoryCreateWithoutImagesInput, StoryUncheckedCreateWithoutImagesInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutImagesInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutImagesInput, StoryUncheckedUpdateWithoutImagesInput>
  }

  export type StoryUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCityCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    region?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCityUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type OrderCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    master?: UserCreateNestedOneWithoutOrdersAsMasterInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    steps?: OrderStepCreateNestedManyWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    steps?: OrderStepUncheckedCreateNestedManyWithoutOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutClientInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateManyClientInputEnvelope = {
    data: OrderCreateManyClientInput | OrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutMasterInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    client?: UserCreateNestedOneWithoutOrdersAsClientInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    steps?: OrderStepCreateNestedManyWithoutOrderInput
    review?: ReviewCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutMasterInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    steps?: OrderStepUncheckedCreateNestedManyWithoutOrderInput
    review?: ReviewUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutMasterInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutMasterInput, OrderUncheckedCreateWithoutMasterInput>
  }

  export type OrderCreateManyMasterInputEnvelope = {
    data: OrderCreateManyMasterInput | OrderCreateManyMasterInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referred: UserCreateNestedOneWithoutReferredInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    referredId: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredInput = {
    id?: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutReferredInput = {
    id?: string
    referrerId: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
  }

  export type MasterApplicationCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedBy?: UserCreateNestedOneWithoutProcessedApplicationsInput
  }

  export type MasterApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    processedById?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MasterApplicationCreateOrConnectWithoutUserInput = {
    where: MasterApplicationWhereUniqueInput
    create: XOR<MasterApplicationCreateWithoutUserInput, MasterApplicationUncheckedCreateWithoutUserInput>
  }

  export type MasterApplicationCreateWithoutProcessedByInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMasterApplicationInput
  }

  export type MasterApplicationUncheckedCreateWithoutProcessedByInput = {
    id?: string
    userId: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MasterApplicationCreateOrConnectWithoutProcessedByInput = {
    where: MasterApplicationWhereUniqueInput
    create: XOR<MasterApplicationCreateWithoutProcessedByInput, MasterApplicationUncheckedCreateWithoutProcessedByInput>
  }

  export type MasterApplicationCreateManyProcessedByInputEnvelope = {
    data: MasterApplicationCreateManyProcessedByInput | MasterApplicationCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeUsageCreateWithoutUserInput = {
    id?: string
    points?: number
    createdAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutUsagesInput
  }

  export type PromoCodeUsageUncheckedCreateWithoutUserInput = {
    id?: string
    promoCodeId: string
    points?: number
    createdAt?: Date | string
  }

  export type PromoCodeUsageCreateOrConnectWithoutUserInput = {
    where: PromoCodeUsageWhereUniqueInput
    create: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput>
  }

  export type PromoCodeUsageCreateManyUserInputEnvelope = {
    data: PromoCodeUsageCreateManyUserInput | PromoCodeUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    manager?: UserCreateNestedOneWithoutChatsAsManagerInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUserInput = {
    id?: string
    managerId?: string | null
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUserInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatCreateManyUserInputEnvelope = {
    data: ChatCreateManyUserInput | ChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutManagerInput = {
    id?: string
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutChatsAsUserInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutManagerInput = {
    id?: string
    userId: string
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutManagerInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput>
  }

  export type ChatCreateManyManagerInputEnvelope = {
    data: ChatCreateManyManagerInput | ChatCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type BugReportCreateWithoutUserInput = {
    id?: string
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    images?: BugReportImageCreateNestedManyWithoutBugReportInput
  }

  export type BugReportUncheckedCreateWithoutUserInput = {
    id?: string
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    images?: BugReportImageUncheckedCreateNestedManyWithoutBugReportInput
  }

  export type BugReportCreateOrConnectWithoutUserInput = {
    where: BugReportWhereUniqueInput
    create: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput>
  }

  export type BugReportCreateManyUserInputEnvelope = {
    data: BugReportCreateManyUserInput | BugReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutAuthorInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReviewInput
    service: ServiceCreateNestedOneWithoutReviewsInput
    master?: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutAuthorInput = {
    id?: string
    orderId: string
    serviceId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutAuthorInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput>
  }

  export type ReviewCreateManyAuthorInputEnvelope = {
    data: ReviewCreateManyAuthorInput | ReviewCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutMasterInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReviewInput
    service: ServiceCreateNestedOneWithoutReviewsInput
    author: UserCreateNestedOneWithoutReviewsGivenInput
  }

  export type ReviewUncheckedCreateWithoutMasterInput = {
    id?: string
    orderId: string
    serviceId: string
    authorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutMasterInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutMasterInput, ReviewUncheckedCreateWithoutMasterInput>
  }

  export type ReviewCreateManyMasterInputEnvelope = {
    data: ReviewCreateManyMasterInput | ReviewCreateManyMasterInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutUsersInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceCityUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceCityUncheckedUpdateManyWithoutCityNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithWhereWithoutClientInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutClientInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    clientId?: StringNullableFilter<"Order"> | string | null
    masterId?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    recipient?: StringFilter<"Order"> | string
    clientName?: StringFilter<"Order"> | string
    clientPhone?: StringFilter<"Order"> | string
    city?: StringFilter<"Order"> | string
    address?: StringFilter<"Order"> | string
    apartment?: StringNullableFilter<"Order"> | string | null
    isPrivateHouse?: BoolFilter<"Order"> | boolean
    urgency?: EnumOrderUrgencyFilter<"Order"> | $Enums.OrderUrgency
    scheduledDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    scheduledTime?: StringNullableFilter<"Order"> | string | null
    totalPrice?: FloatNullableFilter<"Order"> | number | null
    workDescription?: StringNullableFilter<"Order"> | string | null
    warranty?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    completedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutMasterInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutMasterInput, OrderUncheckedUpdateWithoutMasterInput>
    create: XOR<OrderCreateWithoutMasterInput, OrderUncheckedCreateWithoutMasterInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutMasterInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutMasterInput, OrderUncheckedUpdateWithoutMasterInput>
  }

  export type OrderUpdateManyWithWhereWithoutMasterInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutMasterInput>
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    points?: IntFilter<"Referral"> | number
    status?: EnumReferralStatusFilter<"Referral"> | $Enums.ReferralStatus
    completedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithoutReferredInput = {
    update: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutReferredInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type ReferralUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationUpsertWithoutUserInput = {
    update: XOR<MasterApplicationUpdateWithoutUserInput, MasterApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<MasterApplicationCreateWithoutUserInput, MasterApplicationUncheckedCreateWithoutUserInput>
    where?: MasterApplicationWhereInput
  }

  export type MasterApplicationUpdateToOneWithWhereWithoutUserInput = {
    where?: MasterApplicationWhereInput
    data: XOR<MasterApplicationUpdateWithoutUserInput, MasterApplicationUncheckedUpdateWithoutUserInput>
  }

  export type MasterApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedBy?: UserUpdateOneWithoutProcessedApplicationsNestedInput
  }

  export type MasterApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: MasterApplicationWhereUniqueInput
    update: XOR<MasterApplicationUpdateWithoutProcessedByInput, MasterApplicationUncheckedUpdateWithoutProcessedByInput>
    create: XOR<MasterApplicationCreateWithoutProcessedByInput, MasterApplicationUncheckedCreateWithoutProcessedByInput>
  }

  export type MasterApplicationUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: MasterApplicationWhereUniqueInput
    data: XOR<MasterApplicationUpdateWithoutProcessedByInput, MasterApplicationUncheckedUpdateWithoutProcessedByInput>
  }

  export type MasterApplicationUpdateManyWithWhereWithoutProcessedByInput = {
    where: MasterApplicationScalarWhereInput
    data: XOR<MasterApplicationUpdateManyMutationInput, MasterApplicationUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type MasterApplicationScalarWhereInput = {
    AND?: MasterApplicationScalarWhereInput | MasterApplicationScalarWhereInput[]
    OR?: MasterApplicationScalarWhereInput[]
    NOT?: MasterApplicationScalarWhereInput | MasterApplicationScalarWhereInput[]
    id?: StringFilter<"MasterApplication"> | string
    userId?: StringFilter<"MasterApplication"> | string
    name?: StringFilter<"MasterApplication"> | string
    phone?: StringFilter<"MasterApplication"> | string
    email?: StringNullableFilter<"MasterApplication"> | string | null
    experience?: StringNullableFilter<"MasterApplication"> | string | null
    specialties?: StringNullableListFilter<"MasterApplication">
    description?: StringNullableFilter<"MasterApplication"> | string | null
    status?: EnumMasterApplicationStatusFilter<"MasterApplication"> | $Enums.MasterApplicationStatus
    processedAt?: DateTimeNullableFilter<"MasterApplication"> | Date | string | null
    processedById?: StringNullableFilter<"MasterApplication"> | string | null
    rejectionReason?: StringNullableFilter<"MasterApplication"> | string | null
    createdAt?: DateTimeFilter<"MasterApplication"> | Date | string
    updatedAt?: DateTimeFilter<"MasterApplication"> | Date | string
  }

  export type PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: PromoCodeUsageWhereUniqueInput
    update: XOR<PromoCodeUsageUpdateWithoutUserInput, PromoCodeUsageUncheckedUpdateWithoutUserInput>
    create: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput>
  }

  export type PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: PromoCodeUsageWhereUniqueInput
    data: XOR<PromoCodeUsageUpdateWithoutUserInput, PromoCodeUsageUncheckedUpdateWithoutUserInput>
  }

  export type PromoCodeUsageUpdateManyWithWhereWithoutUserInput = {
    where: PromoCodeUsageScalarWhereInput
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
  }

  export type ChatUpdateManyWithWhereWithoutUserInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
    managerId?: StringNullableFilter<"Chat"> | string | null
    status?: EnumChatStatusFilter<"Chat"> | $Enums.ChatStatus
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
  }

  export type ChatUpsertWithWhereUniqueWithoutManagerInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutManagerInput, ChatUncheckedUpdateWithoutManagerInput>
    create: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutManagerInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutManagerInput, ChatUncheckedUpdateWithoutManagerInput>
  }

  export type ChatUpdateManyWithWhereWithoutManagerInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutManagerInput>
  }

  export type BugReportUpsertWithWhereUniqueWithoutUserInput = {
    where: BugReportWhereUniqueInput
    update: XOR<BugReportUpdateWithoutUserInput, BugReportUncheckedUpdateWithoutUserInput>
    create: XOR<BugReportCreateWithoutUserInput, BugReportUncheckedCreateWithoutUserInput>
  }

  export type BugReportUpdateWithWhereUniqueWithoutUserInput = {
    where: BugReportWhereUniqueInput
    data: XOR<BugReportUpdateWithoutUserInput, BugReportUncheckedUpdateWithoutUserInput>
  }

  export type BugReportUpdateManyWithWhereWithoutUserInput = {
    where: BugReportScalarWhereInput
    data: XOR<BugReportUpdateManyMutationInput, BugReportUncheckedUpdateManyWithoutUserInput>
  }

  export type BugReportScalarWhereInput = {
    AND?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
    OR?: BugReportScalarWhereInput[]
    NOT?: BugReportScalarWhereInput | BugReportScalarWhereInput[]
    id?: StringFilter<"BugReport"> | string
    userId?: StringNullableFilter<"BugReport"> | string | null
    category?: EnumBugReportCategoryFilter<"BugReport"> | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFilter<"BugReport"> | $Enums.BugReportPriority
    status?: EnumBugReportStatusFilter<"BugReport"> | $Enums.BugReportStatus
    description?: StringFilter<"BugReport"> | string
    steps?: StringNullableFilter<"BugReport"> | string | null
    email?: StringFilter<"BugReport"> | string
    logFileUrl?: StringNullableFilter<"BugReport"> | string | null
    createdAt?: DateTimeFilter<"BugReport"> | Date | string
    updatedAt?: DateTimeFilter<"BugReport"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"BugReport"> | Date | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutAuthorInput, ReviewUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutAuthorInput, ReviewUncheckedUpdateWithoutAuthorInput>
  }

  export type ReviewUpdateManyWithWhereWithoutAuthorInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutMasterInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutMasterInput, ReviewUncheckedUpdateWithoutMasterInput>
    create: XOR<ReviewCreateWithoutMasterInput, ReviewUncheckedCreateWithoutMasterInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutMasterInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutMasterInput, ReviewUncheckedUpdateWithoutMasterInput>
  }

  export type ReviewUpdateManyWithWhereWithoutMasterInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutMasterInput>
  }

  export type BugReportImageCreateManyBugReportInput = {
    id?: string
    imageUrl: string
    order?: number
    createdAt?: Date | string
  }

  export type BugReportImageUpdateWithoutBugReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportImageUncheckedUpdateWithoutBugReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BugReportImageUncheckedUpdateManyWithoutBugReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyChatInput = {
    id?: string
    text: string
    isFromUser?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isFromUser?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCityInput = {
    id?: string
    phone: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    rating?: number | null
    reviewsCount?: number | null
    isActive?: boolean | null
    pushToken?: string | null
    referralCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCityCreateManyCityInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordersAsClient?: OrderUncheckedUpdateManyWithoutClientNestedInput
    ordersAsMaster?: OrderUncheckedUpdateManyWithoutMasterNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referred?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    masterApplication?: MasterApplicationUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: MasterApplicationUncheckedUpdateManyWithoutProcessedByNestedInput
    promoCodeUsages?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    chatsAsUser?: ChatUncheckedUpdateManyWithoutUserNestedInput
    chatsAsManager?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    bugReports?: BugReportUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewsCount?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushToken?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutCitiesNestedInput
  }

  export type ServiceCityUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemCreateManySectionInput = {
    id?: string
    categoryId?: string | null
    serviceId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneWithoutHomePageItemsNestedInput
    service?: ServiceUpdateOneWithoutHomePageItemsNestedInput
  }

  export type HomePageSectionItemUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    serviceId: string
    quantity?: number
    price: number
    createdAt?: Date | string
  }

  export type OrderStepCreateManyOrderInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.StepStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStepUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStepUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStepUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageCreateManyPromoCodeInput = {
    id?: string
    userId: string
    points?: number
    createdAt?: Date | string
  }

  export type PromoCodeUsageUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPromoCodeUsagesNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price?: number | null
    image?: string | null
    time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomePageSectionItemCreateManyCategoryInput = {
    id?: string
    sectionId: string
    serviceId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderItemUncheckedUpdateManyWithoutServiceNestedInput
    cities?: ServiceCityUncheckedUpdateManyWithoutServiceNestedInput
    homePageItems?: HomePageSectionItemUncheckedUpdateManyWithoutServiceNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: HomePageSectionUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutHomePageItemsNestedInput
  }

  export type HomePageSectionItemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyServiceInput = {
    id?: string
    orderId: string
    quantity?: number
    price: number
    createdAt?: Date | string
  }

  export type ServiceCityCreateManyServiceInput = {
    id?: string
    cityId: string
    createdAt?: Date | string
  }

  export type HomePageSectionItemCreateManyServiceInput = {
    id?: string
    sectionId: string
    categoryId?: string | null
    imageUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyServiceInput = {
    id?: string
    orderId: string
    authorId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceCityUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCityUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: HomePageSectionUpdateOneRequiredWithoutItemsNestedInput
    category?: ServiceCategoryUpdateOneWithoutHomePageItemsNestedInput
  }

  export type HomePageSectionItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomePageSectionItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    author?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    master?: UserUpdateOneWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryImageCreateManyStoryInput = {
    id?: string
    image: string
    title?: string | null
    duration?: number
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryImageUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryImageUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryImageUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyClientInput = {
    id?: string
    orderNumber: string
    masterId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type OrderCreateManyMasterInput = {
    id?: string
    orderNumber: string
    clientId?: string | null
    status?: $Enums.OrderStatus
    recipient?: string
    clientName: string
    clientPhone: string
    city: string
    address: string
    apartment?: string | null
    isPrivateHouse?: boolean
    urgency?: $Enums.OrderUrgency
    scheduledDate?: Date | string | null
    scheduledTime?: string | null
    totalPrice?: number | null
    workDescription?: string | null
    warranty?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    referredId: string
    points?: number
    status?: $Enums.ReferralStatus
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MasterApplicationCreateManyProcessedByInput = {
    id?: string
    userId: string
    name: string
    phone: string
    email?: string | null
    experience?: string | null
    specialties?: MasterApplicationCreatespecialtiesInput | string[]
    description?: string | null
    status?: $Enums.MasterApplicationStatus
    processedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUsageCreateManyUserInput = {
    id?: string
    promoCodeId: string
    points?: number
    createdAt?: Date | string
  }

  export type ChatCreateManyUserInput = {
    id?: string
    managerId?: string | null
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatCreateManyManagerInput = {
    id?: string
    userId: string
    status?: $Enums.ChatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type BugReportCreateManyUserInput = {
    id?: string
    category: $Enums.BugReportCategory
    priority?: $Enums.BugReportPriority
    status?: $Enums.BugReportStatus
    description: string
    steps?: string | null
    email: string
    logFileUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReviewCreateManyAuthorInput = {
    id?: string
    orderId: string
    serviceId: string
    masterId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyMasterInput = {
    id?: string
    orderId: string
    serviceId: string
    authorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    master?: UserUpdateOneWithoutOrdersAsMasterNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUpdateManyWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUncheckedUpdateManyWithoutOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: UserUpdateOneWithoutOrdersAsClientNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUpdateManyWithoutOrderNestedInput
    review?: ReviewUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    steps?: OrderStepUncheckedUpdateManyWithoutOrderNestedInput
    review?: ReviewUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    recipient?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivateHouse?: BoolFieldUpdateOperationsInput | boolean
    urgency?: EnumOrderUrgencyFieldUpdateOperationsInput | $Enums.OrderUrgency
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referred?: UserUpdateOneRequiredWithoutReferredNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMasterApplicationNestedInput
  }

  export type MasterApplicationUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterApplicationUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: MasterApplicationUpdatespecialtiesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMasterApplicationStatusFieldUpdateOperationsInput | $Enums.MasterApplicationStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager?: UserUpdateOneWithoutChatsAsManagerNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChatsAsUserNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumChatStatusFieldUpdateOperationsInput | $Enums.ChatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BugReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: BugReportImageUpdateManyWithoutBugReportNestedInput
  }

  export type BugReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: BugReportImageUncheckedUpdateManyWithoutBugReportNestedInput
  }

  export type BugReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumBugReportCategoryFieldUpdateOperationsInput | $Enums.BugReportCategory
    priority?: EnumBugReportPriorityFieldUpdateOperationsInput | $Enums.BugReportPriority
    status?: EnumBugReportStatusFieldUpdateOperationsInput | $Enums.BugReportStatus
    description?: StringFieldUpdateOperationsInput | string
    steps?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    logFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    service?: ServiceUpdateOneRequiredWithoutReviewsNestedInput
    master?: UserUpdateOneWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    masterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReviewNestedInput
    service?: ServiceUpdateOneRequiredWithoutReviewsNestedInput
    author?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
  }

  export type ReviewUncheckedUpdateWithoutMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}